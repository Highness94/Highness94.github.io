<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/> 
<script src="/live2d/autoload.js"></script>

  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon (1).ico?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="muxin's Blog" type="application/atom+xml" />






<meta name="description" content="网络层(IP) 1. mac和ip怎么转换ARP协议： 将IP地址通过广播 目标MAC地址是FF-FF-FF-FF-FF-FF 解析目标IP地址的MAC地址 扫描本网段MAC地址。 DHCP协议： DHCP租约过程就是DHCP客户机动态获取IP地址的过程。 DHCP租约过程分为4步：  客户机请求IP（客户机发DHCPDISCOVER广播包）； 服务器响应（服务器发DHCPOFFER广播包）； 客">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://yoursite.com/2019/08/31/计算机网络/index.html">
<meta property="og:site_name" content="muxin&#39;s Blog">
<meta property="og:description" content="网络层(IP) 1. mac和ip怎么转换ARP协议： 将IP地址通过广播 目标MAC地址是FF-FF-FF-FF-FF-FF 解析目标IP地址的MAC地址 扫描本网段MAC地址。 DHCP协议： DHCP租约过程就是DHCP客户机动态获取IP地址的过程。 DHCP租约过程分为4步：  客户机请求IP（客户机发DHCPDISCOVER广播包）； 服务器响应（服务器发DHCPOFFER广播包）； 客">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/子网划分.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/os7.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/dta.jpg">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/tcp.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/udp.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/76217b745e45ea3a45337c8cc86c883.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/sanci.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/tcp-4.png">
<meta property="og:image" content="e:/PersonalBlog/source/_posts/计算机网络/https_com.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/fuzai.png">
<meta property="og:image" content="http://yoursite.com/2019/08/31/计算机网络/c44d92b9c250a5365fc228d71d714e9.png">
<meta property="og:updated_time" content="2019-09-15T13:34:44.166Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机网络">
<meta name="twitter:description" content="网络层(IP) 1. mac和ip怎么转换ARP协议： 将IP地址通过广播 目标MAC地址是FF-FF-FF-FF-FF-FF 解析目标IP地址的MAC地址 扫描本网段MAC地址。 DHCP协议： DHCP租约过程就是DHCP客户机动态获取IP地址的过程。 DHCP租约过程分为4步：  客户机请求IP（客户机发DHCPDISCOVER广播包）； 服务器响应（服务器发DHCPOFFER广播包）； 客">
<meta name="twitter:image" content="http://yoursite.com/2019/08/31/计算机网络/子网划分.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '9A6H83NNE8',
      apiKey: '88b14b97a1038f62aa1e4ad1d03ad369',
      indexName: 'search',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/31/计算机网络/"/>

  <script>
    (function(){
        if(''){
            if (prompt('Please enter your password') !== ''){
                alert('wrong password��');
                history.back();
            }
        }
    })();
</script>



  <title>计算机网络 | muxin's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2cb6ba3a1c27ee1fc0a8e6d0dcb28522";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>





<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <script src="https://highness94.github.io/live2d/autoload.js"></script>
  
  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">muxin's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">contact me by email:dreamcore@126.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github-alt"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			
			<!--���ӵĴ��� start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/31/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="muxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="muxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算机网络</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-31T21:43:19+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/31/计算机网络/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/08/31/计算机网络/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="网络层-IP"><a href="#网络层-IP" class="headerlink" title="网络层(IP)"></a>网络层(IP)</h1><blockquote>
<h2 id="1-mac和ip怎么转换"><a href="#1-mac和ip怎么转换" class="headerlink" title="1. mac和ip怎么转换"></a>1. mac和ip怎么转换</h2><p><strong>ARP协议：</strong></p>
<p>将IP地址通过广播 目标MAC地址是FF-FF-FF-FF-FF-FF 解析目标IP地址的MAC地址 扫描本网段MAC地址。</p>
<p><strong>DHCP协议：</strong></p>
<p>DHCP租约过程就是DHCP客户机动态获取IP地址的过程。</p>
<p>DHCP租约过程分为4步：</p>
<ol>
<li>客户机请求IP（客户机发DHCPDISCOVER广播包）；</li>
<li>服务器响应（服务器发DHCPOFFER广播包）；</li>
<li>客户机选择IP（客户机发DHCPREQUEST广播包）；</li>
<li>服务器确定租约（服务器发DHCPACK/DHCPNAK广播包）。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="http://blog.51cto.com/yuanbin/109574" target="_blank" rel="noopener">图解DHCP的4步租约过程-大浪淘沙-51CTO博客</a></li>
</ul>
</blockquote>
<p><img src="/2019/08/31/计算机网络/子网划分.png" alt="子网划分"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">IP分类</span><br><span class="line">公有地址：</span><br><span class="line">IP分类        缺省掩码</span><br><span class="line">A 1－127      /8</span><br><span class="line">B 128－191        /16</span><br><span class="line">C 192－223      /24</span><br><span class="line">D 224－239      组播地址</span><br><span class="line">E 240－247    保留地址</span><br><span class="line">私有地址：</span><br><span class="line">A：10.0.0.0 - 10.255.255.255</span><br><span class="line">B:  172.16.0.0 - 172.31.255.255</span><br><span class="line">C:  192.168.0.0 - 192.168.255.255</span><br><span class="line"></span><br><span class="line">判断合法的主机（IP）地址：</span><br><span class="line">192.168.10.240/24        合法</span><br><span class="line">192.168.10.0/24          不合法，主机位全为0，网络地址</span><br><span class="line">192.168.10.255/24        不合法，主机位全为1，子网广播地址</span><br><span class="line">255.255.255.255              不合法，网络和主机位全为1，全网广播地址</span><br><span class="line">127.x.x.x/8                不合法，本地环回地址</span><br><span class="line">172.16.3.5/24              合法</span><br><span class="line">192.168.5.240/32        合法</span><br><span class="line">224.10.10.10.1              不合法，组播地址</span><br><span class="line">300.2.4.200/24              不合法</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IP特殊地址</p>
<ul>
<li>本地环回地址：127.0.0.0 – 127.255.255.255，测试主机TCP/IP协议栈是否安装正确。</li>
<li>本地链路地址：169.254.0.0 – 169.254.255.255，自动地址无法获取时系统自动配置占位。</li>
<li>受限广播地址：255.255.255.255，发往这个地址的数据不能跨越三层设备，但本地网络内所有的主机都可以接收到数据</li>
</ul>
</blockquote>
<h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><h2 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h2><ol>
<li>路由器可以给你的局域网自动分配IP，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。交换机只是用来分配网络数据的。</li>
<li>路由器在网络层，路由器根据IP地址寻址，路由器可以处理TCP/IP协议，交换机不可以。</li>
<li>交换机在中继层，交换机根据MAC地址寻址。路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。交换机可以把很多主机连起来，这些主机对外各有各的IP。</li>
<li>路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</li>
</ol>
<p>交换机是利用<strong>物理地址或者说MAC地址</strong>来确定转发数据的目的地址。而路由器则是利用不同网络的ID号(即IP地址)来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络，有时这些第三层的地址也称为协议地址或者网络地址。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</p>
<p><strong>路由器和交换机的区别一</strong>：交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响。 <strong>路由器和交换机的区别二</strong>：交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP/IP协议，而交换机不可以。</p>
<p><strong>路由器和交换机的区别三</strong>：交换机可以使连接它的多台电脑组成局域网，如果还有代理服务器的话还可以实现同时上网功能而且局域网所有电脑是共享它的带宽速率的，但是交换机没有路由器的自动识别数据包发送和到达地址的功能。路由器可以自动识别数据包发送和到达的地址，路由器相当于马路上的警察，负责交通疏导和指路的。</p>
<p><strong>路由器和交换机的区别四</strong>：举几个例子,路由器是小邮局，就一个地址(IP)，负责一个地方的收发(个人电脑，某个服务器，所以你家上网要这个东西)，交换机是省里的大邮政中心，负责由一个地址给各个小地方的联系。简单的说路由器专管入网，交换机只管配送，路由路由就是给你找路让你上网的，交换机只负责开门，交换机上面要没有路由你是上不了网的。</p>
<p><strong>路由器和交换机的区别五</strong>：路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p>
<h2 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h2><p>内网中192.168.1.199的前三组是网络号，后一组是主机号，子网掩码就是255.255.255.0</p>
<p><strong>首先要说明的是</strong>：不是某个IP的网络号和主机号决定子网掩码是什么，而是子网掩码决定了某个IP地址的网络号与主机号是什么，IP地址是要搭配子网掩码使用的。例如上面的子网掩码决定了192.168.1.199的前三段192.168.1是网络号，最后一段199是主机号。</p>
<p>我们再来理解子网掩码的作用，先举个例子，市面上的两个厂家都生产电子秤，每个厂家都坚称他们的秤最准，那你是怎么知道他们的秤到底准不准？很简单，你去找一个 1KG 的国际千克原器，各放到他们的秤上测量，如果秤的测量值是1KG，那这把秤就是准的，<strong>子网掩码的作用就相当于这个大家公认的国际千克原器，是我们测量两个IP是否属于同一个网段的一个工具（应该说是让你知道某个IP地址的网络号与主机号分别是什么） 。</strong></p>
<p><strong>如果让你判断一个IP地址：192.168.1.199的网络号和主机号分别是什么？</strong></p>
<p>请问你怎么判断？你凭什么说192.168.1是网络号？199是主机号？有什么根据吗？</p>
<p>但是如果我给你一个IP地址是以下（带子网掩码）形式的：</p>
<p>IP：192.168.1.199</p>
<p>子网掩码：255.255.255.0</p>
<p>那么根据大家公认的规则，你就可以得出这个IP的网络号和主机号了，怎么算呢？</p>
<p>子网掩码的长度和IP地址一样也是一串32位的二进制数字，只不过为人类的可读性和记忆性的方便，通常使用十进制数字来表示，例如把上面的IP地址和子网掩码都转换成相应的二进制就是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**十进制**                   **二进制**</span><br></pre></td></tr></table></figure>
<p>IP 地址：192.168.1.199 <strong>‐＞</strong>11000000.10101000.00000001.11000111</p>
<p>子网掩码：255.255.255.0 <strong>‐＞</strong>11111111.11111111.11111111.00000000</p>
<p>十进制的显示形式是给人看的，二进制的显示形式是给计算机看的。。。</p>
<p>子网掩码的左边是网络位，用二进制数字“1”表示，1的数目等于网络位的长度；右边是主机位，用二进制数字“0”表示，0的数目等于主机位的长度。</p>
<p>例如上面的子网掩码255.255.255.0的 “1”的个数是左边24位，则对应IP地址左边的位数也是24位;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**十进制**                   **二进制**</span><br></pre></td></tr></table></figure>
<p>IP 地址：192.168.1.199 <strong>‐＞11000000.10101000.00000001</strong>.11000111</p>
<p>子网掩码：255.255.255.0 <strong>‐＞11111111.11111111.11111111</strong>.00000000</p>
<p>则这个IP地址的网络号就是11000000.10101000.00000001 ，转换成十进制就是 192.168.1，网掩码255.255.255.0的 “0”的个数是右边8位，则这个IP地址的主机号就是11000111，转换成十进制就是199.</p>
<h1 id="传输层-TCP-UDP"><a href="#传输层-TCP-UDP" class="headerlink" title="传输层(TCP/UDP)"></a>传输层(TCP/UDP)</h1><ol>
<li><p>ISO七层模型中表示层和会话层功能是什么？</p>
<ul>
<li><p>表示层：图像、视频编码解，数据加密。</p>
</li>
<li><p>会话层：建立会话，如session认证、断点续传。</p>
<p><img src="/2019/08/31/计算机网络/os7.png" alt="os7"></p>
</li>
</ul>
<blockquote>
<h3 id="（1）五层协议"><a href="#（1）五层协议" class="headerlink" title="（1）五层协议"></a>（1）五层协议</h3><ul>
<li><p><strong>应用层</strong> ：提供用户接口，特指能够发起网络流量的程序，比如客户端程序：QQ，MSN，浏览器等；服务器程序：web服务器，邮件服务器，流媒体服务器等等。数据单位为报文。</p>
</li>
<li><p>运输层</p>
</li>
</ul>
<p>  ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：</p>
<ul>
<li>传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；</li>
<li>用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。</li>
<li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
</ul>
<ul>
<li>网络层</li>
</ul>
<p>  ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。（负责选择最佳路径 规划IP地址）</p>
<ul>
<li>路由器查看数据包目标IP地址，根据路由表为数据包选择路径。路由表中的类目可以人工添加（静态路由）也可以动态生成（动态路由）。</li>
</ul>
<ul>
<li>数据链路层</li>
</ul>
<p>  ：不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧。能够进行差错检验，但不纠错，监测处错误丢掉该帧。</p>
<ul>
<li>帧的开始和结束，透明传输，差错校验</li>
</ul>
<ul>
<li>物理层</li>
</ul>
<p>  ：物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的主要任务描述为：确定与传输媒体的接口的一些特性，即：</p>
<ul>
<li>机械特性：例接口形状，大小，引线数目</li>
<li>电气特性：例规定电压范围 ( -5V 到 +5V )</li>
<li>功能特性：例规定 -5V 表示 0，＋5V 表示 1</li>
<li>过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤</li>
</ul>
</blockquote>
<h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>　　在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<ol>
<li><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p>
</li>
<li><p>交换机只有下面两层协议</p>
<p><img src="/2019/08/31/计算机网络/dta.jpg" alt="dta"></p>
</li>
</ol>
<h3 id="（4）TCP-IP四层模型"><a href="#（4）TCP-IP四层模型" class="headerlink" title="（4）TCP/IP四层模型"></a>（4）TCP/IP四层模型</h3><p>它只有四层，相当于五层协议中<strong>数据链路层和物理层合并为网络接口层</strong>。</p>
<p>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
</li>
</ol>
<ol>
<li><p>描述TCP头部？</p>
<p><img src="/2019/08/31/计算机网络/tcp.png" alt="tcp"></p>
<ul>
<li><p>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。</p>
</li>
<li><p>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。</p>
</li>
<li><p>首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。</p>
</li>
<li><p>标志位（6bit）：</p>
<ul>
<li>URG：标志紧急指针是否有效。</li>
<li>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li>
<li>PSH：提示接收端立即从缓冲读走数据。</li>
<li>RST：表示要求对方重新建立连接（复位报文段）。</li>
<li>SYN：表示请求建立一个连接（连接报文段）。</li>
<li>FIN：表示关闭连接（断开报文段）。</li>
</ul>
</li>
<li><p>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</p>
</li>
<li><p>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</p>
<p><strong>udp</strong></p>
<p><img src="/2019/08/31/计算机网络/udp.png" alt="udp"></p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
</li>
</ul>
<blockquote>
<ul>
<li><p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信</p>
</li>
<li><p><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TCP和UDP区别？如何改进TCP</span><br><span class="line">TCP和UDP区别</span><br><span class="line">UDP 是无连接的，即发送数据之前不需要建立连接。</span><br><span class="line">UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</span><br><span class="line">UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。</span><br><span class="line">UDP 支持一对一、一对多、多对一和多对多的交互通信。</span><br><span class="line">UDP 的首部开销小，只有 8 个字节。</span><br><span class="line">TCP 是面向连接的运输层协议。</span><br><span class="line">每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。</span><br><span class="line">TCP 提供可靠交付的服务。</span><br><span class="line">TCP 提供全双工通信。</span><br><span class="line">TCP是面向字节流。  </span><br><span class="line">首部最低20个字节。</span><br><span class="line">TCP加快传输效率的方法</span><br><span class="line">采取一块确认的机制</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="TCP和UDP的区别？应用场景都有哪些？"><a href="#TCP和UDP的区别？应用场景都有哪些？" class="headerlink" title="TCP和UDP的区别？应用场景都有哪些？"></a>TCP和UDP的区别？应用场景都有哪些？</h4><p>l   TCP面向连接即发送前需要建立连接，UDP是无连接的即发送数据之前不需要建立连接</p>
<p>l   TCP面向字节流，UTP面向数据包；</p>
<p>l   TCP提供可靠的服务，即通过TCP连接传送的数据无差错不丢失不重复且按序到达，通过校验和、重传控制、序号标识，滑动窗口、确认应答实现可靠传输，如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制；UDP尽最大努力交付即不保证可靠交付。</p>
<p>l   UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<p>l   每一条TCP连接只能是点到点通信；UDP支持一对一、一对多，多对一和多对多的交互通信；</p>
<p>l   TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<p>应用场景：若通信数据需让位且需要通信实时，则应该选用 TCP 协议如文件传输、重要状态的更新等；反之则使用 UDP 协议如视频传输、实时通信等。</p>
<p>UDP：DNS、SNMP</p>
<h4 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h4><p>l   网速快的情况下UDP提供可靠传输，丢包率很低，如果使用应用层重传能确保传输的可靠性。</p>
<p>l   TCP为了实现可靠传输使用复杂的拥塞控制算法和繁琐的握手过程，且TCP内置的系统协议栈中很难改进。一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收后再继续发送，延时会越来越大。UDP具有实时性，采用自定义重传机制能够降低延迟，减少网络问题造成的影响。 </p>
<h4 id="UDP中一个包的大小最大多少？"><a href="#UDP中一个包的大小最大多少？" class="headerlink" title="UDP中一个包的大小最大多少？"></a>UDP中一个包的大小最大多少？</h4><p>l   以太网(Ethernet)数据帧的长度必须在46-1500字节之间，这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区。</p>
<p>l   并不包括链路层的首部和尾部的18个字节.所以,事实上，这个1500字节就是网络层IP数据报的长度限制.因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节。  </p>
<p>而这个1480TCPTCPUDPUDP.UDP8,UDP1472.1472</p>
</blockquote>
<p><img src="/2019/08/31/计算机网络/76217b745e45ea3a45337c8cc86c883.png" alt="76217b745e45ea3a45337c8cc86c883"></p>
</li>
<li><p>三次握手过程？</p>
<p> <img src="/2019/08/31/计算机网络/sanci.png" alt="sanci"></p>
<ul>
<li>第一次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&gt; SYN_SEND）</li>
<li>第二次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -&gt; SYN_RECV）</li>
<li>第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&gt; ESTABLISH，服 -&gt; ESTABLISH）</li>
</ul>
</li>
<li><p>四次挥手过程？</p>
<p><img src="/2019/08/31/计算机网络/tcp-4.png" alt="tcp-4"></p>
<ul>
<li>第一次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&gt; FIN_WAIT_1）</li>
<li>第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&gt; CLOSE_WAIT，客 -&gt; FIN_WAIT_2）<ul>
<li>此处有等待</li>
</ul>
</li>
<li>第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&gt; LAST_ACK，客 -&gt; TIME_WAIT）<ul>
<li>此处有等待</li>
</ul>
</li>
<li>第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -&gt; CLOSED）</li>
</ul>
</li>
<li><p>为什么握手是三次，挥手是四次？</p>
<ul>
<li>对于握手：握手只需要确认双方通信时的初始化序号，保证通信不会乱序。（第三次握手必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同一个客户机保持多个连接，造成资源浪费。）</li>
<li>对于挥手：TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。</li>
</ul>
</li>
<li><p>TCP连接状态？</p>
<ul>
<li>CLOSED：初始状态。</li>
<li>LISTEN：服务器处于监听状态。</li>
<li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li>
<li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li>
<li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li>
<li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li>
<li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li>
<li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li>
<li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li>
<li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li>
</ul>
</li>
<li><p>解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？</p>
<ul>
<li>FIN_WAIT_2：<ul>
<li>半关闭状态。</li>
<li>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li>
</ul>
</li>
<li>CLOSE_WAIT状态：<ul>
<li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li>
<li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。</li>
</ul>
</li>
<li>TIME_WAIT状态：<ul>
<li>又叫2MSL等待状态。</li>
<li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li>
<li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li>
</ul>
</li>
</ul>
</li>
<li><p>解释RTO，RTT和超时重传？</p>
<ul>
<li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul>
<li>发送的数据没能到达接收端，所以对方没有响应。</li>
<li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li>
<li>接收端拒绝或丢弃数据。</li>
</ul>
</li>
<li>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。<ul>
<li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li>
<li>重传次数到达上限之后停止重传。</li>
</ul>
</li>
<li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li>
</ul>
</li>
<li><p>流量控制原理？</p>
<ul>
<li>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li>
<li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。<ul>
<li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li>
<li>接收窗：用来标记可以接收的数据大小。</li>
</ul>
</li>
<li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</li>
<li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li>
</ul>
</li>
<li><p>拥塞控制原理？</p>
<ul>
<li>拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</li>
<li><p>TCP拥塞控制算法：</p>
<ul>
<li><p>慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。</p>
</li>
<li><p>快速重传 &amp; 快速恢复：略。</p>
</li>
<li><p>最终拥塞窗口会收敛于稳定值。</p>
<blockquote>
<h3 id="（1）慢开始与拥塞避免"><a href="#（1）慢开始与拥塞避免" class="headerlink" title="（1）慢开始与拥塞避免"></a>（1）慢开始与拥塞避免</h3><p>　　发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>　　注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢启动阈值 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>　　如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。</p>
<h3 id="（2）快重传与快恢复"><a href="#（2）快重传与快恢复" class="headerlink" title="（2）快重传与快恢复"></a>（2）快重传与快恢复</h3><p>　　在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>　　在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>　　在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何区分流量控制和拥塞控制？</p>
<ul>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li>
<li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li>
</ul>
</li>
<li><p>TCP如何提供可靠数据传输的？</p>
<ul>
<li>建立连接（标志位）：通信前确认通信实体存在。</li>
<li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li>
<li>数据校验（校验和）：CRC校验全部数据。</li>
<li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li>
<li>窗口机制（窗口）：提供流量控制，避免过量发送。</li>
<li>拥塞控制：同上。</li>
</ul>
</li>
<li><p>TCP soctet交互流程？</p>
<ul>
<li><p>服务器：</p>
<ul>
<li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p>
<ul>
<li>domain：协议域，决定了socket的地址类型，IPv4为AF_INET。</li>
<li>type：指定socket类型，SOCK_STREAM为TCP连接。</li>
<li>protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。</li>
</ul>
</li>
<li><p>绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<ul>
<li>sockfd：socket返回的套接字描述符，类似于文件描述符fd。</li>
<li>addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IPv4的sockaddr地址结构</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family;    // 协议类型，AF_INET</span><br><span class="line">    in_port_t sin_port;    // 端口号</span><br><span class="line">    struct in_addr sin_addr;    // IP地址</span><br><span class="line">&#125;;</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>addrlen：地址长度。</li>
</ul>
</li>
<li><p>监听端口号 -&gt; int listen(int sockfd, int backlog);</p>
<ul>
<li>sockfd：要监听的sock描述字。</li>
<li>backlog：socket可以排队的最大连接数。</li>
</ul>
</li>
<li><p>接收用户请求 -&gt; int accept(int sockfd, struct sockaddr <em>addr, socklen_t </em>addrlen);</p>
<ul>
<li>sockfd：服务器socket描述字。</li>
<li>addr：指向地址结构指针。</li>
<li>addrlen：协议地址长度。</li>
<li>注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。</li>
</ul>
</li>
<li><p>从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);</p>
<ul>
<li>fd：连接描述字。</li>
<li>buf：缓冲区buf。</li>
<li>count：缓冲区长度。</li>
<li>注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。</li>
</ul>
</li>
<li><p>关闭socket -&gt; int close(int fd);</p>
<ul>
<li>fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。</li>
<li>注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>客户机：</p>
<ul>
<li>创建socket -&gt; int socket(int domain, int type, int protocol);</li>
<li>连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);<ul>
<li>sockfd客户端的sock描述字。</li>
<li>addr：服务器的地址。</li>
<li>addrlen：socket地址长度。</li>
</ul>
</li>
<li>向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);<ul>
<li>fd、buf、count：同read中意义。</li>
<li>大于0表示写了部分或全部数据，小于0表示出错。</li>
</ul>
</li>
<li>关闭oscket -&gt; int close(int fd);<ul>
<li>fd：同服务器端fd。 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>问题</strong><br>我面试时经常会问的一个问题是当TCP两端A、B建立了连接后，如果一端拔掉网线或者拔掉电源，那么另一端能够收到通知吗？<br>答案是不会，但是只有少数人能够正确的回答这个问题。</p>
<p><strong>原因</strong><br>TCP是一种有连接的协议，但是这个连接并不是指有一条实际的电路，而是一种虚拟的电路。TCP的建立连接和断开连接都是通过发送数据实现的，也就是我们常说的三次握手、四次挥手。TCP两端保存了一种数据的状态，就代表这种连接，TCP两端之间的路由设备只是将数据转发到目的地，并不知道这些数据实际代表了什么含义，也并没有在其中保存任何的状态信息，也就是说中间的路由设备没有什么连接的概念，只是将数据转发到目的地，只有数据的发送者和接受者两端真正的知道传输的数据代表着一条连接。</p>
<p>但是这就说明了一点，如果不发送数据那么是无法断开连接的。正常情况下当TCP的一端A调用了SOCKET的close或者进程结束，操作系统就会按照TCP协议发送FIN数据报文。B端收到后就会断开连接。但是当出现了上文所说的异常情况时：被拔掉网线或者断掉电源，总结起来就是没有机会发出断开的FIN数据报文。那么和A直连的路由设备虽然知道A设备已经断开了，但是路由设备并没有保存连接的状态信息，所以路由设备也就不可能去通知B端A端的断开。而B端没有收到断开的数据报文就会依然保持连接。所以A端拔掉网线或者断掉电源后B端是没办法收到断开连接的通知的。 </p>
<p>解决方案：心跳包</p>
</blockquote>
<h1 id="应用层-HTTP"><a href="#应用层-HTTP" class="headerlink" title="应用层(HTTP)"></a>应用层(HTTP)</h1><p>HTTP协议工作在应用层，端口号是80。HTTP协议被用于网络中两台计算机间的通信，相比于TCP/IP这些底层协议，HTTP协议更像是高层标记型语言，浏览器根据从服务器得到的HTTP响应体中分别得到报文头，响应头和信息体（HTML正文等），之后将HTML文件解析并呈现在浏览器上。同样，我们在浏览器地址栏输入网址之后，浏览器相当于用户代理帮助我们组织好报文头，请求头和信息体（可选），之后通过网络发送到服务器，，服务器根据请求的内容准备数据。所以如果想要完全弄明白HTTP协议，你需要写一个浏览器 + 一个Web服务器，一侧来生成请求信息，一侧生成响应信息。</p>
<p>从网络分层模型来看，HTTP工作在应用层，其在传输层由TCP协议为其提供服务。所以可以猜到，HTTP请求前，客户机和服务器之间一定已经通过三次握手建立起连接，其中套接字中服务器一侧的端口号为HTTP周知端口80。在请求和传输数据时也是有讲究的，通常一个页面上不只有文本数据，有时会内嵌很多图片，这时候有两种选择可以考虑。一种是对每一个文件都建立一个TCP连接，传送完数据后立马断开，通过多次这样的操作获取引用的所有数据，但是这样一个页面的打开需要建立多次连接，效率会低很多。另一种是对于有多个资源的页面，传送完一个数据后不立即断开连接，在同一次连接下多次传输数据直至传完，但这种情况有可能会长时间占用服务器资源，降低吞吐率。上述两种模式分别是HTTP 1.0和HTTP 1.1版本的默认方式，具体是什么含义会在后面详细解释。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 </span><br><span class="line">&gt; </span><br><span class="line">&gt; 缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>HTTP工作流程</strong></p>
<p>一次完整的HTTP请求事务包含以下四个环节：</p>
<ul>
<li>建立起客户机和服务器连接。</li>
<li>建立连接后，客户机发送一个请求给服务器。</li>
<li>服务器收到请求给予响应信息。</li>
<li>客户端浏览器将返回的内容解析并呈现，断开连接。</li>
</ul>
<p><strong>HTTP协议结构</strong></p>
<p>请求报文</p>
<p>对于HTTP请求报文我们可以通过以下两种方式比较直观的看到：一是在浏览器调试模式下（F12）看请求响应信息，二是通过wireshark或者tcpdump抓包实现。通过前者看到的数据更加清晰直观，通过后者抓到的数据更真实。但无论是用哪种方式查看，得到的请求报文主题体信息都是相同的，对于请求报文，主要包含以下四个部分，每一行数据必须通过”\r\n”分割，这里可以理解为行末标识符。</p>
<ul>
<li><p>报文头（只有一行）</p>
<p>结构：method uri version</p>
<ul>
<li><p>method</p>
<p>HTTP的请求方法，一共有9中，但GET和POST占了99%以上的使用频次。GET表示向特定资源发起请求，当然也能提交部分数据，不过提交的数据以明文方式出现在URL中。POST通常用于向指定资源提交数据进行处理，提交的数据被包含在请求体中，相对而言比较安全些。</p>
</li>
<li><p>uri</p>
<p>用来指代请求的文件，≠URL。</p>
</li>
<li><p>version</p>
<p>HTTP协议的版本，该字段有HTTP/1.0和HTTP/1.1两种。</p>
</li>
</ul>
</li>
<li><p>请求头（多行）</p>
<p>在HTTP/1.1中，请求头除了Host都是可选的。包含的头五花八门，这里只介绍部分。</p>
<ul>
<li>Host：指定请求资源的主机和端口号。端口号默认80。</li>
<li>Connection：值为keep-alive和close。keep-alive使客户端到服务器的连接持续有效，不需要每次重连，此功能为HTTP/1.1预设功能。</li>
<li>Accept：浏览器可接收的MIME类型。假设为text/html表示接收服务器回发的数据类型为text/html，如果服务器无法返回这种类型，返回406错误。</li>
<li>Cache-control：缓存控制，Public内容可以被任何缓存所缓存，Private内容只能被缓存到私有缓存，non-cache指所有内容都不会被缓存。</li>
<li>Cookie：将存储在本地的Cookie值发送给服务器，实现无状态的HTTP协议的会话跟踪。</li>
<li>Content-Length：请求消息正文长度。</li>
</ul>
<p>另有User-Agent、Accept-Encoding、Accept-Language、Accept-Charset、Content-Type等请求头这里不一一罗列。由此可见，请求报文是告知服务器请求的内容，而请求头是为了提供服务器一些关于客户机浏览器的基本信息，包括编码、是否缓存等。</p>
</li>
<li><p>空行（一行）</p>
</li>
<li><p>可选消息体（多行）</p>
</li>
</ul>
<p>响应报文</p>
<p>响应报文是服务器对请求资源的响应，通过上面提到的方式同样可以看到，同样地，数据也是以”\r\n”来分割。</p>
<ul>
<li><p>报文头（一行）</p>
<p>结构：version status_code status_message</p>
<ul>
<li><p>version</p>
<p>描述所遵循的HTTP版本。</p>
</li>
<li><p>status_code</p>
<p>状态码，指明对请求处理的状态，常见的如下。</p>
<ul>
<li>200：成功。</li>
<li>301：内容已经移动。</li>
<li>400：请求不能被服务器理解。</li>
<li>403：无权访问该文件。</li>
<li>404：不能找到请求文件。</li>
<li>500：服务器内部错误。</li>
<li>501：服务器不支持请求的方法。</li>
<li>505：服务器不支持请求的版本。</li>
</ul>
</li>
<li><p>status_message</p>
<p>显示和状态码等价英文描述。</p>
</li>
</ul>
</li>
<li><p>响应头（多行）</p>
<p>这里只罗列部分。</p>
<ul>
<li>Date：表示信息发送的时间。</li>
<li>Server：Web服务器用来处理请求的软件信息。</li>
<li>Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。</li>
<li>Content-Length：服务器告知浏览器自己响应的对象长度。</li>
<li>Content-Type：告知浏览器响应对象类型。</li>
</ul>
</li>
<li><p>空行（一行）</p>
</li>
<li><p>信息体（多行）</p>
<p>实际有效数据，通常是HTML格式的文件，该文件被浏览器获取到之后解析呈现在浏览器中。</p>
</li>
</ul>
<p><strong>CGI与环境变量</strong></p>
<ul>
<li><p>CGI程序</p>
<p>服务器为客户端提供动态服务首先需要解决的是得到用户提供的参数再根据参数信息返回。为了和客户端进行交互，服务器需要先创建子进程，之后子进程执行相应的程序去为客户服务。CGI正是帮助我们解决参数获取、输出结果的。</p>
<p>动态内容获取其实请求报文的头部和请求静态数据时完全相同，但请求的资源从静态的HTML文件变成了后台程序。服务器收到请求后fork()一个子进程，子进程执行请求的程序，这样的程序称为CGI程序（Python、Perl、C++等均可）。通常在服务器中我们会预留一个单独的目录（cgi-bin）用来存放所有的CGI程序，请求报文头部中请求资源的前缀都是/cgi-bin，之后加上所请求调用的CGI程序即可。</p>
<p>所以上述流程就是：客户端请求程序 -&gt; 服务器fork()子进程 -&gt; 执行被请求程序。接下来需要解决的问题就是如何获取客户端发送过来的参数和输出信息怎么传递回客户端。</p>
</li>
<li><p>环境变量</p>
<p>对CGI程序来说，CGI环境变量在创建时被初始化，结束时被销毁。当CGI程序被HTTP服务器调用时，因为是被服务器fork()出来的子进程，所以其继承了其父进程的环境变量，这些环境变量包含了很多基本信息，请求头中和响应头中列出的内容（比如用户Cookie、客户机主机名、客户机IP地址、浏览器信息等），CGI程序所需要的参数也在其中。</p>
<ul>
<li><p>GET方法下参数获取</p>
<p>服务器把接收到的参数数据编码到环境变量QUERY_STRING中，在请求时只需要直接把参数写到URL最后即可，比如”http:127.0.0.1:80/cgi-bin/test?a=1&amp;b=2&amp;c=3”，表示请求cgi-bin目录下test程序，’?’之后部分为参数，多个参数用’&amp;’分割开。服务器接收到请求后环境变量QUERY_STRING的值即为a=1&amp;b=2&amp;c=3。</p>
<p>在CGI程序中获取环境变量值的方法是：getenv()，比如我们需要得到上述QUERY_STRING的值，只需要下面这行语句就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *value = getenv(&quot;QUERY_STRING&quot;);</span><br></pre></td></tr></table></figure>
<p>之后对获得的字符串处理一下提取出每个参数信息即可。</p>
</li>
<li><p>POST方法下参数获取</p>
<p>POST方法下，CGI可以直接从服务器标准输入获取数据，不过要先从CONTENT_LENGTH这个环境变量中得到POST参数长度，再获取对应长度内容。</p>
</li>
</ul>
</li>
</ul>
<p><strong>会话机制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</span><br><span class="line"></span><br><span class="line">- Cookie</span><br><span class="line"></span><br><span class="line">    Cookie是客户端保持状态的方法。</span><br><span class="line"></span><br><span class="line">    Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</span><br><span class="line"></span><br><span class="line">    除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</span><br><span class="line"></span><br><span class="line">- Session</span><br><span class="line"></span><br><span class="line">    Session是服务器保持状态的方法。</span><br><span class="line"></span><br><span class="line">    首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</span><br><span class="line"></span><br><span class="line">当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>HTTP**</strong>协议概念：**超文本传输协议，一种详细规定浏览器和万维网服务器之间通信规则，通过因特网传送万维网文档的数据传送协议。</p>
<p><strong>HTTP**</strong>协议执行过程：**浏览器要访问万维网服务器时，首先完成对WWW服务器的域名解析，一旦获得服务器IP地址，浏览器通过TCP向服务器发送连接建立请求。</p>
<p>(1)       浏览器打开一个TCP连接；</p>
<p>(2)       浏览器发送HTTP请求到服务器；</p>
<p>(3)       服务器发送HTTP回应信息到服务器；</p>
<p>(4)       TCP连接关闭；</p>
<p><strong>HTTPS**</strong>（<strong><strong>Hypertext Transfer Protocol over Secure Socket Layer</strong></strong>）概念：**以安全为目标的HTTP通道即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密需要SSL。</p>
<p><strong>作用（两个）：</strong>（1）建立一个信息安全通道，来保证数据传输的安全；（2）确认网站的真实性。</p>
<p><strong>HTTPs SSL**</strong>执行过程：**</p>
<p>(1)       验证服务器端；</p>
<p>(2)       允许客户端和服务器端选择加密算法和密码，确保双方都支持；</p>
<p>(3)       验证客户端；</p>
<p>(4)       使用公钥加密技术来生成共享加密数据；</p>
<p>(5)       创建一个加密的SSL连接；</p>
<p>(6)       基于该SSL连接传递HTTP请求；</p>
<h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><p>l   HTTP是超文本传输协议，信息是明文传输，HTTPs则是具有安全性的ssl加密传输协议，要到ca申请证书。</p>
<p>l   HTTP和HTTPs使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>l   HTTP连接简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p>
<p>l   在OSI模型中，HTTP工作于应用层，而HTTPS工作于传输层；</p>
</blockquote>
<h2 id="从输入网址到获得页面的网络请求过程"><a href="#从输入网址到获得页面的网络请求过程" class="headerlink" title="从输入网址到获得页面的网络请求过程"></a>从输入网址到获得页面的网络请求过程</h2><ul>
<li><p>查询 DNS</p>
<ul>
<li>浏览器搜索自身的DNS缓存</li>
<li>搜索操作系统的DNS缓存，本地host文件查询</li>
<li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li>
<li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li>
</ul>
</li>
<li><p>浏览器获得域名对应的IP地址后，发起HTTP三次握手</p>
</li>
<li><p>TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求了</p>
</li>
<li><p>TLS 握手</p>
<ul>
<li>客户端发送一个 <code>ClientHello</code> 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</li>
<li>服务器端向客户端返回一个 <code>ServerHello</code> 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li>
<li>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li>
<li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li>
<li>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li>
<li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</li>
<li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li>
</ul>
</li>
<li><p>HTTP 服务器请求处理</p>
<p>HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>
<ul>
<li><p>HTTPD 接收请求</p>
</li>
<li><ul>
<li><p>服务器把请求拆分为以下几个参数：</p>
<p>HTTP 请求方法(<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, 或者 <code>TRACE</code>)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法域名：google.com请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)</p>
</li>
</ul>
</li>
<li><p>服务器验证其上已经配置了 google.com 的虚拟主机</p>
</li>
<li><p>服务器验证 google.com 接受 GET 方法</p>
</li>
<li><p>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</p>
</li>
<li><p>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</p>
</li>
<li><p>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</p>
</li>
<li><p>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</p>
</li>
</ul>
</li>
<li><p>服务器接受到这个请求，根据路径参数，经过后端的一些处理生成HTML页面代码返回给浏览器</p>
</li>
<li><p>浏览器拿到完整的HTML页面代码开始解析和渲染，如果遇到引用的外部<a href="http://lib.csdn.net/base/javascript" target="_blank" rel="noopener">js</a>，CSS,图片等静态资源，它们同样也是一个个的HTTP请求，都需要经过上面的步骤</p>
</li>
<li><p>浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给用户</p>
</li>
</ul>
<h2 id="HTTPs安全性"><a href="#HTTPs安全性" class="headerlink" title="HTTPs安全性"></a>HTTPs安全性</h2><p><strong>HTTP 有以下安全性问题：</strong></p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPs（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</p>
<p>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<h3 id="（1）对称密钥加密"><a href="#（1）对称密钥加密" class="headerlink" title="（1）对称密钥加密"></a>（1）对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<h3 id="（2）非对称密钥加密"><a href="#（2）非对称密钥加密" class="headerlink" title="（2）非对称密钥加密"></a>（2）非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢</li>
</ul>
<h2 id="SSL-TLS协议的握手过程"><a href="#SSL-TLS协议的握手过程" class="headerlink" title="SSL/TLS协议的握手过程"></a>SSL/TLS协议的握手过程</h2><p>我们知道，HTTP 协议都是明文传输内容，在早期只展示静态内容时没有问题。伴随着互联网的快速发展，人们对于网络传输安全性的要求也越来越高，HTTPS 协议因此出现。如上图所示，在 HTTPS 加密中真正起作用的其实是 SSL/TLS 协议。SSL/TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送接收数据流程不变，这就很好地兼容了老的 HTTP 协议，这也是软件开发中分层实现的体现。</p>
<h3 id="SSL-Secure-Socket-Layer，安全套接字层"><a href="#SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="SSL (Secure Socket Layer，安全套接字层)"></a>SSL (Secure Socket Layer，安全套接字层)</h3><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<h3 id="TLS-Transport-Layer-Security，传输层安全协议"><a href="#TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="TLS (Transport Layer Security，传输层安全协议)"></a>TLS (Transport Layer Security，传输层安全协议)</h3><p>用于两个应用程序之间提供保密性和数据完整性。 TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
<p>SSL/TLS 握手是为了<strong>安全</strong>地协商出一份<strong>对称加密</strong>的秘钥，这个过程很有意思，下面我们一起来了解一下。</p>
<p><img src="E:\PersonalBlog\source\_posts\计算机网络\https_com.png" alt="https_com"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">（1）client hello</span><br><span class="line">握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。</span><br><span class="line"></span><br><span class="line">（2）server hello</span><br><span class="line">第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。</span><br><span class="line"></span><br><span class="line">（3）server certificate</span><br><span class="line">这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</span><br><span class="line"></span><br><span class="line">（4）Server Hello Done</span><br><span class="line">Server Hello Done 通知客户端 Server Hello 过程结束。</span><br><span class="line"></span><br><span class="line">（5）Client Key Exchange</span><br><span class="line">上面客户端根据服务器传来的公钥生成了 PreMaster Key，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。</span><br><span class="line"></span><br><span class="line">为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。</span><br><span class="line"></span><br><span class="line">（6）Change Cipher Spec(Client)</span><br><span class="line">这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。</span><br><span class="line"></span><br><span class="line">（7）Finished(Client)</span><br><span class="line">客户端发送Finished报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准。</span><br><span class="line"></span><br><span class="line">（8）Change Cipher Spec(Server)</span><br><span class="line">服务器同样发送Change Cipher Spec报文给客户端</span><br><span class="line"></span><br><span class="line">（9）Finished(Server)</span><br><span class="line">服务器同样发送Finished报文给客户端</span><br><span class="line"></span><br><span class="line">（10-11）Application Data</span><br><span class="line">到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。</span><br><span class="line"></span><br><span class="line">（12）Alert：warning, close notify</span><br><span class="line">最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。</span><br><span class="line"></span><br><span class="line">（*）demand client certificate</span><br><span class="line">Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。</span><br><span class="line"></span><br><span class="line">（*）check server certificate</span><br><span class="line">客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3 生成 PreMaster Key。</span><br></pre></td></tr></table></figure>
<h1 id="常见问题集锦"><a href="#常见问题集锦" class="headerlink" title="常见问题集锦"></a>常见问题集锦</h1><h2 id="网络负载均衡"><a href="#网络负载均衡" class="headerlink" title="网络负载均衡"></a><strong>网络负载均衡</strong></h2><p><img src="/2019/08/31/计算机网络/fuzai.png" alt="fuzai"></p>
<p>介绍<br>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>对于大量的用户请求，可通过负载均衡器分发到服务器集群中的各个服务器中，服务器集群是可弹性伸缩的，如对于某些特定的活动节日，用户的请求量比平时更多，所以对于原有的服务器集群可能根本负载不起用户的请求量，一方面通过引入弹性伸缩来增加服务的硬件措施，另一方面通过某些负载均衡算法使得服务器集群内部每一台服务器的负载量是合理的。</p>
<p>负载均衡方案<br>1、DNS方案    -    地域上的流量均衡</p>
<p>2、硬件方案    -    大型服务器集群负载均衡</p>
<p>3、软件方案    -    机器层面的流量负载均衡</p>
<p>DNS方案<br>让DNS服务器根据不同的地理位置的用户返回不同的服务器IP，如广州的用户可以返回广州机房中服务器的IP，北京的用户可以返回北京机房中服务器的IP。<br>然而，DNS查找服务器IP的方式有两种，一种是递归查询，一种是迭代查询。由于DNS的几级缓存可能导致配置修改生效不及时，从而影响负载均衡的效果。 </p>
<blockquote>
<p>软件方案<br>软件方案大多都是使用一些列的负载均衡算法，如轮训算法，负载度策略算法、响应策略、哈希策略。<br>常用的由LVS和Nginx，<br>LVS是基于4层网络协议（TCP）<br>Nginx是基于5层网络协议(应用层，传输层)<br>LVS由于是基于底层的网络协议，主要是TCP协议，由IP来转发，处理量在几十万/秒。<br>Nginx是基于7层网络协议，如Http、SMTP协议，处理量在几万/秒。</p>
<p>常用的负载均衡算法<br>1、轮询策略，在DNS方案负载均衡方案中较为常见，根据域的权重比来分配流量。<br>2、负载度策略，负载均衡器向后端服务器中采集参数，如每台服务器的CPU负载指标，连接请求等参数来动态分配流量到不同的服务器。<br>3、响应策略，这种做法更注重用户的体验，由负载均衡器不断向后（如每隔1分钟采集一次）端采集每一台后端服务器的响应速度来将数据流量转发到当前处理速度最快的服务器。<br>4、哈希策略，率先给后端服务器的主机进行编号，通过哈希算法将请求转发到对应哈希运算结果对应的服务器中。如，采用取模的哈希算法，将数据包对后端机器数量进行取模后得到一个值Q，最终将数据包转发到编号为Q的服务器。 </p>
</blockquote>
<h2 id="http连接池的作用，有哪些优化？"><a href="#http连接池的作用，有哪些优化？" class="headerlink" title="http连接池的作用，有哪些优化？"></a><strong>http</strong>连接池的作用，有哪些优化？</h2><p>HTTP是建立在TCP上面的，一次HTTP请求要经历TCP三次握手阶段，然后发送请求，得到相应，最后TCP断开连接。如果我们要发出多个HTTP请求，每次都这么搞，那每次要握手、请求、断开，就太浪费了，如果是HTTPS请求，就更加浪费了，每次HTTPS请求之前的连接多好几个包（不包括ACK的话会多4个）。所以如果我们在TCP或HTTP连接建立之后，可以传输、传输、传输，就能省很多资源。于是就有了“HTTP（S）连接池”的概念。和线程池非常像是不是。本文介绍连接池，连接池管理器，主要基于Python和 requests, urllib3 两个库。主要讲HTTP连接池，HTTPS连接池原理一样，只不过不光缓存TCP连接，还有发起请求之前对证书认证等过程。</p>
<blockquote>
<p>http连接池是什么？http连接池就是一个池子，里面装满了连接，哈哈哈。连接就是一条通路，例如打电话，通了之后，就是一个连接。把这些连接放在一起就是连接池啦。<br>以通电话为例子，例如有下面几通接通的电话：<br>1.跟主席连通的电话<br>2.跟总理连通的电话<br>3.跟总司令连接的电话<br>4.跟指导员连接的电话<br>这一堆连通的电话机放在的一个神秘的小黑屋，这个小黑屋就是连接池啦</p>
<p>而每个进小黑屋跟大领导通电话的人可以认为就是httpclient，而大领导就是各个服务器啦。大领导可忙了，如果每个进小黑屋的人跟大领导通完电话就挂断的话，那得多浪费大领导的时间，所以小黑屋里面的电话不能随便挂断，要过一段时间一直没有人跟大领导通话了才能挂断。这个就是连接池（小黑屋）的原理。<br>所以有一下两个特征：<br>1.连接池里面保存着可以马上通信的连接，免除了重新建立连接的麻烦<br>2.连接如果长期不用，就会挂断。</p>
</blockquote>
<p>大概就是三个步骤：<br>1.查看有没有过期的连接，有则干掉他<br>2.查看没事干的空闲的连接是不是过多了，按时间顺序干掉一部分。先把老的干掉<br>3.如果没有东西要清理，清理线程则休息一下。当有连接进入的时候，就起来继续干活，哈哈哈。</p>
<blockquote>
<p>1.为什么要用Http连接池</p>
<p>1、降低延迟：如果不采用连接池，每次连接发起Http请求的时候都会重新建立TCP连接(经历3次握手)，用完就会关闭连接(4次挥手)，如果采用连接池则减少了这部分时间损耗，别小看这几次握手，本人经过测试发现，基本上3倍的时间延迟</p>
<p>2、支持更大的并发：如果不采用连接池，每次连接都会打开一个端口，在大并发的情况下系统的端口资源很快就会被用完，导致无法建立新的连接</p>
<p>2.简单连接管理器</p>
<p>是个简单的连接管理器，它一次只能管理一个连接。尽管这个类是线程安全的，它在同一时间也只能被一个线程使用。会尽量重用旧的连接来发送后续的请求，并且使用相同的路由。如果后续请求的路由和旧连接中的路由不匹配，就会关闭当前连接，使用请求中的路由重新建立连接。如果当前的连接正在被占用，会抛出异常。</p>
<p>3.连接池管理器</p>
<p>相对来说，是个更复杂的类，它管理着连接池，可以同时为很多线程提供http连接请求。Connections are pooled on a per route basis.当请求一个新的连接时，如果连接池有有可用的持久连接，连接管理器就会使用其中的一个，而不是再创建一个新的连接。</p>
<p>维护的连接数在每个路由基础和总数上都有限制。默认，每个路由基础上的连接不超过2个，总连接数不能超过20。在实际应用中，这个限制可能会太小了，尤其是当服务器也使用Http协议时。</p>
<p>下面的例子演示了如果调整连接池的参数：</p>
<p>4.关闭连接管理器</p>
<p>当一个HttpClient的实例不在使用，或者已经脱离它的作用范围，我们需要关掉它的连接管理器，来关闭掉所有的连接，释放掉这些连接占用的系统资源。</p>
<p>\5. 连接回收策略</p>
<p>经典阻塞I/O模型的一个主要缺点就是只有当组侧I/O时，socket才能对I/O事件做出反应。当连接被管理器收回后，这个连接仍然存活，但是却无法监控socket的状态，也无法对I/O事件做出反馈。如果连接被服务器端关闭了，客户端监测不到连接的状态变化（也就无法根据连接状态的变化，关闭本地的socket）。</p>
<p>HttpClient为了缓解这一问题造成的影响，会在使用某个连接前，监测这个连接是否已经过时，如果服务器端关闭了连接，那么连接就会失效。这种过时检查并不是100%有效，并且会给每个请求增加10到30毫秒额外开销。唯一一个可行的，且does not involve a one thread per socket model for idle connections的解决办法，是建立一个监控线程，来专门回收由于长时间不活动而被判定为失效的连接。这个监控线程可以周期性的调用类的方法来关闭过期的连接，回收连接池中被关闭的连接。它也可以选择性的调用类的方法来关闭一段时间内不活动的连接。</p>
<p>\6. 连接存活策略</p>
<p>Http规范没有规定一个持久连接应该保持存活多久。有些Http服务器使用非标准的头消息和客户端进行交互，服务器端会保持数秒时间内保持连接。HttpClient也会利用这个头消息。如果服务器返回的响应中没有包含头消息，HttpClient会认为这个连接可以永远保持。然而，很多服务器都会在不通知客户端的情况下，关闭一定时间内不活动的连接，来节省服务器资源。在某些情况下默认的策略显得太乐观，我们可能需要自定义连接存活策略。</p>
<p><strong>7.原理及注意事项</strong></p>
<p>连接池中连接都是在发起请求的时候建立，并且都是长连接</p>
<p><strong>in.close();作用就是将用完的连接释放，下次请求可以复用，这里特别注意的是，如果不使用in.close();而仅仅使用response.close();结果就是连接会被关闭，并且不能被复用，这样就失去了采用连接池的意义。</strong></p>
<p>连接池释放连接的时候，并不会直接对TCP连接的状态有任何改变，只是维护了两个Set，leased和avaliabled，leased代表被占用的连接集合，avaliabled代表可用的连接的集合，释放连接的时候仅仅是将连接从leased中remove掉了，并把连接放到avaliabled集合中</p>
</blockquote>
<h3 id="DNS是干什么的？"><a href="#DNS是干什么的？" class="headerlink" title="DNS是干什么的？"></a>DNS是干什么的？</h3><p><strong>DNS**</strong>协议：**运行在UDP协议之上，服务器监听端口号为53：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询。</p>
<p>（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，依次类推）</p>
<p><strong>主机解析域名的顺序：</strong>找缓存、找本机的hosts文件、找DNS服务器</p>
<p><img src="/2019/08/31/计算机网络/c44d92b9c250a5365fc228d71d714e9.png" alt="c44d92b9c250a5365fc228d71d714e9"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解析过程：10步</span><br><span class="line">	浏览器先检查自身缓存中有没有被解析过这个域名对应的ip地址；</span><br><span class="line">	如果浏览器缓存没有命中，浏览器会检查操作系统缓存中有没有对应的已解析过的结果。在windows中可通过c盘里hosts文件来设置；</span><br><span class="line">	还没命中，请求本地域名服务器来解析这个域名，一般都会在本地域名服务器找到；</span><br><span class="line">	本地域名服务器没有命中，则去根域名服务器请求解析；</span><br><span class="line">	根域名服务器返回给本地域名服务器一个所查询域的主域名服务器；</span><br><span class="line">	本地域名服务器向主域名服务器发送请求；</span><br><span class="line">	接受请求的主域名服务器查找并返回这个域名对应的域名服务器的地址；</span><br><span class="line">	域名服务器根据映射关系找到ip地址，返回给本地域名服务器；</span><br><span class="line">	本地域名服务器缓存这个结果；</span><br><span class="line">	本地域名服务器将该结果返回给用户；</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Tipping via QR code</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.jpg" alt="muxin 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/zhifu.jpg" alt="muxin 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/31/网络编程/" rel="next" title="网络编程">
                <i class="fa fa-chevron-left"></i> 网络编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/31/Linux相关操作/" rel="prev" title="Linux相关操作">
                Linux相关操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</script>

      
    </div>
  </div>


          </div>
          


          


  

    
      <script id="dsq-count-scr" src="https://xzx.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/08/31/计算机网络/';
          this.page.identifier = '2019/08/31/计算机网络/';
          this.page.title = '计算机网络';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://xzx.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




    

   
        <!-- UY BEGIN -->
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2159828"></script>
        <!-- UY END -->
    
  
 


	





    

   
        <!-- UY BEGIN -->
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2159828"></script>
        <!-- UY END -->
    
  
 


 



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/photo.JPG"
                alt="muxin" />
            
              <p class="site-author-name" itemprop="name">muxin</p>
              <p class="site-description motion-element" itemprop="description">Fear not that the life shall come to an end, but rather fear that it shall never have a beginning.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#网络层-IP"><span class="nav-number">1.</span> <span class="nav-text">网络层(IP)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-mac和ip怎么转换"><span class="nav-number">1.1.</span> <span class="nav-text">1. mac和ip怎么转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址解析协议ARP"><span class="nav-number">1.2.</span> <span class="nav-text">地址解析协议ARP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交换机和路由器的区别"><span class="nav-number">1.3.</span> <span class="nav-text">交换机和路由器的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子网掩码的作用"><span class="nav-number">1.4.</span> <span class="nav-text">子网掩码的作用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#传输层-TCP-UDP"><span class="nav-number">2.</span> <span class="nav-text">传输层(TCP/UDP)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）五层协议"><span class="nav-number">2.0.1.</span> <span class="nav-text">（1）五层协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据在各层之间的传递过程"><span class="nav-number">2.0.2.</span> <span class="nav-text">数据在各层之间的传递过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（4）TCP-IP四层模型"><span class="nav-number">2.0.3.</span> <span class="nav-text">（4）TCP/IP四层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP和UDP的区别？应用场景都有哪些？"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">TCP和UDP的区别？应用场景都有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么UDP有时比TCP更有优势"><span class="nav-number">2.0.3.2.</span> <span class="nav-text">为什么UDP有时比TCP更有优势?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP中一个包的大小最大多少？"><span class="nav-number">2.0.3.3.</span> <span class="nav-text">UDP中一个包的大小最大多少？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）慢开始与拥塞避免"><span class="nav-number">2.0.4.</span> <span class="nav-text">（1）慢开始与拥塞避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）快重传与快恢复"><span class="nav-number">2.0.5.</span> <span class="nav-text">（2）快重传与快恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用层-HTTP"><span class="nav-number">3.</span> <span class="nav-text">应用层(HTTP)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP和HTTPS的区别"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">HTTP和HTTPS的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从输入网址到获得页面的网络请求过程"><span class="nav-number">3.1.</span> <span class="nav-text">从输入网址到获得页面的网络请求过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPs安全性"><span class="nav-number">3.2.</span> <span class="nav-text">HTTPs安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）对称密钥加密"><span class="nav-number">3.2.1.</span> <span class="nav-text">（1）对称密钥加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）非对称密钥加密"><span class="nav-number">3.2.2.</span> <span class="nav-text">（2）非对称密钥加密</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSL-TLS协议的握手过程"><span class="nav-number">3.3.</span> <span class="nav-text">SSL/TLS协议的握手过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL-Secure-Socket-Layer，安全套接字层"><span class="nav-number">3.3.1.</span> <span class="nav-text">SSL (Secure Socket Layer，安全套接字层)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-Transport-Layer-Security，传输层安全协议"><span class="nav-number">3.3.2.</span> <span class="nav-text">TLS (Transport Layer Security，传输层安全协议)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见问题集锦"><span class="nav-number">4.</span> <span class="nav-text">常见问题集锦</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络负载均衡"><span class="nav-number">4.1.</span> <span class="nav-text">网络负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http连接池的作用，有哪些优化？"><span class="nav-number">4.2.</span> <span class="nav-text">http连接池的作用，有哪些优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS是干什么的？"><span class="nav-number">4.2.1.</span> <span class="nav-text">DNS是干什么的？</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
	<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=86381&auto=1&height=66"></iframe>
</div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">muxin</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i>
 
        <!-- 不蒜子统计 -->
        <span id="busuanzi_container_site_pv">
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
        </span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv" style='display:none'>
                本站访客数<span id="busuanzi_value_site_uv"></span>人
        </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 
</div>

<div>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
        var now = new Date(); 
        function createtime() { 
            var grt= new Date("07/08/2018 12:00:00");//此处修改你的建站时间或者网站上线时间 
            now.setTime(now.getTime()+250); 
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
            document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
        } 
    setInterval("createtime()",250);
    </script> 
	
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 | Search by algolia</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2cb6ba3a1c27ee1fc0a8e6d0dcb28522";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  

  
  
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
