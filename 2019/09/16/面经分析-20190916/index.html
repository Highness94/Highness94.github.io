<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/> 
<script src="/live2d/autoload.js"></script>

  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon (1).ico?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="muxin's Blog" type="application/atom+xml" />






<meta name="description" content="网易互娱原帖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859一面 共计时长1h+牛客视频面试，两位面试官一起面，面试官们态度都特别好，面试体验极佳1.自我介绍介绍了学校，项目（这一部分重点介绍），常用的编程语言，以及喜欢的游戏（">
<meta property="og:type" content="article">
<meta property="og:title" content="面经分析-20190916">
<meta property="og:url" content="http://yoursite.com/2019/09/16/面经分析-20190916/index.html">
<meta property="og:site_name" content="muxin&#39;s Blog">
<meta property="og:description" content="网易互娱原帖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859一面 共计时长1h+牛客视频面试，两位面试官一起面，面试官们态度都特别好，面试体验极佳1.自我介绍介绍了学校，项目（这一部分重点介绍），常用的编程语言，以及喜欢的游戏（">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="http://yoursite.com/2019/09/16/面经分析-20190916/064bb159a5a563699dbabaf8bb737e1.png">
<meta property="og:image" content="http://yoursite.com/2019/09/16/面经分析-20190916/5e197d1be3fbf69d630ba615426d137.png">
<meta property="og:image" content="http://yoursite.com/2019/09/16/面经分析-20190916/1dbbc48c03e86aceb701e8bbe8185cc.png">
<meta property="og:image" content="http://yoursite.com/2019/09/16/面经分析-20190916/E:/PersonalBlog/source/_posts/面经分析-20190916/a4e1812cccfc18f484cc5b34fc1f853.png">
<meta property="og:updated_time" content="2019-09-17T09:19:44.601Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面经分析-20190916">
<meta name="twitter:description" content="网易互娱原帖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859一面 共计时长1h+牛客视频面试，两位面试官一起面，面试官们态度都特别好，面试体验极佳1.自我介绍介绍了学校，项目（这一部分重点介绍），常用的编程语言，以及喜欢的游戏（">
<meta name="twitter:image" content="https://common.cnblogs.com/images/copycode.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '9A6H83NNE8',
      apiKey: '88b14b97a1038f62aa1e4ad1d03ad369',
      indexName: 'search',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/16/面经分析-20190916/"/>

  <script>
    (function(){
        if('117106032724'){
            if (prompt('Please enter your password') !== '117106032724'){
                alert('wrong password��');
                history.back();
            }
        }
    })();
</script>



  <title>面经分析-20190916 | muxin's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2cb6ba3a1c27ee1fc0a8e6d0dcb28522";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>





<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <script src="https://highness94.github.io/live2d/autoload.js"></script>
  
  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">muxin's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">contact me by email:dreamcore@126.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github-alt"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			
			<!--���ӵĴ��� start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/面经分析-20190916/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="muxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="muxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面经分析-20190916</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-16T09:39:18+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/16/面经分析-20190916/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/09/16/面经分析-20190916/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="网易互娱"><a href="#网易互娱" class="headerlink" title="网易互娱"></a>网易互娱</h2><p>原帖</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">一面 共计时长<span class="number">1</span>h+</span><br><span class="line">牛客视频面试，两位面试官一起面，面试官们态度都特别好，面试体验极佳</span><br><span class="line"><span class="number">1.</span>自我介绍</span><br><span class="line">介绍了学校，项目（这一部分重点介绍），常用的编程语言，以及喜欢的游戏（划重点 阴阳师签到<span class="number">900</span>+天🤣）</span><br><span class="line"><span class="number">2.</span>Static关键字各种用法，Static声明的函数能否在其他文件中调用</span><br><span class="line"><span class="number">3.</span>Const关键字各种用法</span><br><span class="line"><span class="number">4.</span>虚函数的原理介绍一下，哪些函数不能是虚函数</span><br><span class="line"><span class="number">5.</span>虚函数指针在多继承下的情况</span><br><span class="line">比如类C继承了类A和类B。A，B中都有虚函数，那么C的虚表指针有多少个，</span><br><span class="line"><span class="number">6.</span>类C又定义了自己的虚函数，在虚表中的存储位置？</span><br><span class="line"><span class="comment">//问题5和6推荐看一下这篇博客 说的很详细 https://blog.csdn.net/li1914309758/article/details/79916414</span></span><br><span class="line"><span class="number">7.</span>C++<span class="number">11</span>的新特性了解哪些</span><br><span class="line"><span class="number">8.</span>右值引用和move()方法说一下</span><br><span class="line"><span class="number">9.</span>所有的智能指针说一下，全局变量和静态变量可以用智能指针吗</span><br><span class="line"><span class="number">10.</span><span class="built_in">shared_ptr</span>实现一下</span><br><span class="line"><span class="number">11.</span>weak_ptr如何解决<span class="built_in">shared_ptr</span>的循环引用问题，具体举一个例子说一下</span><br><span class="line"><span class="comment">//可以直接敲代码实现例子</span></span><br><span class="line"><span class="number">12.</span>stl平时用过哪些，大致把每一部分介绍一下</span><br><span class="line"><span class="number">13.</span><span class="built_in">map</span>和<span class="built_in">unordered_map</span>用过吗，底层如何实现的，它们的区别有哪些</span><br><span class="line"><span class="number">14.</span>红黑树和哈希表有什么关系，介绍一下红黑树的特性，插入，删除</span><br><span class="line"><span class="number">15.</span>哈希表处理冲突的几种方法说一下</span><br><span class="line"><span class="number">16.</span>使用再哈希法处理过冲突的哈希表，平均查找的时间复杂度是多少</span><br><span class="line"><span class="number">17.</span>再哈希法如何优化</span><br><span class="line"><span class="number">18.</span>线程同步的加锁方法有哪些</span><br><span class="line"><span class="number">19.</span>进程切换为什么比线程切换开销大，介绍TLB</span><br><span class="line"><span class="number">20.</span>死锁相关 包括死锁的必要条件，银行家算法等</span><br><span class="line"><span class="number">21.</span>平时有多线程开发经验吗</span><br><span class="line"><span class="number">22.</span>了解哪些排序方法，重点说了快排</span><br><span class="line"><span class="number">23.</span>了解过计算机图形学吗</span><br><span class="line"><span class="comment">//不怎么了解，这个是加分项，会的话加分，不会的话也没关系</span></span><br><span class="line"><span class="number">24.</span>笔试复盘 把笔试题目的思路和做法讲一遍</span><br><span class="line"><span class="number">25.</span>优化一下笔试第三题</span><br><span class="line"><span class="comment">//当时我是使用暴力法做的，面试官让思考一下能否使用dp来优化，我没想出来</span></span><br><span class="line"><span class="number">25.</span>嘉宾提问环节</span><br><span class="line"><span class="comment">//提问：如何强化出6号位爆伤16暴的破势🤣（误）</span></span><br><span class="line"></span><br><span class="line">二面 共计时长<span class="number">50</span>min</span><br><span class="line">牛客视频面试，这次是一位面试官单独面，面试官态度极好，我爱互娱🤣</span><br><span class="line"><span class="number">1.</span>自我介绍 重点介绍了项目，围绕项目主要说，包括项目的实现/创新点/难点/论文内容等等</span><br><span class="line"><span class="number">2.</span>平时玩过哪些游戏，在游戏中最难忘的经历有哪些</span><br><span class="line"><span class="comment">//开荒H古尔丹，为了部落</span></span><br><span class="line"><span class="number">3.</span>魔兽世界玩过哪些版本，最喜欢哪个版本</span><br><span class="line"><span class="number">4.</span>对行业内的游戏公司有哪些了解</span><br><span class="line"><span class="number">5.</span>用unity3D做过什么游戏，说一下使用过程中的技术难点</span><br><span class="line"><span class="number">6.</span>智力题</span><br><span class="line">有一张桌子，桌子上有很多砖头，现在我们要把砖头摞在桌子边缘又不能让砖头掉下去，同时要让砖头在桌子边沿之外的部分尽可能长，怎么摞</span><br><span class="line"><span class="comment">//这题我答的不好，基本就是一顿胡说面试官都笑了</span></span><br><span class="line"><span class="number">7.</span>场景题</span><br><span class="line">有一张表，表里存放了很多玩家信息和他们对应的IP地址，IP地址对应不同的位置</span><br><span class="line">需要实现的是玩家一登录，获取到玩家的IP地址，并且返回对应的地址，如果IP地址不在表中，则完成一个插入操作并判断</span><br><span class="line">用什么数据结构来实现</span><br><span class="line"><span class="comment">//个人的思路：使用多叉查找树来做，类似数据库索引</span></span><br><span class="line"><span class="number">8.</span>接上一题，如果还要同时快速查找一个区间的IP应该怎么做</span><br><span class="line"><span class="comment">//个人的思路：使用跳表来做</span></span><br><span class="line"><span class="number">9.</span>数据库的索引是用什么实现的</span><br><span class="line"><span class="number">10.B</span>树和B+树有什么区别，为什么不用红黑树或者普通二叉树来实现索引</span><br><span class="line"><span class="comment">//重点：减少IO次数</span></span><br><span class="line"><span class="number">11.</span>愉快的聊天环节，聊游戏，聊工作，聊人生</span><br><span class="line"><span class="number">12.</span>面试官给我讲段子之论做游戏有多快乐🤣</span><br></pre></td></tr></table></figure>
<p>解析</p>
<h3 id="Static关键字各种用法，Static声明的函数能否在其他文件中调用"><a href="#Static关键字各种用法，Static声明的函数能否在其他文件中调用" class="headerlink" title="Static关键字各种用法，Static声明的函数能否在其他文件中调用"></a>Static关键字各种用法，Static声明的函数能否在其他文件中调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 函数内<span class="keyword">static</span>局部变量：变量在程序初始化时被分配，直到程序退出前才被释放，也就是<span class="keyword">static</span>是按照程序的生命周期来分配释放变量的，而不是变量自己的生命周期。多次调用，仅需一次初始化。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> cpp内的<span class="keyword">static</span>全局变量：只在cpp内有效。在不同的cpp文件中定义同名变量，不必担心命名冲突。保持变量内容的持久。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 头文件内的<span class="keyword">static</span>全局变量：在每个包含该头文件的cpp文件中都是独立的。不推荐使用。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">static</span>函数：仅在当前文件内有效。在不同的cpp文件中定义同名函数，不必担心命名冲突。对其它源文件隐藏。在现代C++中被无名<span class="keyword">namespace</span>取代。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 类的<span class="keyword">static</span>数据成员：必须在<span class="class"><span class="keyword">class</span>的外部初始化。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">6. 类的<span class="title">static</span>函数：不能访问类的私有成员，只能访问类的<span class="title">static</span>成员，不需要类的实例即可调用。可以继承和覆盖，但无法是虚函数。属于整个类而非类的对象，没有<span class="title">this</span>指针。静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数。非静态成员函数可以任意地访问静态成员函数和静态数据成员。静态成员函数不能访问非静态成员函数和非静态数据成员。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">7. 单例模式(<span class="title">Singleton</span>)中使用<span class="title">static</span>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、为什么静态成员不能在类内初始化？<br>在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。</p>
<p>class A<br>{<br>private:<br>static int count ; // 类内声明<br>};</p>
<p>int A::count = 0 ; // 类外初始化，不必再加static关键字</p>
<p>为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p>
<p>《c++primer》<strong>里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法</strong>。 但为什么static const int就可以在类里面初始化呢？<br>想起C中一个函数里定义一个static变量是为了保证只初始化一次。 那么，是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,这样编译器就不必考虑类的函数里面第一个对static变量的’=’操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。</p>
<p>2、什么东西能在类内初始化<br>能在类中初始化的成员只有一种，那就是静态常量成员。</p>
<p>这样不行<br>class A<br>{<br>private:<br>static int count = 0; // 静态成员不能在类内初始化<br>};</p>
<p>这样也不行<br>class A<br>{<br>private:<br>const int count = 0; // 常量成员也不能在类内初始化<br>};</p>
<p>但是这样可以<br>class A<br>{<br>private:<br>static const int count = 0; // 静态整型常量成员可以在类内初始化，但是 static const float count就不行了<br>}; </p>
</blockquote>
<h3 id="Const关键字各种用法"><a href="#Const关键字各种用法" class="headerlink" title="Const关键字各种用法"></a>Const关键字各种用法</h3><p>C++中使用const关键字来修饰常量，下面从两个方面总结：<strong>变量</strong>和<strong>成员函数</strong>。</p>
<p><strong>变量</strong>：const可以修饰普通变量、指针（数组）和结构体。</p>
<p>1.const修饰<strong>普通变量</strong>是最简单的情形。这样的用法多为在程序中创建一个只读变量，类似于C语言的#define宏定义，但const声明的变量可以指定类型，因此在C++中提倡使用const关键字声明只读变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Month = <span class="number">12</span>;　　<span class="comment">/* 示例代码 1 */</span></span><br></pre></td></tr></table></figure>
<p>示例代码1表示：定义了一个int型变量Month，程序可以使用该变量，但不可对Month变量重新赋值，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = Month + <span class="number">3</span>;　　　　<span class="comment">/* 正确 */</span></span><br><span class="line">Month = <span class="number">6</span>;　　　　　　　　　　<span class="comment">/* 错误 */</span></span><br></pre></td></tr></table></figure>
<p>2.下面是const修饰<strong>指针</strong>的情形。这样的情形多见于将指针/数组作为某个函数的参数，为了防止调用该函数时无意或错误修改了原指针数据，常在指针参数前添加const关键字，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strMsg)</span></span>;　　<span class="comment">/* 示例代码 2 */</span></span><br></pre></td></tr></table></figure>
<p>示例代码2声明了一个返回值为void的函数ShowMsg，假设该函数的作用是显示某个字符串的内容，我们在使用的时候不希望该函数修改原字符串的内容，因此可以将参数前添加const关键字，这样，如果函数代码中错误出现了修改strMsg字符串的代码，程序编译将会报错。</p>
<p>下面，分四种情况详细叙述const和指针的搭配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 3 */</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pB = &amp;a;     　　　　<span class="comment">/* 1 */</span>   </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *pB = &amp;a;　　　　　　　<span class="comment">/* 2 */</span> </span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> pB = &amp;a;　　　　　　 <span class="comment">/* 3 */</span> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> pB = &amp;a;　　　<span class="comment">/* 4 */</span></span><br></pre></td></tr></table></figure>
<p>请看示例代码3中的四种情形，我们可以这样来记忆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const位于星号左侧表示指针指向的变量为常值，上述1、2两种情况的作用一样，指针变量指向的值为常值，不可使用指针变量pB来修改该值，换句话说，*pB的值为const不可修改，即不可执行*pB = 11;（但是a = 11是合法的，int b = 11;pB = &amp;b 也是合法的）。注意：可以将const变量的地址赋给const指针（如示例3），但不可将const变量的地址赋给非const指针。</span><br></pre></td></tr></table></figure>
<p>如以下代码是<strong>非法</strong>的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误代码示例 */</span><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const位于星号右侧表示是一个常量指针，该指针地址不可被修改。3表示pB只可指向&amp;a地址，但可以使用*pB = 11来改变a的值。4是以上两种情况的综合。</span><br></pre></td></tr></table></figure>
<p>3.使用const修饰函数一般出现在<strong>成员函数</strong>中，如下形式：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码4 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">　　　　......</span><br><span class="line">　　<span class="keyword">public</span>:</span><br><span class="line">　　　　...</span><br><span class="line">　　　　<span class="function"><span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span> <span class="keyword">const</span></span>;　　<span class="comment">/* 函数声明 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>像示例代码4中那样声明的函数称为const成员函数，该函数不会修改类对象，即不会对类的私有成员变量进行改动。</p>
<p><strong>const</strong> 表示该函数不会改变类中的数据。为什么最好要加 <strong>const</strong> 呢？</p>
<p>原因是假如我们在程序中这样定义了一个对象并且调用这两个函数，而这假设类中两个函数没有加 <strong>const</strong> ，那么编译器就会报错。 </p>
<h3 id="虚函数的原理介绍一下，哪些函数不能是虚函数"><a href="#虚函数的原理介绍一下，哪些函数不能是虚函数" class="headerlink" title="虚函数的原理介绍一下，哪些函数不能是虚函数"></a>虚函数的原理介绍一下，哪些函数不能是虚函数</h3><p><strong>虚函数的底层实现原理</strong></p>
<p><strong>实现原理：虚函数表+虚表指针</strong></p>
<p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，<strong>每个类使用一个虚函数表，每个类对象用一个虚表指针</strong>。</p>
<p>举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。<em>看下面两种情况：</em></p>
<ul>
<li><p>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。</p>
</li>
<li><p>如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">看到类P的三个实例p1,p2,p3他们的实例指针是不相同的，而虚函数表指针是同一个。</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">总结一下，如果C++类中定义过虚函数，不管是只定义了一个还是多个，那么这个类就会生出一个虚函数表，里面包含所有虚函数的地址指针列表，而类的每一个对象实例在内存的开头位置，都额外分配一个指针变量，指向类的虚函数表。</span><br><span class="line">当call一个虚函数的时候，首先从<span class="keyword">this</span>指针位置读出虚函数表，然后从虚函数表里面拿出虚函数的正确地址，在call到这个地址。</span><br><span class="line"></span><br><span class="line">把虚函数表指针放在对象内存的开始位置是linux环境下的结果，不同的编译运行环境可能会不同，比如windows系统下就把虚函数表指针放在对象内存的结尾部。</span><br><span class="line"> </span><br><span class="line">这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</span><br><span class="line"></span><br><span class="line">她是编译器在编译时期为我们创建好的, 只存在一份</span><br><span class="line">定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</span><br></pre></td></tr></table></figure>
<p><strong>虚函数调用过程</strong></p>
<p><img src="/2019/09/16/面经分析-20190916/064bb159a5a563699dbabaf8bb737e1.png" alt="064bb159a5a563699dbabaf8bb737e1"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编译器只知道pb是B*类型的指针，并不知道它指向的具体对象类型 ：pb可能指向的是B的对象，也可能指向的是D的对象。  </span><br><span class="line">但对于“pb-&gt;bar()”，编译时能够确定的是：此处<span class="keyword">operator</span>-&gt;的另一个参数是B::bar（因为pb是B*类型的，编译器认为bar是B::bar），而B::bar和D::bar在各自虚函数表中的偏移位置是相等的。 </span><br><span class="line"></span><br><span class="line">无论pb指向哪种类型的对象，只要能够确定被调函数在虚函数中的偏移值，待运行时，能够确定具体类型，并能找到相应vptr了，就能找出真正应该调用的函数。 </span><br><span class="line"></span><br><span class="line">提示：本人曾在“C/C++杂记：深入理解数据成员指针、函数成员指针”一文中提到：虚函数指针中的ptr部分为虚函数表中的偏移值（以字节为单位）加<span class="number">1</span>。 </span><br><span class="line">B::bar是一个虚函数指针， 它的ptr部分内容为<span class="number">9</span>，它在B的虚函数表中的偏移值为<span class="number">8</span>（<span class="number">8</span>+<span class="number">1</span>=<span class="number">9</span>）。 </span><br><span class="line">当程序执行到“pb-&gt;bar()”时，已经能够判断pb指向的具体类型了： </span><br><span class="line"></span><br><span class="line">如果pb指向B的对象，可以获取到B对象的vptr，加上偏移值<span class="number">8</span>（(<span class="keyword">char</span>*)vptr + <span class="number">8</span>），可以找到B::bar。</span><br><span class="line">如果pb指向D的对象，可以获取到D对象的vptr，加上偏移值<span class="number">8</span>（(<span class="keyword">char</span>*)vptr + <span class="number">8</span>） ，可以找到D::bar。</span><br><span class="line">如果pb指向其它类型对象...同理...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1）虚函数按照其声明顺序放于表中。<br>2）父类的虚函数在子类的虚函数前面。</p>
</blockquote>
<p>多重继承**</p>
<p>当一个类继承多个类，且多个基类都有虚函数时，子类对象中将包含多个虚函数表的指针（即多个vptr），例：</p>
<p><img src="/2019/09/16/面经分析-20190916/5e197d1be3fbf69d630ba615426d137.png" alt="5e197d1be3fbf69d630ba615426d137"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其中：D自身的虚函数与B基类共用了同一个虚函数表，因此也称B为D的主基类（primary base <span class="class"><span class="keyword">class</span>）。</span></span><br><span class="line"><span class="class">虚函数替换过程与前面描述类似，只是多了一个虚函数表，多了一次拷贝和替换的过程。</span></span><br><span class="line"><span class="class">虚函数的调用过程，与前面描述基本类似，区别在于基类指针指向的位置可能不是派生类对象的起始位置，以如下面的程序为例：</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/16/面经分析-20190916/1dbbc48c03e86aceb701e8bbe8185cc.png" alt="1dbbc48c03e86aceb701e8bbe8185cc"></p>
<p><strong>哪些不能是虚函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.普通函数。</span><br><span class="line"></span><br><span class="line">2.友元函数。</span><br><span class="line"></span><br><span class="line">以上两个都不是类的成员函数</span><br><span class="line"></span><br><span class="line">4.静态成员函数；虚函数一定要通过对象来调，而静态成员函数不用（说明静态成员函数不在虚表之中）。</span><br><span class="line"></span><br><span class="line">5.构造函数；拷贝构造函数（构造函数还没有调就还没有对象，就没有指向虚表的指针，就不可以通过虚表去调用，这是一个先有鸡还是先有蛋的问题）</span><br><span class="line"></span><br><span class="line">6.但建议把析构函数给成虚函数（防止内存泄漏），如下代码可以说明这个问题</span><br><span class="line">5.内联函数；</span><br><span class="line"></span><br><span class="line">inline函数在编译时被展开，在调用处将整个函数替换为代码块，省去了函数跳转的时间，提高了SD，减少函数调用的开销，虚函数是为了继承后对象能够准确的调用自己的函数，执行相应的动作。</span><br><span class="line"></span><br><span class="line">主要的原因是：inline函数在编译时被展开，用函数体去替换函数，而virtual是在运行期间才能动态绑定的，这也决定了inline函数不可能为虚函数。（inline函数体现的是一种编译机制，而virtual体现的是一种动态运行机制</span><br><span class="line"></span><br><span class="line">注意：派生类里的析构函数最好给成虚函数。否则派生类中如有空间的开辟那么有可能造成内存泄露</span><br><span class="line"></span><br><span class="line">7.运算符重载可以写成虚函数但不建议用,如果硬要写成虚函数，可以看到写出的代码如下， </span><br><span class="line"></span><br><span class="line"> 可以看得因为参数列表的不同所以并不可以构成重写。也就是说写成虚函数是没有作用的（因为虚函数的作用是通过重写来实现的）。</span><br><span class="line"></span><br><span class="line">换句话说必须是类的成员函数</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>virtual在函数中的使用限制</strong></p>
<ul>
<li><strong>普通函数不能是虚函数，也就是说这个函数必须是某一个类的成员函数，不可以是一个全局函数，否则会导致编译错误。</strong></li>
<li><strong>静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。</strong></li>
<li><strong>内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。</strong></li>
<li><strong>构造函数不能是虚函数，否则会出现编译错误。</strong></li>
</ul>
</blockquote>
<h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><blockquote>
<p>一、内存分配方式</p>
<p>1.从静态存储区域分配。内存在程序编译的过程中就已经分配好，这块内存在程序的整个运行期间都存在。例如：全局变量和static变量。</p>
<p>2.在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数运行结束时，这些存储单元会被自动释放，栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存数量有限。</p>
<p>3.从堆上分配，又被称为动态内存分配。程序在运行过程中用malloc和new申请任意大小的内存，程序员自己负责在何时用free或者delete释放内存。内存的存在周期由我们自己决定，比较灵活，但同时出现的问题也比较多。</p>
<p>二、经常会出现的内存问题以及问题分析和解决方法</p>
<p>1.内存重复释放（一般在出现double free时基本上都是这个原因）</p>
<p>*关于double free会在下篇博客中讲解</p>
<p>2.内存泄漏。申请的内存忘了释放。</p>
<p>3.内存越界使用</p>
<p>4.内存未分配成功确使用了它</p>
<p>5.内存分配成功却没有初始化就使用了内存</p>
<p>6.使用了无效指针</p>
<p>（1）已经释放对象，却继续操作改指针所指的对象</p>
<pre><code>a.程序当中的对象调用关系过于复杂，是在难以搞清哪个对象是否已经释放了内存，从根本上解决对象管理混乱的情况。

b.函数的return语句写错了，注意不要返回指向“栈内存”的指针或者引用。

c.使用free或者delete释放之后，没有将其置空，导致产生野指针。
</code></pre><p>（2）多线程中某一动态分配的对象同时被两个线程使用，一个线程释放了该对象，另一个线程却继续对该对象进行操作</p>
<p>三、使用规则</p>
<p>1.在malloc或者new之后应立即检查是否将其置为空，防止其使用指针值为NULL的空间。</p>
<p>2.不要忘记为指针和数组赋初始值，防止将未被初始化的内存作为右值使用</p>
<p>3.避免数组或者指针的下标越界，要特别注意多一，少一操作</p>
<p>4.动态内存的申请与释放必须配对使用，避免出现内存泄漏</p>
<p>5.用free或者delete之后要立即将其置为空，防止出现“野指针”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">=======================================================================</span><br><span class="line">内存溢出（out of memory）</span><br><span class="line">是指程序在申请内存时，没有足够的内存空间供其使用。</span><br><span class="line">=======================================================================</span><br><span class="line">内存泄漏（memory leak）</span><br><span class="line">是指程序在申请内存后，无法释放已申请的内存空间，占用有用内存。</span><br><span class="line"></span><br><span class="line"> 注：内存泄漏最终会导致内存溢出</span><br><span class="line">简单理解，内存溢出就是要求分配的内存超出了系统所给的。内存泄漏是指向系统申请分配内存进行使用（<span class="keyword">new</span>），但是用完后不归还（<span class="keyword">delete</span>），导致占用有效内存。</span><br><span class="line"></span><br><span class="line">内存泄漏可分为<span class="number">4</span>类：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>常发性内存泄漏 </span><br><span class="line"></span><br><span class="line"> 引起内存泄漏的代码会被很多次执行，每次执行的时候都会导致内存泄漏</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>偶发性内存泄漏</span><br><span class="line"></span><br><span class="line">在某些特定的环境下执行引起内存泄漏的代码，才会引起内存泄漏</span><br><span class="line"></span><br><span class="line">从以上两种内存泄漏的方式来看，测试环境和测试方法在程序生命周期的重要性是不可或缺的。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>一次性内存泄漏</span><br><span class="line"></span><br><span class="line">代码只会执行一次，但总有一块内存发生泄漏，多见于构造类的时候，析构函数没有释放内存。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>隐式泄漏</span><br><span class="line"></span><br><span class="line">程序运行过程中不断的分配内存，直到结束时才释放内存，但一般服务器程序会运行较长的时间，不及时释放也会导致内存耗尽以至于内存泄漏。</span><br><span class="line"></span><br><span class="line">综上所述，一次性内存泄漏对用户的程序维护是没有什么实质性的伤害，但在实际生活中，我们还是尽可能要避免此类的事件发生。</span><br><span class="line">=======================================================================</span><br><span class="line">内存越界</span><br><span class="line">是指向系统申请一块内存后，使用时却超出申请范围。比如一些操作内存的函数：<span class="built_in">sprintf</span>、<span class="built_in">strcpy</span>、<span class="built_in">strcat</span>、<span class="built_in">vsprintf</span>、<span class="built_in">memcpy</span>、<span class="built_in">memset</span>、memmove。当造成内存泄漏的代码运行时，所带来的错误是无法避免的，通常会造成</span><br><span class="line"><span class="number">1.</span>破坏了堆中内存内存分配信息数据</span><br><span class="line"><span class="number">2.</span>破坏了程序其他对象的内存空间</span><br><span class="line"><span class="number">3.</span>破坏了空闲内存块</span><br><span class="line">附：如果在之前你的程序运行一切正常，但因为你新增了几个类的成员变量或者修改了一部分代码（前提是保证你的这些修改是完全正确的）而导致程序发生错误，则因考虑是否是内存被破坏的原因了，重点排查内存是否越界。</span><br><span class="line">=======================================================================</span><br><span class="line">缓冲区溢出（栈溢出）</span><br><span class="line">程序为了临时存取数据的需要，一般会分配一些内存空间称为缓冲区。如果向缓冲区中写入缓冲区无法容纳的数据，机会造成缓冲区以外的存储单元被改写，称为缓冲区溢出。而栈溢出是缓冲区溢出的一种，原理也是相同的。分为上溢出和下溢出。其中，上溢出是指栈满而又向其增加新的数据，导致数据溢出；下溢出是指空栈而又进行删除操作等，导致空间溢出。</span><br></pre></td></tr></table></figure>
<h3 id="数据结构之哈希表"><a href="#数据结构之哈希表" class="headerlink" title="数据结构之哈希表"></a>数据结构之哈希表</h3><blockquote>
<p>哈希算法就是将任意长度的二进制值映射为固定长度的二进制串，这个映射的规则就是哈希算法，原始数据映射之后得到的二进制哈希值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一般哈希算法的要求：</span><br><span class="line"></span><br><span class="line">不能通过哈希值反向推导出原始数据（哈希算法也叫单向哈希算法）</span><br><span class="line">对输入的数据非常敏感，哪怕原始数据只是修改了一个bit，最后得到的哈希值也大不形同</span><br><span class="line">对不同的原始数据，哈希值相同的概率要非常小，散列冲突的概率要很小。</span><br><span class="line">哈希算法的执行效率要尽量的高效，即使较长的文本也能很快的计算出哈希值</span><br></pre></td></tr></table></figure>
<p>哈希算法的应用非常多最常见的有安全加密，唯一标识，数据校验，散列函数，负载均衡，数据分片，分布式存储。</p>
<p><strong>哈希冲突解决办法</strong></p>
<p><strong>1.开发定址法</strong></p>
<p>　　如果遇到冲突的时候怎么办呢？就找hash表剩下空余的空间，找到空余的空间然后插入。就像你去商店买东西，发现东西卖光了，怎么办呢？找下一家有东西卖的商家买呗。</p>
<p><strong>2.链地址法</strong></p>
<p> 　　上面所说的开发定址法的原理是遇到冲突的时候查找顺着原来哈希地址查找下一个空闲地址然后插入，但是也有一个问题就是如果空间不足，那他无法处理冲突也无法插入数据，因此需要装填因子(插入数据/空间)&lt;=1。</p>
<p>　　那有没有一种方法可以解决这种问题呢？链地址法可以，链地址法的原理时如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。我感觉业界上用的最多的就是链地址法。下面从百度上截取来一张图片，可以很清晰明了反应下面的结构。比如说我有一堆数据{1,12,26,337,353…}，而我的哈希算法是H(key)=key mod 16，第一个数据1的哈希值f(1)=1，插入到1结点的后面，第二个数据12的哈希值f(12)=12，插入到12结点，第三个数据26的哈希值f(26)=10，插入到10结点后面，第4个数据337，计算得到哈希值是1，遇到冲突，但是依然只需要找到该1结点的最后链结点插入即可，同理353。</p>
<h3 id="Hash、Hash-map、map"><a href="#Hash、Hash-map、map" class="headerlink" title="Hash、Hash_map、map"></a>Hash、Hash_map、map</h3><blockquote>
<p> C++ STL 之所以得到广泛的赞誉，也被很多人使用，不只是提供了像vector, string, list等方便的容器，更重要的是STL封装了许多复杂的数据结构算法和大量常用数据结构操作。</p>
<p><strong>vector封装数组，list封装了链表，map和 set封装了二叉树</strong>等，在封装这些数据结构的时候，<strong>STL</strong>按照程序员的使用习惯，<strong>以成员函数方式提供的常用操作</strong>，如：插入、排序、删除、查找等。让用户在 STL使用过程中，并不会感到陌生。</p>
<p> C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  hash_map和<span class="built_in">map</span>的区别在哪里？</span><br><span class="line">构造函数。hash_map需要hash函数，等于函数；<span class="built_in">map</span>只需要比较函数(小于函数). </span><br><span class="line">存储结构。hash_map采用hash表存储，<span class="built_in">map</span>一般采用红黑树(RB Tree)实现。因此其memory数据结构是不一样的。 </span><br><span class="line">    什么时候需要用hash_map，什么时候需要用<span class="built_in">map</span>?</span><br><span class="line">总体来说，hash_map 查找速度会比<span class="built_in">map</span>快，而且查找速度基本和数据数据量大小，属于常数级别;而<span class="built_in">map</span>的查找速度是<span class="built_in">log</span>(n)级别。并不一定常数就比<span class="built_in">log</span>(n)小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且hash_map的构造速度较慢。</span><br><span class="line"></span><br><span class="line">现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用。</span><br></pre></td></tr></table></figure>
<p><strong>在C++11中，unordered_map作为一种关联容器，替代了hash_map，unordered_map的底层实现是hash表，所以被称为无序关联容器。</strong></p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p><strong>何时调用拷贝函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个对象以值传递的方式传入函数体</span><br><span class="line">一个对象以值传递的方式从函数返回（与返回值优化密切相关）</span><br><span class="line">一个对象需要通过另一个对象进行初始化</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.cnblogs.com/qianqiannian/p/8946769.html" target="_blank" rel="noopener">为什么需要拷贝构造函数</a></p>
<p>　　把参数传递给函数有三种方法，一种是传值，一种是传地址，一种是传引用。传值与其他两种方式不同的地方在于 当使用传值方式的时候，会在函数里面生成传递参数的一个副本，这个副本的内容是按位从原始参数那里复制过来的，两者的内容是相同的。</p>
<p>当原始参数是一个类的对象时，它也会产生一个对象的副本，此时需要注意：一般对象在创建时都会调用构造函数来进行初始化，但是</p>
<p>在产生对象的副本时如果再执行对象的构造函数，那么这个对象的属性又再恢复到原始状态，这就不是我们希望的了。所以在产生对象</p>
<p>副本的时候，构造函数不会被执行，被执行的是一个默认的默认的拷贝构造函数。</p>
<p>　　问题原因：</p>
<p>　　当函数执行完毕要返回的时候对象副本会执行析构函数，</p>
<p>如果你的析构函数是空的话，也不会发生什么问题，但一般的析构函数都是要完成一些清理工作，如释放指针所指向的内存空间，这时候</p>
<p>可能就会出问题。 譬如：我们在构造函数中为一个指针变量分配了内存，在析构函数中释放给这个指针所指向的内存空间，在把对象传递</p>
<p>给函数至函数结束返回 的这个过程中 首先有一个对象的副本产生了。这个副本也有一个指针，它和原始对象的指针是指向同块内存空间的，</p>
<p>函数返回时，副本对象的析构函数执行了，释放了副本对象中指针指向的内存空间，但是这个内存空间对于原始对象而言还是有效地，</p>
<p>这是第一个问题，后面当原始对象也被销毁的时候，原始对象的析构函数执行，还会对那块已经释放掉的内存空间再次释放，产生严重</p>
<p>错误，这是第二个问题。</p>
<p>　　解决方法：</p>
<p>　　既然传值有这样的问题，那是否可以使用传地址或者传引用的方式解决这种问题呢？</p>
<p>　　事实上传地址和传引用确实可以解决这种问题，但是这并不适用所有的情况，有时我们不希望在函数里面的一些操作会影响到函数外部的变量。</p>
<p>为了解决这种问题，此时就需要用到拷贝构造函数，拷贝构造函数就是在产生副本对象的时候执行的，在拷贝构造函数里面我们申请一个新的内存空间，</p>
<p>这样在副本对象执行析构函数时其释放的就是新的内存空间，从而解决这个问题。</p>
<p>　　适用范围：</p>
<p>\1. 一个对象以值传递的方式传入函数体</p>
<p>\2. 一个对象以值传递的方式从函数返回</p>
<p>\3. 一个对象需要通过另外一个对象进行初始化  </p>
<p>　　拷贝构造函数不可以改变它所引用的对象，如果可以改变，那么将导致无限循环，如果类中没有显示的声明一个拷贝构造函数，</p>
<p>那么编译器会为你隐式定义一个位拷贝的默认拷贝构造函数</p>
<p>　　如果不准备使用按值传递对象，那么其实是不需要拷贝构造函数，但是我们如果不写拷贝构造函数，编译器又可能为我们创建一个默认的。</p>
<p>那么如何保证一个对象将永远不会被通过按值传递方式传递呢？</p>
<p>　　声明一个私有的拷贝构造函数，甚至不必去定义它，除非成员函数或友元函数需要执行按值传递方式的传递。否则，如果用户试图用按值传递方式传递</p>
<p>或返回对象，编译器将会报错。这是因为拷贝构造函数是私有的。因为已经显示地声明我们接管了这项工作，所以编译器不再创建默认的拷贝构造函数</p>
</blockquote>
<h3 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h3><p>指针是一个存放地址的变量，而指针引用指的是这个变量的<strong>引用</strong>，众所周知C++中如果参数不是引用的话会调用参数对象的拷贝构造函数，所以如果有需求想改变指针所指的对象（换句话说，就是要改变指针里面存的地址），就要使用指针引用。</p>
<blockquote>
<p>C++中定义指针的引用有什么好处呢？</p>
<p>首先指针引用的定义方式（以char类型为例）： char*   &amp;ptr = xxx   </p>
<p>我们知道在C语言中如果想改变实参指针所指向的位置，就要定义重指针，如下面的例子</p>
<p>// 错误 实参指针不能被赋值<br>void changePtr( char<em> ptr )<br>{<br>    ptr = (char</em>)malloc(100*sizeof(char));<br>}<br>如果要想改变实参指针所指向的地址，则需要定义重指针</p>
<p>// 正确<br>void changePtr( char*<em> dbl_ptr )<br>{
    </em>dbl_ptr = (char<em>)malloc(100</em>sizeof(char));<br>}<br>如果使用指针的引用</p>
<p>void changePtr( char<em>&amp;  ref_ptr )<br>{<br>    ref_ptr = (char</em>)malloc(100*sizeof(char));<br>}<br>就可以直接使用引用来修改实参指针所指向的位置，也就相当于用指针本身修改指针所指向的位置。</p>
<p>(当然前提不是指针常量） </p>
</blockquote>
<h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><p>C/S模式</p>
<p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<p>B/S模式</p>
<p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p>
<p>优缺点： 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。 因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏英雄联盟。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。 C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。<br>B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。 B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。 因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。 </p>
<h3 id="程序编译的四个阶段"><a href="#程序编译的四个阶段" class="headerlink" title="程序编译的四个阶段"></a>程序编译的四个阶段</h3><p>1.编译过程的四个阶段</p>
<p>源程序到目标程序执行的四个阶段如图1所示，GCC编译C源代码有四个步骤：预处理—-&gt;编译—-&gt;汇编—-&gt;链接。 <img src="/2019/09/16/面经分析-20190916/E:/PersonalBlog\source\_posts\面经分析-20190916\a4e1812cccfc18f484cc5b34fc1f853.png" alt="a4e1812cccfc18f484cc5b34fc1f853"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">以源程序hello.c为例</span><br><span class="line"></span><br><span class="line">#include intmain()&#123;printf(&quot;happy new year!\n&quot;);return0;&#125;</span><br><span class="line"></span><br><span class="line">2.预处理阶段（.c—.i）</span><br><span class="line"></span><br><span class="line">编译器将C程序的头文件编译进来，还有宏的替换，可以用gcc的参数-E来参看。</span><br><span class="line"></span><br><span class="line">命令：unix&gt;gcc –o hello hello.c </span><br><span class="line"></span><br><span class="line">作用：将hello.c预处理输出hello.i</span><br><span class="line"></span><br><span class="line">3 编译（.i—.s）转换为汇编语言文件</span><br><span class="line"></span><br><span class="line">这个阶段编译器主要做词法分析、语法分析、语义分析等，在检查无错误后后，把代码翻译成汇编语言[2]。可用gcc的参数-S来参看。 </span><br><span class="line"></span><br><span class="line">编译器(ccl)将文本文件hello.i 翻译成文本文件hello.s, 它包含一个汇编语言程序。 </span><br><span class="line"></span><br><span class="line">一条低级机器语言指令。 </span><br><span class="line"></span><br><span class="line">命令：gcc -S hello.i -o hello.s </span><br><span class="line"></span><br><span class="line">作用：将预处理输出文件hello.i汇编成hello.s文件</span><br><span class="line"></span><br><span class="line">4.汇编阶段（.s—.o）得到机器语言</span><br><span class="line"></span><br><span class="line">汇编器as 将hello.s 翻译成机器语言保存在hello.o 中（二进制文本形式）。</span><br><span class="line"></span><br><span class="line">5.链接阶段</span><br><span class="line"></span><br><span class="line">printf函数存在于一个名为printf.o的单独预编译目标文件中。必须得将其并入到hello.o的程序中，链接器就是负责处理这两个的并入，结果得到hello文件，它就是一个可执行的目标文件。</span><br></pre></td></tr></table></figure>
<h3 id="浏览器多进程架构"><a href="#浏览器多进程架构" class="headerlink" title="浏览器多进程架构"></a>浏览器多进程架构</h3><p>跟现在的很多多线程浏览器不一样，Chrome浏览器使用多个进程来隔离不同的网页。因此在Chrome中打开一个网页相当于起了一个进程</p>
<h4 id="那么Chrome为什么要使用多进程架构"><a href="#那么Chrome为什么要使用多进程架构" class="headerlink" title="那么Chrome为什么要使用多进程架构?"></a>那么Chrome为什么要使用多进程架构?</h4><p>在浏览器刚被设计出来的时候，那时的网页非常的简单，每个网页的资源占有率是非常低的，因此一个进程处理多个网页时可行的。然后在今天，大量网页变得日益复杂。把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战。因为如果浏览器中的<code>一个tab网页崩溃的话，将会导致其他被打开的网页应用</code>。另外相对于线程，进程之间是不共享资源和地址空间的,所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源,所以会存在<code>线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。</code></p>
<p>在了解这个知识点线，我们需要先说明下什么是<code>浏览器内核</code>。</p>
<h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。</p>
<h4 id="浏览器内核是多线程"><a href="#浏览器内核是多线程" class="headerlink" title="浏览器内核是多线程"></a>浏览器内核是多线程</h4><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ul>
<h3 id="select，poll，epoll"><a href="#select，poll，epoll" class="headerlink" title="select，poll，epoll"></a>select，poll，epoll</h3><blockquote>
<p>当有多个流时，可以考虑用轮训的方式<strong>逐一查看每个流目前是否有数据</strong>，若有，则进行处理。（非阻塞忙轮询－－一直主动查看流的状态）</p>
<p>缺点：cpu空耗在无用的流缓冲区检查上，浪费时间。</p>
<p>改进：引入一个代理人（select），<strong>当代理人感知到有一个或多个流的数据有变化时，再进行轮询检查</strong>。（非阻塞轮询－－有流的状态发生变化时，主动检查所有流的状态）</p>
<p>缺点：当只有一个或少数流有更新时，遍历检查所有的流非常浪费时间。（故，亦称为无差别轮询）</p>
<p>改进：当有流的状态改变时，仅处理该流相关的数据变化。（epoll－－event poll，事件轮询，精确到“什么流”发生了“什么事件”）</p>
<p>具体实现是引入了一个红黑树及一个就绪列表。</p>
<p>epoll的关键操作：</p>
<p>1、创建一个epoll对象</p>
<p>epollfd=epoll_create()</p>
<p>此时，会在内核中专属于epoll的高速cache区新建一棵红黑树以及一个就绪列表。</p>
<p>2、往epoll中添加或删除<strong>某个流</strong>的<strong>某个事件</strong></p>
<p>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN)</p>
<p>epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT)</p>
<p>“add”动作会将文件句柄（socket）加入到红黑树中，并向内核注册改句柄的回调函数，当内核检测到该句柄可读或可写时（由中断触发），就将该句柄对应的回调函数加入到就绪列表中。</p>
</blockquote>
<p>在讨论epoll的实现细节之前，先把epoll的相关操作列出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">epoll_create 创建一个epoll对象，一般epollfd = epoll_create()</span><br><span class="line"></span><br><span class="line">epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line"></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);<span class="comment">//注册缓冲区非空事件，即有数据流入</span></span><br><span class="line"></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);<span class="comment">//注册缓冲区非满事件，即流可以被写入</span></span><br><span class="line"></span><br><span class="line">epoll_wait(epollfd,...)等待直到注册的事件发生</span><br><span class="line"></span><br><span class="line">（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回<span class="number">-1</span>，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。</span><br><span class="line"></span><br><span class="line">一个epoll模式的代码大概的样子是：</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">    active_stream[] = epoll_wait(epollfd)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in active_stream[] &#123;</span><br><span class="line"></span><br><span class="line">         read <span class="keyword">or</span> write till</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一次读懂 Select、Poll、Epoll IO复用技术</p>
<p><a href="https://baijiahao.baidu.com/s?id=1611547498841608701&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1611547498841608701&amp;wfr=spider&amp;for=pc</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Tipping via QR code</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.jpg" alt="muxin 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/zhifu.jpg" alt="muxin 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/15/面经分析-20190915/" rel="next" title="面经分析-20190915">
                <i class="fa fa-chevron-left"></i> 面经分析-20190915
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/11/GA-NC/" rel="prev" title="GA_NC">
                GA_NC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</script>

      
    </div>
  </div>


          </div>
          


          


  

    
      <script id="dsq-count-scr" src="https://xzx.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/09/16/面经分析-20190916/';
          this.page.identifier = '2019/09/16/面经分析-20190916/';
          this.page.title = '面经分析-20190916';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://xzx.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




    

   
        <!-- UY BEGIN -->
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2159828"></script>
        <!-- UY END -->
    
  
 


	





    

   
        <!-- UY BEGIN -->
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2159828"></script>
        <!-- UY END -->
    
  
 


 



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/photo.JPG"
                alt="muxin" />
            
              <p class="site-author-name" itemprop="name">muxin</p>
              <p class="site-description motion-element" itemprop="description">Fear not that the life shall come to an end, but rather fear that it shall never have a beginning.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#网易互娱"><span class="nav-number">1.</span> <span class="nav-text">网易互娱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Static关键字各种用法，Static声明的函数能否在其他文件中调用"><span class="nav-number">1.1.</span> <span class="nav-text">Static关键字各种用法，Static声明的函数能否在其他文件中调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Const关键字各种用法"><span class="nav-number">1.2.</span> <span class="nav-text">Const关键字各种用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数的原理介绍一下，哪些函数不能是虚函数"><span class="nav-number">1.3.</span> <span class="nav-text">虚函数的原理介绍一下，哪些函数不能是虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存问题"><span class="nav-number">1.4.</span> <span class="nav-text">内存问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构之哈希表"><span class="nav-number">1.5.</span> <span class="nav-text">数据结构之哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash、Hash-map、map"><span class="nav-number">1.6.</span> <span class="nav-text">Hash、Hash_map、map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝构造函数"><span class="nav-number">1.7.</span> <span class="nav-text">拷贝构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针引用"><span class="nav-number">1.8.</span> <span class="nav-text">指针引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络应用程序设计模式"><span class="nav-number">1.9.</span> <span class="nav-text">网络应用程序设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序编译的四个阶段"><span class="nav-number">1.10.</span> <span class="nav-text">程序编译的四个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器多进程架构"><span class="nav-number">1.11.</span> <span class="nav-text">浏览器多进程架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#那么Chrome为什么要使用多进程架构"><span class="nav-number">1.11.1.</span> <span class="nav-text">那么Chrome为什么要使用多进程架构?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器内核"><span class="nav-number">1.11.2.</span> <span class="nav-text">浏览器内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器内核是多线程"><span class="nav-number">1.11.3.</span> <span class="nav-text">浏览器内核是多线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select，poll，epoll"><span class="nav-number">1.12.</span> <span class="nav-text">select，poll，epoll</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
	<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=86381&auto=1&height=66"></iframe>
</div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">muxin</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i>
 
        <!-- 不蒜子统计 -->
        <span id="busuanzi_container_site_pv">
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
        </span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv" style='display:none'>
                本站访客数<span id="busuanzi_value_site_uv"></span>人
        </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 
</div>

<div>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
        var now = new Date(); 
        function createtime() { 
            var grt= new Date("07/08/2018 12:00:00");//此处修改你的建站时间或者网站上线时间 
            now.setTime(now.getTime()+250); 
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
            document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
        } 
    setInterval("createtime()",250);
    </script> 
	
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 | Search by algolia</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2cb6ba3a1c27ee1fc0a8e6d0dcb28522";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  

  
  
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
