<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>muxin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/18d4fc6e466a8c32a8b91dfebad50ca5</icon>
  <subtitle>contact me by email:dreamcore@126.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-29T02:19:42.008Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>muxin</name>
    <email>dreamcore@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>huawei20190928-笔试</title>
    <link href="http://yoursite.com/2019/08/29/huawei20190928-%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2019/08/29/huawei20190928-笔试/</id>
    <published>2019-08-29T01:26:39.000Z</published>
    <updated>2019-08-29T02:19:42.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给一个周长，求出其能满足的直角三角形有多少种。</span><br><span class="line"></span><br><span class="line">限制：周长&lt;=100000</span><br><span class="line"></span><br><span class="line">时间限制：&lt;1s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long  num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    double yy;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(x=1;x&lt;num/3;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        yy=1.0*(((num*num)-2*num*x))/(2*num-2*x);</span><br><span class="line">        if(yy-floor(yy)&gt;1e-10)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        y=(int)yy;</span><br><span class="line">        z=num-x-y;</span><br><span class="line">        if(x&lt;=y&amp;&amp;y&lt;z)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note：</span><br><span class="line"><span class="number">1.</span>防止运算过程中数据溢出。</span><br><span class="line"><span class="number">2.</span><span class="keyword">double</span>是不精确的，所以不能将之与某个数值相比，必须确定一个极小区间如<span class="number">1e-8</span>，比如<span class="keyword">if</span>(x-<span class="built_in">floor</span>(x)&gt;<span class="number">1e-8</span>)</span><br></pre></td></tr></table></figure><h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">水题</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">5</span>][<span class="number">5</span>]=&#123;    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,    &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,    &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>&#125;,    &#123;<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>&#125;,    &#123;<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>,<span class="number">45</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> mask[<span class="number">5</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> movex[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> movey[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    mask[x][y]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)   &#123;</span><br><span class="line">        <span class="keyword">if</span>(x+movex[i]&lt;<span class="number">0</span>||x+movex[i]&gt;<span class="number">4</span>||y+movey[i]&lt;<span class="number">0</span>||x+movey[i]&gt;<span class="number">4</span>)       &#123;</span><br><span class="line">            <span class="keyword">continue</span>;       &#125;</span><br><span class="line">        <span class="keyword">if</span>(mask[x+movex[i]][y+movey[i]]==<span class="number">-1</span>)       &#123;</span><br><span class="line">            <span class="keyword">continue</span>;       &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mask[x+movex[i]][y+movey[i]]==<span class="number">1</span>)       &#123;</span><br><span class="line">            solve(x+movex[i],y+movey[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa,b,c,d,e,f;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;aa&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">6</span>]=&#123;aa,b,c,d,e,f&#125;;</span><br><span class="line">        sort(a,a+<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">int</span> loc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startx,starty;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)            &#123;</span><br><span class="line">                <span class="keyword">if</span>(loc&lt;<span class="number">6</span>&amp;&amp;table[i][j]==a[loc])               &#123;</span><br><span class="line">                    loc++;</span><br><span class="line">                    mask[i][j]=<span class="number">1</span>;</span><br><span class="line">                    startx=i;</span><br><span class="line">                    starty=j;</span><br><span class="line">                &#125;               <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mask[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solve(startx,starty);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)   &#123;</span><br><span class="line">                <span class="keyword">if</span>(mask[i][j]==<span class="number">-1</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">6</span>)        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;        <span class="keyword">else</span>        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">俩整数数组，二者元素全部相同，仅顺序不同，求删去最少的元素使得俩整数数组相等。</span><br><span class="line">比如&#123;1，3，2&#125;、&#123;3，2，1&#125;，最少删去1后&#123;3、2&#125;&#123;3，2&#125;相同符合要求，所以结果为1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="keyword">int</span> *table1=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="keyword">int</span> *table2=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="keyword">int</span> *dp=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;locmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;table1[i];</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;table2[i];</span><br><span class="line">        locmap[table2[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxlts=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(locmap[table1[i]]&gt;locmap[table1[j]])</span><br><span class="line">           &#123;</span><br><span class="line">               dp[i]=max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlts=max(maxlts,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num-maxlts&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">欢迎找出反例</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="校招 C++" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B-C/"/>
    
  </entry>
  
  <entry>
    <title>程序纠错</title>
    <link href="http://yoursite.com/2019/08/26/%E7%A8%8B%E5%BA%8F%E7%BA%A0%E9%94%99/"/>
    <id>http://yoursite.com/2019/08/26/程序纠错/</id>
    <published>2019-08-26T08:34:03.000Z</published>
    <updated>2019-08-29T02:32:57.630Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">整个公司的人员结构可以看作是一棵标准的多叉树。树的头节点是公司唯一的老板，除老板外，每个员工都有唯一的直接上级，叶节点是没有任何下属的基层员工，除基层员工外，每个员工都有一个或多个直接下级，另外每个员工都有一个快乐值。</span><br><span class="line">这个公司现在要办 party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下的原则：</span><br><span class="line">1.如果某个员工来了，那么这个员工的所有直接下级都不能来。</span><br><span class="line">2.派对的整体快乐值是所有到场员工快乐值的累加。</span><br><span class="line">3.你的目标是让派对的整体快乐值尽量大。</span><br><span class="line">给定一棵多叉树，请输出派对的最大快乐值。</span><br><span class="line">输入描述:</span><br><span class="line">第一行两个整数 n 和 root，n 表示公司的总人数，root 表示公司的老板。</span><br><span class="line"></span><br><span class="line">第二行 n 个整数 happy_i 表示员工 i 的快乐值。</span><br><span class="line"></span><br><span class="line">接下来 n - 1 行每行两个整数 u_i 和 v_i 表示 u_i 是 v_i 的直接上级。</span><br><span class="line">输出描述:</span><br><span class="line">输出一个整数表示最大快乐值。</span><br><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line">复制</span><br><span class="line">3 1</span><br><span class="line">5 1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">输出</span><br><span class="line">复制</span><br><span class="line">5</span><br><span class="line">备注:</span><br><span class="line">1 \le n \le 5000001≤n≤500000</span><br><span class="line">0 \le happy_i \le 10000≤happy </span><br><span class="line">i</span><br><span class="line">​</span><br><span class="line"> ≤1000</span><br><span class="line">输入保证是一棵树</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxlen=<span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,root;</span><br><span class="line"><span class="keyword">int</span> ye[maxlen]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> happy[maxlen];</span><br><span class="line"><span class="keyword">int</span> mask0[maxlen]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> mask1[maxlen]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;fathr_son;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GetHappyness</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> flg)</span><span class="comment">//flg=1,可去可不去。。。 flg=0,一定去不了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ye[val]==<span class="number">0</span>)    <span class="comment">//叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(flg==<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span>  happy[val]  ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flg==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask0[val]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  mask0[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flg==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask1[val]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  mask1[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt;::iterator itor;</span><br><span class="line">    <span class="keyword">if</span>(flg==<span class="number">0</span>)             <span class="comment">//本节点选择不去，下节点可以选择去或不去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        itor=fathr_son.find(val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fathr_son.count(val);i++)</span><br><span class="line">        &#123;</span><br><span class="line">               tmp+=max(GetHappyness(itor-&gt;second,<span class="number">1</span>),GetHappyness(itor-&gt;second,<span class="number">0</span>));</span><br><span class="line">               itor++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask0[val]=tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                  <span class="comment">//本节点选择去，下节点肯定不能去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=happy[val];</span><br><span class="line"></span><br><span class="line">        itor=fathr_son.find(val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fathr_son.count(val);i++)</span><br><span class="line">        &#123;</span><br><span class="line">               tmp+=GetHappyness(itor-&gt;second,<span class="number">0</span>);</span><br><span class="line">               itor++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask1[val]=tmp;;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;happy[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">      fathr_son.insert(make_pair(a,b));</span><br><span class="line">       ye[a]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max(GetHappyness(root,<span class="number">1</span>),GetHappyness(root,<span class="number">0</span>))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="快乐值 树形dp" scheme="http://yoursite.com/tags/%E5%BF%AB%E4%B9%90%E5%80%BC-%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多线程</title>
    <link href="http://yoursite.com/2019/08/20/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/20/C-多线程/</id>
    <published>2019-08-20T14:23:28.000Z</published>
    <updated>2019-08-20T14:30:10.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、C-C-多线程操作说明"><a href="#一、C-C-多线程操作说明" class="headerlink" title="一、C/C++多线程操作说明"></a>一、C/C++多线程操作说明</h1><ol><li>C/C++多线程基本操作如下：<br>\1. 线程的建立结束<br>\2. 线程的互斥和同步<br>\3. 使用信号量控制线程<br>\4. 线程的基本属性配置 </li></ol><p>在C/C++代码编写时，使用多线程机制，首先需要做的事情就是声明引用，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pthread.h&quot;</span><br></pre></td></tr></table></figure><h1 id="二、线程基本操作方法"><a href="#二、线程基本操作方法" class="headerlink" title="二、线程基本操作方法"></a>二、线程基本操作方法</h1><p>基本线程操作：</p><p>\1. pthread_create()：创建线程开始运行相关线程函数，运行结束则线程退出</p><p>\2. pthread_eixt()：因为exit()是用来结束进程的，所以则需要使用特定结束线程的函数</p><p>\3. pthread_join()：挂起当前线程，用于阻塞式地等待线程结束，如果线程已结束则立即返回，0=成功</p><p>\4. pthread_cancel()：发送终止信号给thread线程，成功返回0，但是成功并不意味着thread会终止</p><p>\5. pthread_testcancel()：在不包含取消点，但是又需要取消点的地方创建一个取消点，以便在一个没有包含取消点的执行代码线程中响应取消请求.</p><p>\6. pthread_setcancelstate()：设置本线程对cancle线程的反应</p><p>\7. pthread_setcanceltype()：设置取消状态 继续运行至下一个取消点再退出或者是立即执行取消动作</p><p>\8. pthread_setcancel()：设置取消状态</p><h1 id="三、线程互斥与同步机制"><a href="#三、线程互斥与同步机制" class="headerlink" title="三、线程互斥与同步机制"></a>三、线程互斥与同步机制</h1><p>基本的互斥与同步的操作方法：</p><p>\1. pthread_mutex_init()：互斥锁的初始化</p><p>\2. pthread_mutex_lock()：锁定互斥锁，如果尝试锁定已经被上锁的互斥锁则阻塞至可用为止</p><p>\3. pthread_mutex_trylock()：非阻塞的锁定互斥锁</p><p>\4. pthread_mutex_unlock()：释放互斥锁</p><p>\5. pthread_mutex_destory()：互斥锁销毁函数</p><h1 id="四、信号量线程控制机制"><a href="#四、信号量线程控制机制" class="headerlink" title="四、信号量线程控制机制"></a>四、信号量线程控制机制</h1><p>C/C++在使用信号量机制的时候，默认的信号量为匿名信号量。</p><p>\1. sem_init(sem)：初始化一个定位在sem的匿名信号量</p><p>\2. sem_wait()：把信号量减1操作，如果信号量的当前值为0则进入阻塞，为原子操作</p><p>\3. sem_trywait()：如果信号量的当前值为0则返回错误而不是阻塞调用(errno=EAGAIN),其实是sem_wait()的非阻塞版本</p><p>\4. sem_post()：给信号量的值加1，它是一个“原子操作”，即同时对同一个信号量做加1,操作的两个线程是不会冲突的</p><p>\5. sem_getvalue(sval)：把sem指向的信号量当前值放置在sval指向的整数上</p><p>\6. sem_destory(sem)：销毁由sem指向的匿名信号量</p><h1 id="五、多线程实践"><a href="#五、多线程实践" class="headerlink" title="五、多线程实践"></a>五、多线程实践</h1><h3 id="1-基本的线程及建立运行"><a href="#1-基本的线程及建立运行" class="headerlink" title="1. 基本的线程及建立运行"></a>1. 基本的线程及建立运行</h3><p>下面的代码是C/C++开发的基本的线程的运行，使用的就是最基本的pthread.h：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER       3                 <span class="comment">/*线程数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER       5                 <span class="comment">/*每个线程中的小任务数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS  10.0             <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">/* 线程函数例程 */</span></span><br><span class="line">    <span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">int</span> delay_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++) &#123;</span><br><span class="line">        delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">        sleep(delay_time);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>, thrd_num, count, delay_time);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line">     <span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line">     <span class="keyword">void</span> * thrd_ret;</span><br><span class="line">     srand(time(<span class="literal">NULL</span>));    </span><br><span class="line">     <span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          <span class="comment">/* 创建多线程 */</span></span><br><span class="line">          res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line">          <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line">               <span class="built_in">exit</span>(res);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line">     <span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          <span class="comment">/* 等待线程结束 */</span></span><br><span class="line">          res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">          <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例程中循环3次建立3条线程，并且使用pthread_join函数依次等待线程结束；<br>线程中使用rand()获取随机值随机休眠5次，随意会出现后执行的线程先执行完成；<br>运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ gcc thread.c -lpthread</span><br><span class="line">$ ./a.out </span><br><span class="line">Create treads success</span><br><span class="line"> Waiting <span class="keyword">for</span> threads to finish...</span><br><span class="line">Thread <span class="number">0</span> is starting</span><br><span class="line">Thread <span class="number">1</span> is starting</span><br><span class="line">Thread <span class="number">2</span> is starting</span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">0</span> delay = <span class="number">2</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">1</span> delay = <span class="number">2</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">0</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">0</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">1</span> delay = <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">2</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">1</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">2</span> delay = <span class="number">3</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">3</span> delay = <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">2</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">3</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">4</span> delay = <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> finished</span><br><span class="line">        Thread <span class="number">2</span>: job <span class="number">3</span> delay = <span class="number">6</span></span><br><span class="line">        Thread <span class="number">0</span>: job <span class="number">4</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span> finished</span><br><span class="line">Thread <span class="number">0</span> joined</span><br><span class="line">Thread <span class="number">1</span> joined</span><br><span class="line">        Thread <span class="number">2</span>: job <span class="number">4</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">2</span> finished</span><br><span class="line">Thread <span class="number">2</span> joined</span><br></pre></td></tr></table></figure><p>可以看到，线程1先于线程0执行，但是pthread_join的调用时间顺序，先等待线程0执行；<br>由于线程1已经早结束，所以线程0被pthread_join等到的时候，线程1已结束，就在等待到线程1时，直接返回； </p><h3 id="2-线程执行的互斥和同步pthread-mutex-lock"><a href="#2-线程执行的互斥和同步pthread-mutex-lock" class="headerlink" title="2. 线程执行的互斥和同步pthread_mutex_lock"></a>2. 线程执行的互斥和同步pthread_mutex_lock</h3><p>下面我们在上面的程序中增加互斥锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*thread_mutex.c*/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">#define THREAD_NUMBER        3            /* 线程数 */</span><br><span class="line">#define REPEAT_NUMBER        3            /* 每个线程的小任务数 */</span><br><span class="line">#define DELAY_TIME_LEVELS 10.0         /*小任务之间的最大时间间隔*/</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"> </span><br><span class="line">void *thrd_func(void *arg) &#123;</span><br><span class="line">     int thrd_num = (int)arg;</span><br><span class="line">     int delay_time = 0, count = 0;</span><br><span class="line">     int res;</span><br><span class="line">     /* 互斥锁上锁 */</span><br><span class="line">     res = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">     if (res) &#123;</span><br><span class="line">          printf(&quot;Thread %d lock failed\n&quot;, thrd_num);</span><br><span class="line">          pthread_exit(NULL);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;Thread %d is starting\n&quot;, thrd_num);</span><br><span class="line">     for (count = 0; count &lt; REPEAT_NUMBER; count++) &#123;          </span><br><span class="line">         delay_time = (int)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + 1;</span><br><span class="line">         sleep(delay_time);</span><br><span class="line">         printf(&quot;\tThread %d: job %d delay = %d\n&quot;, </span><br><span class="line">                                      thrd_num, count, delay_time);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;Thread %d finished\n&quot;, thrd_num);</span><br><span class="line">     pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void) &#123;</span><br><span class="line">     pthread_t thread[THREAD_NUMBER];</span><br><span class="line">     int no = 0, res;</span><br><span class="line">     void * thrd_ret;</span><br><span class="line"> </span><br><span class="line">     srand(time(NULL));</span><br><span class="line">     /* 互斥锁初始化 */</span><br><span class="line">     pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">     for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          res = pthread_create(&amp;thread[no], NULL, thrd_func, (void*)no);</span><br><span class="line">          if (res != 0) &#123;</span><br><span class="line">              printf(&quot;Create thread %d failed\n&quot;, no);</span><br><span class="line">              exit(res);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;     </span><br><span class="line">     printf(&quot;Create treads success\n Waiting for threads to finish...\n&quot;);</span><br><span class="line">     for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">          if (!res) &#123;</span><br><span class="line">                printf(&quot;Thread %d joined\n&quot;, no);</span><br><span class="line">          &#125; else  &#123;</span><br><span class="line">              printf(&quot;Thread %d join failed\n&quot;, no);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;   </span><br><span class="line">     /****互斥锁解锁***/</span><br><span class="line">     pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">     pthread_mutex_destroy(&amp;mutex);          </span><br><span class="line">     return 0;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例程中直接添加同步锁pthread_mutex_t；<br>在线程中加入，于是程序在执行线程程序时；<br>调用pthread_mutex_lock上锁，发现上锁时候后进入等待，等待锁再次释放后重新上锁；<br>所以线程程序加载到队列中等待，等待成功上锁后继续执行程序代码；<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$gcc thread_mutex.c -lpthread</span><br><span class="line">$ ./a.out </span><br><span class="line">Create treads success</span><br><span class="line"> Waiting for threads to finish...</span><br><span class="line">Thread 0 is starting</span><br><span class="line">        Thread 0: job 0 delay = 9</span><br><span class="line">        Thread 0: job 1 delay = 4</span><br><span class="line">        Thread 0: job 2 delay = 7</span><br><span class="line">Thread 0 finished</span><br><span class="line">Thread 0 joined</span><br><span class="line">Thread 1 is starting</span><br><span class="line">        Thread 1: job 0 delay = 6</span><br><span class="line">        Thread 1: job 1 delay = 4</span><br><span class="line">        Thread 1: job 2 delay = 7</span><br><span class="line">Thread 1 finished</span><br><span class="line">Thread 1 joined</span><br><span class="line">Thread 2 is starting</span><br><span class="line">        Thread 2: job 0 delay = 3</span><br><span class="line">        Thread 2: job 1 delay = 1</span><br><span class="line">        Thread 2: job 2 delay = 6</span><br><span class="line">Thread 2 finished</span><br><span class="line">Thread 2 joined</span><br></pre></td></tr></table></figure><h3 id="3-使用信号量控制线程的执行顺序sem-post"><a href="#3-使用信号量控制线程的执行顺序sem-post" class="headerlink" title="3. 使用信号量控制线程的执行顺序sem_post"></a>3. 使用信号量控制线程的执行顺序sem_post</h3><p>修改上面例程，上面的是使用pthread_mutex_lock互斥锁控制线程执行顺序，<br>使用另外一种线程执行顺序的控制：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/* thread_sem.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"> </span><br><span class="line">#define THREAD_NUMBER       3</span><br><span class="line">#define REPEAT_NUMBER       3</span><br><span class="line">#define DELAY_TIME_LEVELS   10.0</span><br><span class="line"> </span><br><span class="line">sem_t sem[THREAD_NUMBER];</span><br><span class="line"> </span><br><span class="line">void * thrd_func(void *arg) &#123;</span><br><span class="line">    int thrd_num = (int)arg;</span><br><span class="line">    int delay_time = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    sem_wait(&amp;sem[thrd_num]);</span><br><span class="line">    printf(&quot;Thread %d is starting\n&quot;, thrd_num);</span><br><span class="line">    for (count = 0; count &lt; REPEAT_NUMBER; count++) &#123;</span><br><span class="line">        delay_time = (int)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + 1;</span><br><span class="line">        sleep(delay_time);</span><br><span class="line">        printf(&quot;\tThread %d: job %d delay = %d\n&quot;, thrd_num, count, delay_time);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Thread %d finished\n&quot;, thrd_num);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void) &#123;</span><br><span class="line">    pthread_t thread[THREAD_NUMBER];</span><br><span class="line">    int no = 0, res;</span><br><span class="line">    void * thrd_ret;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">        sem_init(&amp;sem[no], 0, 0);</span><br><span class="line">        res = pthread_create(&amp;thread[no], NULL, thrd_func, (void*)no);</span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line">            printf(&quot;Create thread %d failed\n&quot;, no);</span><br><span class="line">            exit(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Create treads success\n Waiting for threads to finish...\n&quot;);</span><br><span class="line">    sem_post(&amp;sem[THREAD_NUMBER - 1]);</span><br><span class="line">    for (no = THREAD_NUMBER - 1; no &gt;= 0; no--) &#123;</span><br><span class="line">        res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">        if (!res) &#123;</span><br><span class="line">            printf(&quot;Thread %d joined\n&quot;, no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;Thread %d join failed\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;sem[(no + THREAD_NUMBER - 1) % THREAD_NUMBER]);           </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">        sem_destroy(&amp;sem[no]);      </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果，仍然是建立3条线程，每条线程执行时休眠随机时长：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ gcc thread_sem.c -lpthread </span><br><span class="line">$ ./a.out </span><br><span class="line">Create treads success</span><br><span class="line"> Waiting for threads to finish...</span><br><span class="line">Thread 2 is starting</span><br><span class="line">        Thread 2: job 0 delay = 9</span><br><span class="line">        Thread 2: job 1 delay = 9</span><br><span class="line">        Thread 2: job 2 delay = 5</span><br><span class="line">Thread 2 finished</span><br><span class="line">Thread 2 joined</span><br><span class="line">Thread 1 is starting</span><br><span class="line">        Thread 1: job 0 delay = 5</span><br><span class="line">        Thread 1: job 1 delay = 7</span><br><span class="line">        Thread 1: job 2 delay = 4</span><br><span class="line">Thread 1 finished</span><br><span class="line">Thread 1 joined</span><br><span class="line">Thread 0 is starting</span><br><span class="line">        Thread 0: job 0 delay = 3</span><br><span class="line">        Thread 0: job 1 delay = 9</span><br><span class="line">        Thread 0: job 2 delay = 8</span><br><span class="line">Thread 0 finished</span><br><span class="line">Thread 0 joined</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>执行结果与第2个例程非常相似，只不过教材中进行倒序执行而已；<br>那么这种方式其实与使用互斥锁相比，代码量可读性基本持平不相上下；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、C-C-多线程操作说明&quot;&gt;&lt;a href=&quot;#一、C-C-多线程操作说明&quot; class=&quot;headerlink&quot; title=&quot;一、C/C++多线程操作说明&quot;&gt;&lt;/a&gt;一、C/C++多线程操作说明&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;C/C++多线程基本操作如下：&lt;br
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++  并发</title>
    <link href="http://yoursite.com/2019/08/20/C-%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2019/08/20/C-并发/</id>
    <published>2019-08-20T14:13:36.000Z</published>
    <updated>2019-08-21T09:34:51.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yi并发"><a href="#yi并发" class="headerlink" title="yi并发"></a>yi并发</h1><h1 id="一-并发"><a href="#一-并发" class="headerlink" title="一 并发"></a>一 并发</h1><h2 id="1-1，-什么叫并发-concurrency"><a href="#1-1，-什么叫并发-concurrency" class="headerlink" title="1.1， 什么叫并发 concurrency?"></a>1.1， 什么叫并发 concurrency?</h2><p>一遍走路一边说话；你打球我游泳</p><p>单核计算机上的并发是个假象，其实只是<strong>任务切换</strong>（task switching）需要上下文切换<br>多处理器或一个处理器上有多个核上的并发才是自然的并发，叫<strong>硬件并发</strong></p><p>并发种类： </p><h3 id="1，多进程并发"><a href="#1，多进程并发" class="headerlink" title="1，多进程并发"></a>1，多进程并发</h3><p>这些进程间可通过正常的进程通信渠道（信号，套接字，文件，管道等）<br>缺点：1；通信建立较复杂或者慢；2；操作系统需要花时间启动进程和管理进程资源等<br>优点：1；更容易写安全的并发代码比如Erlang语言 2；可以运行在不同的机器上 </p><p><img src="/2019/08/20/C-并发/cf01ff5499ce6602833d34363c9bb58.png" alt="cf01ff5499ce6602833d34363c9bb58"></p><h3 id="2，多线程并发"><a href="#2，多线程并发" class="headerlink" title="2，多线程并发"></a>2，多线程并发</h3><p>线程像轻量级的进程；每个线程互相独立，一个进程的所有线程分享同一个地址空间，多数数据可以共享，比如全局变量，指针和引用可以在线程间传递；<br>优点：共享地址空间和没有数据保护使得使用多线程程序比多进程程序代价小<br>The shared address space and lack of protection of data between threads makes the overhead associated with using multi- ple threads much smaller than that from using multiple pro- cesses<br> <img src="/2019/08/20/C-并发/4243b496ca682cc595c8ac101d8eefb.png" alt="4243b496ca682cc595c8ac101d8eefb"></p><h2 id="1-2-为什么使用并发"><a href="#1-2-为什么使用并发" class="headerlink" title="1.2 为什么使用并发"></a>1.2 为什么使用并发</h2><p>1，分离关注点<br>考虑一个桌面DVD应用<br>one thread can handle the user interface and another the DVD playback；<br>该应用线程的个数不受当前核数影响，而是根据设计而非纯粹提高吞吐量</p><p>2，性能<br>1，任务并行： 把任务划分为几部分并行执行 ；任务之间很可能有依赖<br>2，数据并行： 每个线程完成不同数据部分的相同操作<br>易并行算法 embarrassingly parallel、naturally parallel、 conveniently concurrent；扩展性好<br>nice scalability, cpu 核越多越好，视频处理，不同部分的图像可以并行处理</p><p>1.3 什么时候不使用并发<br>一般使用并发的代码更难理解，尤其是有额外复杂性的多线程代码将会导致更多的bug. 除非能带来性能提升或分离关注点，否则不要使用多线程<br>每个线程都会消耗stack 1M左右 比如32位系统， 总共4G，最多支持4096个线程，没有多余空间作为静态数据和堆数据了，64位系统也会只有有限的其它资源；通过线程池可以限制线程的数量（比如服务端程序限制连接数目）</p><p>1.4 C98<br>Posix C pthread lib 不支持跨平台<br>Boost and ACE 支持跨平台<br>C++11 支持 新的线程意识的内存模型；管理线程；保护共享数据；线程同步；低级原子操作<br>许多命名和结构从boost过来<br>支持原子操作让程序员写出更高效的跨平台代码 </p><h1 id="二线程之间的通信"><a href="#二线程之间的通信" class="headerlink" title="二线程之间的通信"></a>二线程之间的通信</h1><p>C++线程的通信方式有很多种,这里记录一下常用的几种:</p><p><strong>1.全局变量</strong></p><p><strong>2.互斥量</strong></p><p><strong>3.信号量</strong></p><p><strong>4.事件</strong></p><p><strong>5.临界区</strong></p><h2 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1.全局变量"></a>1.全局变量</h2><p>通过全局变量进行通信,要对该变量加关键字volatile<br>volatile(易变的):每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> signalNum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == signalNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signalNum not changed!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signalNum has changed!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signalNum = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:<img src="/2019/08/20/C-并发/1.png" alt="1"></p><h2 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2.互斥量"></a>2.互斥量</h2><p>互斥器的功能和临界区域很相似。区别是：Mutex所花费的时间比Critical Section多的多，但是Mutex是核心对象(Event、Semaphore也是)，可以跨进程使用，而且等待一个被锁住的Mutex可以设定 TIMEOUT，不会像Critical Section那样无法得知临界区域的情况，而一直死等。MFC中的对应类为CMutex。Win32函数有：创建互斥体CreateMutex() ，打开互斥体OpenMutex()，释放互斥体ReleaseMutex()。Mutex的拥有权并非属于那个产生它的线程，而是最后那个对此 Mutex进行等待操作（WaitForSingleObject等等）并且尚未进行ReleaseMutex()操作的线程。线程拥有Mutex就好像进入Critical Section一样，一次只能有一个线程拥有该Mutex。如果一个拥有Mutex的线程在返回之前没有调用ReleaseMutex()，那么这个 Mutex就被舍弃了，但是当其他线程等待(WaitForSingleObject等)这个Mutex时，仍能返回，并得到一个 WAIT_ABANDONED_0返回值。能够知道一个Mutex被舍弃是Mutex特有的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过互斥量实现线程间的同步，初始化为没有加锁的状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE mutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//对互斥量加锁,如果已经加锁了则等待其解锁,等待时间为INFINITE(表示永久)</span></span><br><span class="line">WaitForSingleObject(mutex, INFINITE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WaitForSingleObject(mutex, INFINITE);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment">这里可以做对共享资源的操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ReleaseMutex(mutex);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA lock mutex，please wait~~~~~~\n"</span>);</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA unlock mutex!!!!!!!!!!!!!!!!\n"</span>);</span><br><span class="line"><span class="comment">//互斥量解锁</span></span><br><span class="line">ReleaseMutex(mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line">WaitForSingleObject(mutex, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This is threadFuncB ~~~~~~\n"</span>);</span><br><span class="line">ReleaseMutex(mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadB, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="/2019/08/20/C-并发/2.png" alt="2"></p><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h2><p>信号量是最具历史的同步机制。信号量是解决producer/consumer问题的关键要素。对应的MFC类是Csemaphore。Win32函数 CreateSemaphore（）用来产生信号量。ReleaseSemaphore（）用来解除锁定。Semaphore的现值代表的意义是目前可用的资源数，如果Semaphore的现值为1，表示还有一个锁定动作可以成功。如果现值为5，就表示还有五个锁定动作可以成功。当调用Wait…等函数要求锁定，如果Semaphore现值不为0，Wait…马上返回，资源数减1。当调用ReleaseSemaphore（）资源数加1，当时不会超过初始设定的资源总数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用信号量</span></span><br><span class="line"><span class="comment">参数2:当前可用的信号的量个数 范围为(0 - 参数3)</span></span><br><span class="line"><span class="comment">参数3:信号量的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE signalSemaphore = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line">WaitForSingleObject(signalSemaphore, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 使用了一个信号量!\n"</span>);</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 释放了一个信号量!\n"</span>);</span><br><span class="line">ReleaseSemaphore(signalSemaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里会使信号量减1</span></span><br><span class="line">WaitForSingleObject(signalSemaphore, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncB 使用了一个信号量!\n"</span>);</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//信号量+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncB 释放了一个信号量!\n"</span>);</span><br><span class="line">ReleaseSemaphore(signalSemaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:<img src="/2019/08/20/C-并发/3.png" alt="3"></p><h2 id="4-事件"><a href="#4-事件" class="headerlink" title="4.事件"></a>4.事件</h2><p>用事件（Event）来同步线程是最具弹性的了。一个事件有两种状态：激发状态和未激发状态。也称有信号状态和无信号状态。事件又分两种类型：手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒“一个”等待中的线程，然后自动恢复为未激发状态。所以用自动重置事件来同步两个线程比较理想。MFC中对应的类为 CEvent.。CEvent的构造函数默认创建一个自动重置的事件，而且处于未激发状态。共有三个函数来改变事件的状态:SetEvent,ResetEvent和PulseEvent。用事件来同步线程是一种比较理想的做法，但在实际的使用过程中要注意的是，对自动重置事件调用SetEvent和PulseEvent有可能会引起死锁，必须小心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件进行通信</span></span><br><span class="line"><span class="comment">/*创建事件CreateEvent</span></span><br><span class="line"><span class="comment">LPSECURITY_ATTRIBUTESlpEventAttributes,// 安全属性</span></span><br><span class="line"><span class="comment">BOOLbManualReset,// 复位方式,如果是TRUE，那么必须用ResetEvent函数来复原到无信号状态。FALSE自动将事件状态复原为无信号状态。</span></span><br><span class="line"><span class="comment">BOOLbInitialState,// 初始状态,TRUE有信号,FALESE无信号</span></span><br><span class="line"><span class="comment">LPCTSTRlpName // 对象名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE threadEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 等待事件有信号!\n"</span>);</span><br><span class="line">WaitForSingleObject(threadEvent, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 等待事件信号成功,并把事件自动设置为无信号状态!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//给事件赋予信号</span></span><br><span class="line">SetEvent(threadEvent);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncB 给了事件信号!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="/2019/08/20/C-并发/4.png" alt="4"></p><p>5.临界区<br>CRITICAL_SECTION是最快的。其他内核锁（事件、互斥体），每进一次内核，都需要上千个CPU周期。<br>使用临界区域的第一个忠告就是不要长时间锁住一份资源。这里的长时间是相对的，视不同程序而定。对一些控制软件来说，可能是数毫秒，但是对另外一些程序来说，可以长达数分钟。但进入临界区后必须尽快地离开，释放资源。如果不释放的话，会如何？答案是不会怎样。如果是主线程（GUI线程）要进入一个没有被释放的临界区，呵呵，程序就会挂了！临界区域的一个缺点就是：Critical Section不是一个核心对象，无法获知进入临界区的线程是生是死，如果进入临界区的线程挂了，没有释放临界资源，系统无法获知，而且没有办法释放该临界资源。这个缺点在互斥器(Mutex)中得到了弥补。Critical Section在MFC中的相应实现类是CcriticalSection。CcriticalSection：：Lock()进入临界区，CcriticalSection：：UnLock()离开临界区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxmt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用临界区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CCriticalSection cs;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncA 等待临界区解锁!\n"</span>);</span><br><span class="line">cs.Lock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncA 等待临界区解锁成功,对其加锁!\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncA 把临界区解锁!\n"</span>);</span><br><span class="line">cs.Unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cs.Lock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncB 把临界区锁住了!\n"</span>);</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncB 把临界区解锁!\n"</span>);</span><br><span class="line">cs.Unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/20/C-并发/20190718152652341.png" alt="20190718152652341"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yi并发&quot;&gt;&lt;a href=&quot;#yi并发&quot; class=&quot;headerlink&quot; title=&quot;yi并发&quot;&gt;&lt;/a&gt;yi并发&lt;/h1&gt;&lt;h1 id=&quot;一-并发&quot;&gt;&lt;a href=&quot;#一-并发&quot; class=&quot;headerlink&quot; title=&quot;一 并发&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++ 并发" scheme="http://yoursite.com/tags/C-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Seek Offer</title>
    <link href="http://yoursite.com/2019/08/20/Seek-Offer/"/>
    <id>http://yoursite.com/2019/08/20/Seek-Offer/</id>
    <published>2019-08-20T13:45:34.000Z</published>
    <updated>2019-08-20T13:45:34.276Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20190129记记录-Day_01</title>
    <link href="http://yoursite.com/2019/01/29/20190129%E8%AE%B0%E8%AE%B0%E5%BD%95-Day-01/"/>
    <id>http://yoursite.com/2019/01/29/20190129记记录-Day-01/</id>
    <published>2019-01-29T02:42:05.000Z</published>
    <updated>2019-02-08T12:40:48.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一动态规划"><a href="#一动态规划" class="headerlink" title="一动态规划"></a>一动态规划</h1><h1 id="二-C-进阶"><a href="#二-C-进阶" class="headerlink" title="二 C++进阶"></a>二 C++进阶</h1><p><img src="https://img-blog.csdn.net/20180710145044258?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5na2VfMTIyNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>C只读一本书《 The C Proguamming Language 》 读读C之父的著作，抛开老谭写的那本；</p><p>C++你可以读《C++ primer》，其实当你把这两本书读通后，我想对于C/C++语言的经验（除此之外要积累项目经验）来讲找工作是一定没问题的，可能还会比很多工作了的程序员在语言方面基础好。<br>如果想精通，结合我自己的体会，建议在C++方面阅读《effective c++》《more effective c++》这时至少语言的特性你会了解很多。之后可以把c++之父写的《C++ Programming Language》当做工具书来查看。<br>要想用好C++，有两个库不得不学，stl和boost。</p><hr><p>我刚找完工作，说下自己的看法吧。<br>首先，精通就算了，如果在简历中写“精通C/C++”，一般会死的灰常灰常灰常难看。<br>其次，如果以大公司为目标，如果你就读学校够好，其实把《程序员面试宝典》看熟了理解了，笔试就没啥问题了。笔试题，千篇一律啊~~<br>第三，选择一个小方向深入研究准备面试。比如说熟悉STL，就要把相关的内存分配机制、回收机制、vector漏洞什么的搞清楚，推荐侯捷那本STL源码剖析。<br>最后，光有语言基础是不够的，还需要学会经典的算法，能顺利写出快排的代码这个难度就可以了。Linux环境也稍微熟悉一下。其实大公司校招更看重你的学习能力、思考问题的方法。语言只是工具，人人都能用笔，但不见得人人都能作画。</p><p>参考博文：<a href="https://blog.csdn.net/qq_20996129/article/details/80218771" target="_blank" rel="noopener">https://blog.csdn.net/qq_20996129/article/details/80218771</a></p><h1 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">把数值作为 key，它的下标作为 value</span><br><span class="line">* 遍历数组，判断 map 是否含有这个目标值-当前数值，</span><br><span class="line">* 有直接返回，没有的话放到map里面</span><br><span class="line">*</span><br><span class="line">* 所以以后写代码，如果有双层 for 循环，首先考虑一下能否用 map 替换一层</span><br><span class="line"></span><br><span class="line">--&gt;   https://blog.csdn.net/yusiguyuan/article/details/12883727</span><br></pre></td></tr></table></figure><p><strong> 看一下hashmap和map和maptable等等的区别和联系</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispaly</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见的通信方式：</span><br><span class="line"><span class="number">1.</span> 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</span><br><span class="line"><span class="number">2.</span> 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</span><br><span class="line"><span class="number">4.</span> 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</span><br><span class="line"><span class="number">5.</span> 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</span><br><span class="line"><span class="number">6.</span> 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</span><br><span class="line"><span class="number">7.</span> 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</span><br><span class="line"><span class="number">8.</span> 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一动态规划&quot;&gt;&lt;a href=&quot;#一动态规划&quot; class=&quot;headerlink&quot; title=&quot;一动态规划&quot;&gt;&lt;/a&gt;一动态规划&lt;/h1&gt;&lt;h1 id=&quot;二-C-进阶&quot;&gt;&lt;a href=&quot;#二-C-进阶&quot; class=&quot;headerlink&quot; title=&quot;二
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何将好的技术产品化</title>
    <link href="http://yoursite.com/2019/01/15/%E5%A6%82%E4%BD%95%E5%B0%86%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BA%A7%E5%93%81%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/15/如何将好的技术产品化/</id>
    <published>2019-01-15T13:00:10.000Z</published>
    <updated>2019-01-15T13:01:38.079Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.linkedin.com/in/pauljacksonpivot" target="_blank" rel="noopener">Paul Jackson</a>是<a href="https://castle.co/" target="_blank" rel="noopener">Castle</a>公司的 SaaS 产品经理，他拥有超过 15 年的产品开发经验。在这篇文章里，他解释了什么是产品化、产品化的重要性、产品化的过程，并列举了很多实际的例子。文章内容来自作者在 TechCity 上的一次演讲，这里可以<a href="http://www.slideshare.net/kromagz/productised" target="_blank" rel="noopener">下载</a>到相应的 PPT。</p><h2 id="什么是产品化？"><a href="#什么是产品化？" class="headerlink" title="什么是产品化？"></a>什么是产品化？</h2><p>大部分初创公司都是从一个伟大的想法开始的，并且有一堆技术专家助阵。但伟大的技术和伟大的产品之间有着天壤之别。有些人希望做出对人们有实际使用价值的产品，这篇文章就是为这些人而写的。技术可以解决问题，但它无法规模化。我想用一个动词来描述这个过程——“产品化”。顾名思义，产品化就是把某些东西变成产品的过程。</p><p>我会先探讨产品化的原则，然后再举例深入说明。我要举的例子是 x.ai 公司的私人助理机器人<a href="https://x.ai/" target="_blank" rel="noopener">Amy</a>。在 2016 年，Amy 成为初创公司和风险投资领域十分流行的会议安排助手。</p><p>我以 Amy 为例，因为 Amy 是一项已经转化为消费级产品的 AI 技术。也就是说，这项技术已经被成功地“产品化”。</p><p>Amy 之所以值得我们关注，跟 x.ai（创造 Amy 的公司）宣称自己的“反精益”也有关系。作为产品人，我们对精益创业非常熟悉。精益在某种程度上已经成为非常流行的产品开发方法论。所以，如果有公司自豪地宣称自己是“反精益”的，这件事情就会变得很有趣。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>如果我们把“精益”想象成一条轴线，那么在轴线的一端会是 Airbnb 和 Dropbox 这样的独角兽公司。它们的精益都是从 Y Combinator 复刻出来的。而 Tesla 却是另一个极端。但没有人能够指责 Elon Musk 的反精益做法，他所做的每一件事件都是划时代的，都需要巨大的资本投入。</p><p>在 Tesla 往左一点是一些 AI 公司，比如 x.ai 和 Clarif.ai。这些公司宣称“精益不适合自己的发展”。x.ai 需要三年的研发投入才能让产品走向市场。反精益在前期需要更多的资本，而且只能允许少量的迭代和返工。反精益公司在起步的时候需要对它们的用户和用户的需求了如指掌。</p><h2 id="为什么产品化这么重要？"><a href="#为什么产品化这么重要？" class="headerlink" title="为什么产品化这么重要？"></a>为什么产品化这么重要？</h2><p>把一个愿景转化成一个有用且具有完全吸引力的产品才称得上是产品化。产品化的好处在于它可以帮助你跨过市场鸿沟。<a href="https://www.youtube.com/watch?v=887i04NjDjc" target="_blank" rel="noopener">Geoffrey Moore</a>有一个很著名的发现：在一小部分科技极客公司和主流市场之间存在着一个鸿沟。他在《<a href="https://www.amazon.com/Crossing-Chasm-Marketing-High-Tech-Mainstream/dp/0060517123" target="_blank" rel="noopener">Crossing the Chasm</a>》一书中探讨了影响初创公司跨越这个鸿沟的诸多因素，而产品化就是其中的一个方面。</p><p>产品化有助于绕开技术栈谬论的陷阱。<a href="https://techcrunch.com/2016/01/18/why-big-companies-keep-failing-the-stack-fallacy/" target="_blank" rel="noopener">Anshu Sharma</a>提出了技术栈谬论一说，他曾经是 Oracle 的产品经理，现在是 Storm Ventures 的合伙人。技术栈谬论的核心观点是说，在一个给定的技术栈里，每一个供应商都会高估自己的重要性，同时会低谷其它层，越是处在栈的上层，就越是如此。</p><p>技术栈谬论可以用来解释为什么“数据库公司会认为 SaaS 应用只不过是数据库应用而已，他们认为数据库最终会赢得市场”。</p><p>Anshu 认为，能够发展起来的公司是因为他们赢在了用户体验层，他们清楚地知道终端用户的方方面面。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>作为一个产品经理，我支持这种观点。根据我的经验，要赢得市场就要为客户的价值着想，产品化要聚焦产出而不是功能特性。</p><p>我们都非常熟悉“Job To Be Done”产品方法论。人们使用产品不是因为喜欢产品本身，他们是想通过使用产品来获得某些产出。Clay Christensen 的理论在这些年获得了很多<a href="http://www.forbes.com/sites/hbsworkingknowledge/2016/10/04/clayton-christensen-customers-dont-simply-buy-products-they-hire-them/#5a1412df5712" target="_blank" rel="noopener">支持</a>，我觉得这是有原因的。我坚信很多产品能够帮助人们获得他们想要的结果。只有情感方面的东西，比如品牌认知和美学体验，才超越了这个范畴。</p><p>产品化意味着要聚焦用户想要达成的结果，而不是底层的技术。因为竞争趋势的指数级增长，这个原则变得越来越关键。Mary Meeker 的 2016 年互联网报告里有两项统计数据引起了我的注意。第一个数据是说，美国人有 80% 的时间花在了 3 个应用程序上，至于是哪几个应用就没有必要提及了。2016 年底发布的 Nielsen 数据表明，<a href="https://medium.freecodecamp.com/all-of-2016s-top-mobile-apps-are-owned-by-either-google-or-facebook-a9c56d77a74b#.t3p8049k7" target="_blank" rel="noopener">Google 和 Facebook</a>这两家公司包揽了排名靠前的 8 个移动应用。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>第二个数据是说，50% 的美国人在一个月内不会下载新的应用。这个数字表明，新晋者面临的最大挑战是如何吸引用户的眼球。新应用的推广速度已经达到了饱和状态，因为市场上有太多的选择。对于初创公司来说，它们只有很短的时间来推销自己。如果无法把握住这个机会，就会面临失败。</p><h2 id="产品的三个阶段"><a href="#产品的三个阶段" class="headerlink" title="产品的三个阶段"></a>产品的三个阶段</h2><p>“产品”是什么？一个产品有三个阶段：<strong>产品着陆、完成核心任务和后期管理</strong>。你应该从这三个方面来考量你的产品。横跨这三者的是用户亲密度。在设计产品时，要时刻考虑用户的想法，就好像他们正在跟你的产品进行交互一样。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>用户对产品的认识开始于产品着陆之初。在这个阶段，他们对产品只有很少的了解。在产品着陆之后，他们开始使用产品来完成任务，那么他们就不可避免地对产品变得熟悉起来。如果他们继续使用产品，甚至把产品融入他们的生活，那么产品的后期管理就变得越来越重要。</p><p>除了上述的三个阶段，有必要再加入第四个，也就是初始的推广阶段。在这个阶段要让用户知道产品的存在。我不打算详细地讲解这个阶段，因为从根本上说它应该属于市场营销，超出了产品的范畴。不过，还是要记住产品与市场都是同一个共同体的组成部分。</p><p><a href="https://25iq.com/2016/04/02/a-dozen-things-ive-learned-from-chamath-palihapitiya-about-investing-and-business/" target="_blank" rel="noopener">Chamath Palihapitiya</a>对此做了很好的描述：</p><blockquote><p>“对于一个产品的用户来说，他们只有三种状态——他们从来没有听说过这个产品；他们试用过这个产品；他们使用了这个产品。你所要做的就是管理好这些状态”。</p></blockquote><p>理解用户的想法是让每个阶段都能成功的关键。在每个阶段，你需要倾听用户的声音。在推广阶段，用户对你一无所知。他们会说“你是谁？我为什么要使用你的产品？我有必要关心那么多吗？”在产品着陆阶段，他们会说“我会考虑的。我已经为此花了时间，我有在考虑，不过你还是要说服我”。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>一旦他们到达了核心任务阶段，就算跨过了一个里程碑。在这个阶段，他们会说“你是我的。我知道你是用来做什么的，我想看到你能够为我带来的价值”。管理阶段都是有关客户化服务的。用户会说“我得到了你所能够提供的价值，不过我想要根据我的需求来做一些定制”。</p><p>如果你对 Dave McClure 的“盗版度量指标”很熟悉，或许可以把它们与上述的四个阶段映射起来。最左边是推广指数，激励发生在产品着陆阶段，保留客户和收益是核心任务，移交一般发生在管理阶段。在这个阶段，你完全可以期待用户能够成为产品的拥护者。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><h2 id="产品价值"><a href="#产品价值" class="headerlink" title="产品价值"></a>产品价值</h2><p>产品赢在为客户价值着想。如果你想深入了解产品价值，可以看看 Jerry Chen（来自 Greylock Partners，也是 Reid Hoffman 和 Josh Elman 工作的地方）的“<a href="https://news.greylock.com/unit-of-value-a-framework-for-scaling-42c092fba887#.rscicw5ib" target="_blank" rel="noopener">价值单元</a>”。Jerry 对独角兽公司 Salesforce、Dropbox 和 Docker 的价值单元进行了评估，并演示了这些公司是如何在他们的服务里交付和使用这些价值的。</p><p>产品是“价值交付的搬运工”。如果你正在开发一个新产品，或者有了一个新想法，你需要问自己一个最基本的问题：它的价值单元是什么？你的回答将会贯穿产品的定价、规模化和销售的整个过程。推广阶段对产品价值许下承诺。在产品着陆时要把产品价值体现出来。价值的交付就是核心任务。管理阶段是对价值的延伸，它为客户带来更大的价值，也是促销更多产品的好时机。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>在理解了产品的价值单元之后，就可以对其进行演化。对于产品经理来说，最先要做的是列出一长串开发任务。我发现使用一个 2x2 的网格（<a href="https://blog.intercom.com/first-rule-prioritization-no-snacking/" target="_blank" rel="noopener">影响力和投入度网格模型</a>）来描述这些内容是一种很有效的方式。Hunter Walk（曾经是 YouTube 的产品主管）和 Intercom 的团队都是这个模型的知名倡导者。</p><p>为了确保能够获得良好的效果，所有项目都应该出现在网格的上半部分。对交付单元价值没有帮助的项目不应该出现在那里。战略相关的项目应该出现在右上角的象限里。在与相关人员评估网格时，产品经理和他的产品团队对应该和不应该做什么达成了共识。</p><p>以 Newsmart 为例，Newsmart 是我所工作过的一个项目，它是一个商务英语教学产品，它利用 Wall Street Journal 的内容进行教学，下面是它的 2017 年产品线路图。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>大多数产品的 1.0 版本都只包含了核心任务阶段，它们都不是从产品着陆阶段开始的。产品着陆阶段是进入产品核心的一个途径。产品化要从这个阶段开始，再逐步进入其它阶段。产品化要让用户知道你的产品，理解你的产品，使用你的产品，最后提出定制需求。</p><p>B2B 领域的产品可能会更复杂一些，因为用户和投资者不是同一批人。投资者的价值单元与用户的价值单元之间有很大差别。你可能会极力改进终端用户的体验，却忽视了投资者的需求，而投资者才是最终决定是否要投资你的产品的人。所以，产品需要同时照顾到两者的价值。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>对于客户产品来说，管理阶段一般不需要考虑太多，但在 B2B 领域，它却是非常重要的一环。投资者将如何对他们的投资回报进行评估？一般是通过报告，因为报告会告诉他们用户与产品之间的亲密度，以及这种亲密度将持续多久。在 Newsmart 这个产品上，在很长一段时间内我们一直忽视了这点。我们本该在管理阶段做得更好，让投资者看到价值，而不只是用户，但当我们意识到这点时已经太晚了。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>从个人用户市场起步的产品要进入到企业市场是一个很重大的转变，因为沟通方式和市场都变了。你不再需要去说服个人用户，你需要去说服的是一堆利益相关者。想要在企业市场取得成功，需要跨越很多障碍。Slack 最近<a href="https://techcrunch.com/2016/12/07/slack-and-google-announce-partnership-focused-on-better-integrating-their-services/" target="_blank" rel="noopener">宣布要跟 Google 的 G Suite 合</a>作。在我看来，Slack 也正面临着这个转折问题。Slack 有很好的个人用户市场，但在进入企业市场方面还处在挣扎阶段，并且它也意识到其实 Google 在这方面也没有任何优势。</p><h2 id="产品设计模式"><a href="#产品设计模式" class="headerlink" title="产品设计模式"></a>产品设计模式</h2><p>如果你仔细分析上述四个阶段，会发现人们已经对每个阶段都进行过充分的讨论了。它们已经形成了设计模式，可以直接在你的产品里灵活应用。没有必要重复发明轮子，也没有必要每次都要重新学习这些东西。</p><p>我们以产品着陆阶段为例。有个叫 Samuel Hulick 的人，他已经启动了一项叫作<a href="https://www.useronboard.com/" target="_blank" rel="noopener">User Onboard</a>的业务，他的业务特色是“产品分解”。产品分解过程会对不同产品进行评估，并分析它们的优点和缺点。产品经理可以到 User Onboard 去学习如何通过几个竖线就可以快速对不同产品进行分解。</p><p>产品着陆阶段的中间点是“Aha！”，如果达到了这一点，说明用户已经了解了产品的价值单元以及这些价值与自身的关系。要在产品着陆阶段成功，就要尽快让用户达到“Aha！”这个点。因为争夺用户的竞争日趋激烈，要尽量缩短达到“Aha！”的时间。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>Chamath Palihapitiya 是另一个很好的例子。在 2008 到 2012 年间，Chamath 是 Facebook Growth Team 的主管。他与他人沟通的方式很直接，甚至有点粗鲁。他在 YouTube 上做过一个很经典的<a href="https://www.youtube.com/watch?v=raIUQP71SBU" target="_blank" rel="noopener">谈话节目</a>，他在当中直言不讳地全面否定关于成长和“成长入侵”的伪科学。对于他来说，成长就是要理解产品的价值单元。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>如果有人怀疑产品着陆的重要性，我将以 Twitter 为例。对于 Twitter 来说，2016 年并不好过。业务饱和，增长呈断崖式下滑，股价也没有什么起色。</p><p>Twitter 的问题核心是它没有与用户做好价值单元的沟通。很多人仍然不是很了解 Twitter，不知道 Twitter 能够做些什么，而且说不出要使用它的理由。Twitter 在市场和产品着陆方面做得很失败。大部分用户只是注册了 Twitter，但并不会在上面发消息或者关注其他人。在这方面的失败意味着你将无法达到“Aha！”。如果你达不到“Aha！”，就不了解产品的价值是什么。如果你不了解产品的价值，那你就完蛋了。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>为了更进一步说明，我们举一个产品着陆做得很成功的例子。我之所以选择 x.ai 的 Amy 作为例子，是因为她本质上是一项技术，而不是产品。很多重要的资源被用来开发 AI 和决策引擎，当它们进入市场，会面临很多选择。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>从产品角度来看，x.ai 做了很多明智的选择。Amy 的产品着陆很简单，但很高效。当你在注册 Amy 时，她会给你发邮件说“你好，我是你的个人助理，欢迎登录”，然后她会指引你做一些操作。因为我们经常收发邮件，所以这种交互方式对我们来说很熟悉。</p><p>如果你仔细查看 Amy 发给你的第一封邮件，你会发现她对自己的价值主张做了清楚的阐述。她说“在 13 个会议之后你将会见证奇迹”。为了演示她的价值主张，她会为你安排第一个会议。她会发送一个邀请，并询问“可以为这个礼拜四添加一个会议提醒吗？”在接受了会议邀请之后，你会看到它被移动到日历里，到此，你也就理解了她的价值主张是什么。Amy 就此达到了“Aha！”。就在一瞬间，Amy 从一个陌生新奇的东西变成了你所熟悉的助理。这个设计模式大家应该都能理解。</p><p>Amy 的背后是一项能够支撑会议安排的技术。为了对它进行产品化，x.ai 对我们的脑力模型进行了评估，并利用了很多已知的东西，而不是引入一些陌生的事物。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>对于 Amy 来说，核心任务的完成体现在她与用户之间的邮件交互上面。在邮件交换过程中，她对用户日历进行协调，最后为会议作出安排。</p><p>在管理阶段，Amy 的每一个设置首选项都是关键所在。很多人不想把会议安排在星期天早上 9 点，而我尝试着把我的大部分面谈会议安排在这天早上，而把下午空闲出来，并做好了设置。当然，设置会发生变更。当设置发生变更时，Amy 会发邮件向你确认。</p><p>对我来说，Amy 简直太优秀了，她是这一时期产品化的典范。Amy 的价值单元是帮你节省时间。Amy 会根据你的使用情况进行统计，并把每个月为你省下的时间告诉你。一年下来，省下的时间还真不少。</p><h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><p>大部分产品会接受用户的支付，而这也是一个经常被忽视的环节。在支付方面，也有相应的设计模式。有很多研究是关于“<a href="http://white.net/blog/six-principles-good-choice-architecture/" target="_blank" rel="noopener">选择架构</a>”和支付计划的。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>对目标用户支付方式的评估也很重要。在 Newsmart，我们的产品主要面向亚洲市场，我们一开始支持 PayPal 和信用卡（通过 Stripe），后来我们从用户那里得到的反馈说“我想支付，但支付不了！”。原来我们忽视了中国、台湾和韩国的主要支付方式，这说明我们在支持支付方式方面做得不到位。</p><p>如果你是中国人，Alipay 会是首选的在线支付方式。在中国，UnionPay 也很流行，但 PayPal 没有人用。所以要对目标市场的信用卡使用率进行调查。在美国之外的很多国家，信用卡使用率很低——低于 50%。如果你不支持首选的本地支付方式，就等于放弃了很多赚钱的机会，因为就算用户愿意付钱，他们也没有办法支付。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><h2 id="钩子模型"><a href="#钩子模型" class="headerlink" title="钩子模型"></a>钩子模型</h2><p>用户心里学是有效产品化的基础，Nir Eyal 的“<a href="https://medium.com/behavior-design/how-to-manufacture-desire-3011c82a2b28#.72l79qwlk" target="_blank" rel="noopener">钩子模型</a>”就是一个很值得一学的设计范式。Nir 是 BJ Fogg 的学生，Nir 的“钩子模型”是基于 Fogg 的用户行为模型而提出的。这些模型把行为看成动机、能力和触发器的产出结果。Nir 对具有“超级用户黏性”产品的相似元素进行了研究，在他看来，Facebook、Snapchat、WhatsApp 和 LinkedIn 都创造了能够影响行为变更的因素。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>具有用户黏性的产品能够把动机和触发器紧紧地联系在一起。如果产品是一款 app，那么触发器有可能就是发送给用户的通知，比如“这里发生了一些事情，如果不来看你就会错过”。通知总是会把你拉向产品一边。如果你收到一封来自 Facebook 的邮件，接下来就会有后续的动作把你推向他们的产品。在 Nir 的模型里，最强大的动机是“各种各样的奖励”。从心理学角度说，奖励比破坏更容易让人上瘾。</p><p>可变性会在产品体验里注入未知的元素，它会让用户产生 FOMO（Fear of Missing Out，译为害怕错过），从而迫使他们采取行动。触发器和各种各样的奖励组合在一起，促使我们去使用 Snapchat 和 Facebook。FOMO 也是我们离不开这些平台的原因。你可能经常听到有人说他们已经中了 Facebook 的毒，并打算不再使用 Facebook，但没有人真的这么做过。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你要开发一个产品，不要只关注技术，而在一开始就要考虑价值问题。一旦你清楚你所能提供的价值，接下来就要想清楚如何把它展示出来，让用户知道，并把它们交付给用户。要时刻警觉用户对产品的熟悉程度，不要忽略了用户的诉求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.linkedin.com/in/pauljacksonpivot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Paul Jackson&lt;/a&gt;是&lt;a href=&quot;https://castle.co/&quot; targe
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>临时文件</title>
    <link href="http://yoursite.com/2018/10/29/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/10/29/临时文件/</id>
    <published>2018-10-29T12:13:48.000Z</published>
    <updated>2018-10-29T12:17:01.170Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxx,minn,total=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;table[i][j];</span><br><span class="line"> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  maxx=minn=total=table[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  total+=table[i][j];</span><br><span class="line">   <span class="keyword">if</span>(table[i][j]&gt;maxx)</span><br><span class="line">   &#123;</span><br><span class="line">   maxx=table[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(minn&gt;table[i][j])</span><br><span class="line">   &#123;</span><br><span class="line">   minn=table[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the max number is"</span>&lt;&lt;maxx&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the min number is"</span>&lt;&lt;minn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the total is"</span>&lt;&lt;total&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/29/临时文件/1.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="C++ 临时" scheme="http://yoursite.com/tags/C-%E4%B8%B4%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令小结（一）</title>
    <link href="http://yoursite.com/2018/10/12/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/10/12/Linux-常用命令小结（一）/</id>
    <published>2018-10-12T08:28:18.000Z</published>
    <updated>2018-10-12T08:28:18.723Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络七层模型</title>
    <link href="http://yoursite.com/2018/10/12/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/10/12/网络七层模型/</id>
    <published>2018-10-12T07:43:33.000Z</published>
    <updated>2018-10-12T07:48:54.454Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/10/12/网络七层模型/12.png" alt="12"></p><p>OSI七层模式简单通俗理解</p><p>这个模型学了好多次，总是记不住。今天又看了一遍，发现用历史推演的角度去看问题会更有逻辑，更好记。本文不一定严谨，可能有错漏，主要是抛砖引玉，帮助记性不好的人。总体来说，OSI模型是从底层往上层发展出来的。</p><p>这个模型推出的最开始，是是因为美国人有两台机器之间进行通信的需求。</p><p>需求1：</p><p>科学家要解决的第一个问题是，两个硬件之间怎么通信。具体就是一台发些比特流，然后另一台能收到。</p><p>于是，科学家发明了物理层：</p><p>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特。</p><p>需求2：</p><p>现在通过电线我能发数据流了，但是，我还希望通过无线电波，通过其它介质来传输。然后我还要保证传输过去的比特流是正确的，要有纠错功能。</p><p>于是，发明了数据链路层：</p><p>定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p><p>需求3：</p><p>现在我能发正确的发比特流数据到另一台计算机了，但是当我发大量数据时候，可能需要好长时间，例如一个视频格式的，网络会中断好多次（事实上，即使有了物理层和数据链路层，网络还是经常中断，只是中断的时间是毫秒级别的）。</p><p>那么，我还须要保证传输大量文件时的准确性。于是，我要对发出去的数据进行封装。就像发快递一样，一个个地发。</p><p>于是，先发明了传输层（传输层在OSI模型中，是在网络层上面）</p><p>例如TCP，是用于发大量数据的，我发了1万个包出去，另一台电脑就要告诉我是否接受到了1万个包，如果缺了3个包，就告诉我是第1001，234，8888个包丢了，那我再发一次。这样，就能保证对方把这个视频完整接收了。</p><p>例如UDP，是用于发送少量数据的。我发20个包出去，一般不会丢包，所以，我不管你收到多少个。在多人互动游戏，也经常用UDP协议，因为一般都是简单的信息，而且有广播的需求。如果用TCP，效率就很低，因为它会不停地告诉主机我收到了20个包，或者我收到了18个包，再发我两个！如果同时有1万台计算机都这样做，那么用TCP反而会降低效率，还不如用UDP，主机发出去就算了，丢几个包你就卡一下，算了，下次再发包你再更新。</p><p>TCP协议是会绑定IP和端口的协议，下面会介绍IP协议。</p><p>需求4：</p><p>传输层只是解决了打包的问题。但是如果我有多台计算机，怎么找到我要发的那台？或者，A要给F发信息，中间要经过B，C，D,E，但是中间还有好多节点如K.J.Z.Y。我怎么选择最佳路径？这就是路由要做的事。</p><p>于是，发明了网络层。即路由器，交换价那些具有寻址功能的设备所实现的功能。这一层定义的是IP地址，通过IP地址寻址。所以产生了IP协议。</p><p>需求5：</p><p>现在我们已经保证给正确的计算机，发送正确的封装过后的信息了。但是用户级别的体验好不好？难道我每次都要调用TCP去打包，然后调用IP协议去找路由，自己去发？当然不行，所以我们要建立一个自动收发包，自动寻址的功能。</p><p>于是，发明了会话层。会话层的作用就是建立和管理应用程序之间的通信。</p><p>需求6：</p><p>现在我能保证应用程序自动收发包和寻址了。但是我要用Linux给window发包，两个系统语法不一致，就像安装包一样，exe是不能在linux下用的，shell在window下也是不能直接运行的。于是需要表示层（presentation），帮我们解决不同系统之间的通信语法问题。</p><p>需求7：</p><p>OK，现在所有必要条件都准备好了，我们可以写个android程序，web程序去实现需求把。</p><p>补充：</p><p>Socket：</p><p>这不是一个协议，而是一个通信模型。其实它最初是伯克利加州分校软件研究所，简称BSD发明的，主要用来一台电脑的两个进程间通信，然后把它用到了两台电脑的进程间通信。所以，可以把它简单理解为进程间通信，不是什么高级的东西。主要做的事情不就是：</p><p>A发包：发请求包给某个已经绑定的端口（所以我们经常会访问这样的地址182.13.15.16:1235，1235就是端口）；收到B的允许；然后正式发送；发送完了，告诉B要断开链接；收到断开允许，马上断开，然后发送已经断开信息给B。</p><p>B收包：绑定端口和IP；然后在这个端口监听；接收到A的请求，发允许给A，并做好接收准备，主要就是清理缓存等待接收新数据；然后正式接收；接受到断开请求，允许断开；确认断开后，继续监听其它请求。</p><p>可见，Socket其实就是I/O操作。Socket并不仅限于网络通信。在网络通信中，它涵盖了网络层、传输层、会话层、表示层、应用层——其实这都不需要记，因为Socket通信时候用到了IP和端口，仅这两个就表明了它用到了网络层和传输层；而且它无视多台电脑通信的系统差别，所以它涉及了表示层；一般Socket都是基于一个应用程序的，所以会涉及到会话层和应用层。</p><p>mac协议和路由协议正确的关系用通俗易懂的方式可以这么来理解：<br>\1. 你现在有封信，要从北京发到上海去，你的任务仅仅是把新的内容编辑好，然后交给邮局，其他的事你不用管，你在写信的这个过程就相当于是工作在<strong>应用层</strong>；<br>\2. 路由协议：邮局收到信以后，看到信封上写着邮编，这就好比是发送目标的<a href="https://www.baidu.com/s?wd=IP&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">IP</a>地址。虽说是条条大路通罗马，从北京向北穿过北极到达美国，从美国向南绕过南极最终到达上海是一条路线，从北京经过蒙古直达欧洲，再从欧洲向西大西洋横穿美国最后从太平洋到达上海也是一条路线，路由协议就决定我到底应该走哪条路线把你的信从北京送到上海<strong>。路由协议**</strong>存在于OSI七层结构的<strong><strong>网络层</strong></strong>，<strong>通过这个协议，最终确立了你的信去上海应该经过的路径，比如，从北京先到石家庄，再从石家庄到南京，最终从南京到上海，而不是之前说的那两条路径；<br>\3. mac协议：这个</strong>协议决定了从一站到另一站到底该怎么走<strong>，具体来说，信怎么从北京到达石家庄？mac协议告诉送信邮政，得先找一辆没有满载的汽车，然后把信放在车上发送出去，如果货车都满载了找不到汽车，则应该继续去找没有满载的火车，然后把信送往石家庄。这是mac协议要做的事情。所以很清楚的是，</strong>mac协议存在于路由协议的下层。**</p><hr><p>MAC协议决定了节点什么时候允许发送分组，而且通常控制对<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82/4329158" target="_blank" rel="noopener">物理层</a>的所有访问。</p><p><strong>以太网**</strong>MAC协议–CSMA/CD协议<strong>**</strong></p><p><img src="/2018/10/12/网络七层模型/22.gif" alt="22"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/10/12/网络七层模型/12.png&quot; alt=&quot;12&quot;&gt;&lt;/p&gt;
&lt;p&gt;OSI七层模式简单通俗理解&lt;/p&gt;
&lt;p&gt;这个模型学了好多次，总是记不住。今天又看了一遍，发现用历史推演的角度去看问题会更有逻辑，更好记。本文不一定严谨，可能有错漏，
      
    
    </summary>
    
    
      <category term="整理 网络" scheme="http://yoursite.com/tags/%E6%95%B4%E7%90%86-%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>c/c++学习路线</title>
    <link href="http://yoursite.com/2018/10/10/c-c-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://yoursite.com/2018/10/10/c-c-学习路线/</id>
    <published>2018-10-10T07:42:17.000Z</published>
    <updated>2018-10-10T07:46:48.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-学习路线"><a href="#C-C-学习路线" class="headerlink" title="C/C++学习路线"></a><a href="https://www.cnblogs.com/chengjian-physique/p/8076346.html" target="_blank" rel="noopener">C/C++学习路线</a></h1><p>随着互联网及互联网+深入蓬勃的发展，经过40余年的时间洗礼，C/C++俨然已成为一门贵族语言，出色的性能使之成为高级语言中的性能王者。而在今天，它又扮演着什么样重要的角色呢？请往下看：</p><p>后端服务器，移动互联网后端，经典Windows界面开发，移动互联网端界面开发，跨平台界面开发，图形分析，系统架构，应用设计，还有现在最为流行的分布架构等一些新的技术领域。</p><p> 这么牛的语言，你是不是想知道怎样学习和掌握它呢？接下来请看经过小编整理过C/C++工程师必备知识的思维导图。</p><p><img src="/2018/10/10/c-c-学习路线/1.png" alt="1"></p><p>初学者看到这么密集的知识点，是不是有点眼晕呢？的确，C/C++是一门知识面覆盖很广的学科。想学好C/C++的你并不需要慌张，内容虽多，但依然有法可依。只要有足够的耐心和毅力，加上正确的学习方法，就不怕你学不好C/C++。</p><p>既然如此，C/C++开发到底需要学些什么呢，又应该怎么学呢？接下来由黑马程序员C/C++学院教你如何从零基础学习C/C++开发，快速进入牛人之列，掌握这门贵族语言。</p><p><strong>一、初级入门阶段</strong></p><p>在入门之初，首先要做的是通过C/C++语言的学习培养编程思维和动手能力，深刻理解面向过程和面向对象的思想方法。这个阶段你需要学习：</p><p><strong>① C语言</strong></p><p>数据类型、变量、内存布局、指针基础；</p><p>字符串、一维数组、二维数组；</p><p>一级指针，二级指针，三级指针，N级指针概念，指针数组和数组指针；</p><p>结构体、文件的使用；</p><p>动态库的封装和设计；</p><p>函数指针回调函数。</p><p> <strong>② C++语言</strong></p><p>面向对象编程思想；</p><p>类的封装，构造和析构、静态成员、对象管理；</p><p>类的构造(有参构造函数、无参构造、拷贝构造、默认构造函数)和析构；</p><p>对象动态管理、友元函数、友元类、操作符重载；</p><p>C++编译器对象管理模型分析；</p><p>类对象的动态管理(new/delete)；</p><p>友元函数和友元类；</p><p>运算符重载(一元运算符、二元运算符、运算符重载难点、项目开发中的运算符重载)；</p><p>类的继承、多继承及其二义性、虚继承；</p><p>多态(概念、意义、原理剖析、多态案例)；</p><p>虚函数、纯虚函数、抽象类(面向抽象类编程思想案例)；</p><p>函数模板、类模板，模板的继承；</p><p>C++类型转换；</p><p>C++输入输出流(标准I/O 文件I/O 字符流I/O)；</p><p>C++异常处理(异常机制、异常类型、异常变量、异常层次结构、标准异常库)；</p><p><strong>③ 常**</strong>见常用的IDE开发工具**</p><p>诸如Windows平台VC系列：VC++6.0(比较古老) ；Visual Studio2013, Visual Studio2015；Mac平台的XCode系列，还有CodeBlock，另附一些高级编辑器Notepad++, EditPlus,UE等一些开发工具的常用设置和一些常见快捷键的使用。</p><p>此阶段的学习难度系数不大，掌握这些内容之后，可以做些简单的小项目。当然了如果你想用这些技能找工作的话确实是比较困难的。这时你还应该在加把劲进一步学习第二阶段。</p><p><strong>二、C/C++开发进阶</strong></p><p>这一阶段的目标才是达到C/C++软件工程师开发行业的基本要求，这个阶段是我们走向C/C++开发的进阶之路，更是一个让自己找份薪水比较体面的工作的筹码。</p><p>如果在此部分遇到不懂的或者没有见过的知识点和名词，可先将本文收藏，供以后细细研读。</p><p>那么这个阶段，我们又应该掌握什么呢，继续往下看：</p><p><strong>①   **</strong> C++<strong>**进阶之STL</strong></p><p>STL = Standard Template Library，即标准模板库。这是提高开发效率的极品工具。通过学习此阶段，应掌握泛型编程技巧，理解容器类在C++语言中的应用模式，以及熟练掌握全部STL类的使用方法。</p><p><strong>②   **</strong> C++<strong>**进阶之设计模式</strong></p><p>决定一个项目成败最重要的因素是项目总体的设计，通过本阶段的学习，可掌握面向对象编程中重要的一环，是编码前建模的技巧所在。单例模式；工厂模式；代理模式；迭代模式等，这些都是你要掌握的哦。</p><p><strong>③   **</strong> C++<strong>**进阶之数据结构基础</strong></p><p>这是所有编程语言中最应该学习的部分，程序组成的基础之一。</p><p>顺序存储、链式存储、循环链表；</p><p>双向链表、栈(顺序和链式)、队列(顺序和链式)；</p><p>栈的应用、树基本概念及遍历、二叉树；</p><p>排序算法、并归算法、选择、插入、快速、希尔。</p><p>以上这些内容你知道吗?</p><p><strong>④   **</strong> C++<strong>**进阶之UI界面开发</strong></p><p>掌握QT类库构架，图形界面开发模型；</p><p>掌握QT开发技巧，消息机制，图形处理；</p><p>掌握QT网络编程，UDP，TCP使用方式；</p><p>掌握QT文件处理方式，序列化；</p><p>掌握QT在windows，linux，ios，android不同平台下的移植技术。</p><p><strong>⑤   **</strong> C++<strong>**进阶之Unix/Linux网络服务器</strong></p><p>掌握Unix/Linux平台开发方式；</p><p>熟练使用系统调用；</p><p>熟练Unix/Linux内存管理，进程，线程调度；</p><p>熟悉网络服务器开发方式，熟练编写TCP，UCP网络服务程序；</p><p>掌握同步/异步IO模型在网络编程中的使用方式。</p><p><strong>⑥ C++进阶之数据库开发</strong></p><p>掌握SQL语言的实用技巧。Oracle,MySQL数据库的使用方式。</p><p>如果你能熟练掌握以上列出的技能，具备解决复杂问题和技术难点的能力，而且你能独立开发一些比较复杂的功能模块，那么很荣幸地告诉你，你已经达到中级水平，薪资过万对你来说简直是小菜一碟。</p><p><strong>三、C++开发高级 </strong></p><p>读到此处的你，相信你有更高的目标。即是当下炙手可热的全栈开发工程师，既晓前端，又通后台。快速定位问题，解决问题对他们来说已是小菜一碟，就是人们常说的神秘大牛，只在公司技术攻关的时候才会才看到他们的身影。</p><p>①此阶段软件开发工作所需的知识和技能相对较难，高级软件工程师编码熟练度和规范性需要达到一定要求；</p><p>②具备一定的项目能力(包括调试能力、文档编写能力、测试能力等)和综合技术素质(包括对软件生命周期的理解、对设计模式的理解、必备的行业知识和经验等)；.</p><p>③了解主流的后台技术和前后端协作方式，能从全局角度理解项目的整个生命周期。</p><p>如果你能熟练掌握以上三个阶段的知识技能,那么你就可以满足C++开发行业的高级需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-C-学习路线&quot;&gt;&lt;a href=&quot;#C-C-学习路线&quot; class=&quot;headerlink&quot; title=&quot;C/C++学习路线&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/chengjian-physique/p/8076346
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 7反转整数</title>
    <link href="http://yoursite.com/2018/09/18/LeetCode-7%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2018/09/18/LeetCode-7反转整数/</id>
    <published>2018-09-18T12:13:51.000Z</published>
    <updated>2018-09-18T12:37:25.114Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>沐20180730Plan_LTS</title>
    <link href="http://yoursite.com/2018/07/30/%E6%B2%9020180730Plan/"/>
    <id>http://yoursite.com/2018/07/30/沐20180730Plan/</id>
    <published>2018-07-30T11:24:07.000Z</published>
    <updated>2018-07-30T13:20:52.626Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/07/30/沐20180730Plan/P1.jpg" alt="P1"></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Summary time：2018 07 30 19:36</p><p>Aim:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>完成遗留的任务，主要指导师部分的。</span><br><span class="line"><span class="number">2.</span>完成代号沐文的工作</span><br><span class="line"><span class="number">3.</span>习惯的养成</span><br><span class="line"><span class="number">4.</span>健身</span><br><span class="line"><span class="number">5.</span>吉他</span><br><span class="line"><span class="number">6.</span>工作方向</span><br><span class="line"><span class="number">7.</span>etc</span><br></pre></td></tr></table></figure><h1 id="Recent-mission"><a href="#Recent-mission" class="headerlink" title="Recent mission"></a>Recent mission</h1><p>西安项目—-需求报告完善—开发文档完善–实施文档暂定</p><p>专利交底书书写</p><p>沐文zigbee无线传感器设计</p><p>小论文写作—&gt;目前不太急迫</p><hr><p>；】】健身——-&gt;习惯</p><p>吉他  ——&gt;修身</p><p>跨界读书 —–读书笔记—-&gt;习惯</p><p>早睡早起 —&gt;习惯养成训练</p><hr><p>独立思考</p><p>学会投资</p><hr><p>工作方向</p><hr><h1 id="Specific-plan"><a href="#Specific-plan" class="headerlink" title="Specific plan"></a>Specific plan</h1>]]></content>
    
    <summary type="html">
    
      像产品或服务一样,计划如果被管理者作为进行战略决策的工具，那么它本身也必须被加以管理和塑造。
    
    </summary>
    
      <category term="Personal," scheme="http://yoursite.com/categories/Personal/"/>
    
    
      <category term="Plan" scheme="http://yoursite.com/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-No.6 Z字形变换</title>
    <link href="http://yoursite.com/2018/07/10/LeetCode-No-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/07/10/LeetCode-No-6-Z字形变换/</id>
    <published>2018-07-10T04:02:15.000Z</published>
    <updated>2018-07-10T06:07:12.316Z</updated>
    
    <content type="html"><![CDATA[<p>将字符串 <code>&quot;PAYPALISHIRING&quot;</code> 以Z字形排列成给定的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后从左往右，逐行读取字符：<code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>实现一个将字符串进行指定行数变换的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br><span class="line">输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">string</span>  result=<span class="string">""</span>;; </span><br><span class="line">   <span class="built_in">string</span> *p=<span class="keyword">new</span> <span class="built_in">string</span>[numRows];</span><br><span class="line">   <span class="built_in">string</span> tmp=<span class="string">"a"</span>;</span><br><span class="line">   <span class="keyword">int</span> num=<span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> step=numRows+(numRows<span class="number">-2</span>);<span class="comment">//numRows&gt;2</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;s.size())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numRows&amp;&amp;i&lt;s.size();j++)</span><br><span class="line">      &#123;</span><br><span class="line">        tmp[<span class="number">0</span>]=s[i++];</span><br><span class="line">        p[j]=p[j]+tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=numRows<span class="number">-2</span>;j&gt;<span class="number">0</span>&amp;&amp;i&lt;s.size();j--)</span><br><span class="line">      &#123;</span><br><span class="line">        tmp[<span class="number">0</span>]=s[i++];</span><br><span class="line">        p[j]=p[j]+tmp;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    result+=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> test=<span class="string">"PAYPALISHIRING"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;convert(test,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
    
    <summary type="html">
    
      我们这个世界的一个问题是，蠢人信誓旦旦，智人满腹狐疑。
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-No.5 最长回文子串</title>
    <link href="http://yoursite.com/2018/07/09/LeetCode-No-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/07/09/LeetCode-No-5-最长回文子串/</id>
    <published>2018-07-09T12:06:11.000Z</published>
    <updated>2018-07-09T12:11:45.216Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。*/</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> result=<span class="string">""</span>,finresult;</span><br><span class="line"><span class="keyword">int</span> max=<span class="number">0</span>; </span><br><span class="line"><span class="built_in">string</span> tmpa=<span class="string">"a"</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> step=<span class="number">1</span>;</span><br><span class="line">  tmpa[<span class="number">0</span>]=s[i];</span><br><span class="line">  result=tmpa;</span><br><span class="line">  <span class="keyword">while</span>((i-step&gt;=<span class="number">0</span>)&amp;&amp;(i+step&lt;s.size()))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(s[i-step]==s[i+step])</span><br><span class="line">   &#123;  </span><br><span class="line">     </span><br><span class="line">   tmpa[<span class="number">0</span>]=s[i-step]; </span><br><span class="line">   result=tmpa+result+tmpa; </span><br><span class="line">   step++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(step&gt;max)</span><br><span class="line">   &#123; </span><br><span class="line">   finresult=result;</span><br><span class="line">   max=step;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(step&gt;max)</span><br><span class="line">    &#123; </span><br><span class="line">    finresult=result;</span><br><span class="line">   max=step;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">int</span> maxlen=<span class="number">2</span>*max<span class="number">-1</span>;   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">  result=<span class="string">""</span>;</span><br><span class="line">  <span class="keyword">while</span>((i-step&gt;=<span class="number">0</span>)&amp;&amp;(i+<span class="number">1</span>+step&lt;s.size()))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(s[i-step]==s[i+<span class="number">1</span>+step])</span><br><span class="line">   &#123;   </span><br><span class="line">   tmpa[<span class="number">0</span>]=s[i-step];</span><br><span class="line">   result=tmpa+result+tmpa; </span><br><span class="line">      step++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">2</span>*step&gt;maxlen)</span><br><span class="line">   &#123;</span><br><span class="line">   finresult=result;</span><br><span class="line">   maxlen=<span class="number">2</span>*step;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span>*step&gt;maxlen)</span><br><span class="line">   &#123;</span><br><span class="line">   finresult=result;</span><br><span class="line">   maxlen=<span class="number">2</span>*step;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> finresult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> test=<span class="string">"aa"</span>; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;longestPalindrome(test)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h4 id="Manacher-算法（更优的一种算法"><a href="#Manacher-算法（更优的一种算法" class="headerlink" title="Manacher 算法（更优的一种算法)"></a>Manacher 算法（更优的一种算法)</h4><p>复杂度为 O(n) </p><p>参考链接<a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">http://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></p><p>其他解法</p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/</a></p>]]></content>
    
    <summary type="html">
    
      用代码行数来测评软件开发进度，就相对于用重量来计算飞机建造进度。
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序学习开发实践</title>
    <link href="http://yoursite.com/2018/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/07/09/微信小程序学习开发实践/</id>
    <published>2018-07-09T02:10:27.000Z</published>
    <updated>2018-07-09T08:20:03.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-use-WeChat-applet？"><a href="#Why-use-WeChat-applet？" class="headerlink" title="Why use WeChat applet？"></a>Why use WeChat applet？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用完即走，无需下载安装</span><br><span class="line">最初微信小程序规定源代码大小不能超过2M，现在不能超过10M </span><br><span class="line">对于前端开发而言，微信小程序因为其简单快速、开发成本低、用户流量巨大等特点，也就成了前端开发工程师必会的一个技能。</span><br></pre></td></tr></table></figure><h1 id="Learning-record"><a href="#Learning-record" class="headerlink" title="Learning record"></a>Learning record</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>注册（<a href="https://mp.weixin.qq.com）" target="_blank" rel="noopener">https://mp.weixin.qq.com）</a></p><p>安装开发工具（<a href="https://developers.weixin.qq.com/miniprogram/dev/index.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/index.html</a>）</p><p>学习文档（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html）最好的资料就是官方文档" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html）最好的资料就是官方文档</a></p><p>从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。</p><p>其中</p><p>WXML =html</p><p>WXSS =CSS</p><h2 id="微信小程序通过api接口将json数据展现到小程序示例"><a href="#微信小程序通过api接口将json数据展现到小程序示例" class="headerlink" title="微信小程序通过api接口将json数据展现到小程序示例"></a>微信小程序通过api接口将json数据展现到小程序示例</h2><p>要知道怎么通过知乎新闻的接口，来把数据展示到微信小程序端上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.request 请求接口资源（微信小程序api中的发起请求部分） </span><br><span class="line">swiper 实现轮播图的组件 </span><br><span class="line">wx:for 循环语句 </span><br><span class="line">微信小程序的基础知识</span><br></pre></td></tr></table></figure><p>请求函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line"> url: <span class="string">'******'</span>, <span class="comment">//这里填写你的接口路径</span></span><br><span class="line"> header: &#123; <span class="comment">//这里写你借口返回的数据是什么类型，这里就体现了微信小程序的强大，直接给你解析数据，再也不用去寻找各种方法去解析json，xml等数据了</span></span><br><span class="line">  <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line"> &#125;,</span><br><span class="line"> data: &#123;<span class="comment">//这里写你要请求的参数</span></span><br><span class="line">  x: <span class="string">''</span> ,</span><br><span class="line">  y: <span class="string">''</span></span><br><span class="line"> &#125;, </span><br><span class="line"> success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//这里就是请求成功后，进行一些函数操作</span></span><br><span class="line"> <span class="built_in">console</span>.log(res.data)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先上一段知乎接口数据的json格式中的开头</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">"date":"20161114",</span><br><span class="line">"stories":[</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">"images"</span>:[</span><br><span class="line">   <span class="string">"http://jb51.net.com/76125c357aa7b0ca6c9cbc41b4a5326d.jpg"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"type"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"id"</span>:<span class="number">8975316</span>,</span><br><span class="line">  <span class="attr">"ga_prefix"</span>:<span class="string">"111422"</span>,</span><br><span class="line">  <span class="attr">"title"</span>:<span class="string">"小事 · 我和你们一样"</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">"images"</span>:[</span><br><span class="line">   <span class="string">"http://jb51.net/7c908a5940384123fd88287dbc6a2c98.jpg"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"type"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"id"</span>:<span class="number">8977438</span>,</span><br><span class="line">  <span class="attr">"ga_prefix"</span>:<span class="string">"111421"</span>,</span><br><span class="line">  <span class="attr">"title"</span>:<span class="string">"成长嘛，谁说就意味着一定要长大了？"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"> data: &#123;</span><br><span class="line">  duration: <span class="number">2000</span>,</span><br><span class="line">  indicatorDots: <span class="literal">true</span>,</span><br><span class="line">  autoplay: <span class="literal">true</span>,</span><br><span class="line">  interval: <span class="number">3000</span>,</span><br><span class="line">  loading: <span class="literal">false</span>,</span><br><span class="line">  plain: <span class="literal">false</span></span><br><span class="line"> &#125;,</span><br><span class="line"> onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> that = <span class="keyword">this</span><span class="comment">//不要漏了这句，很重要</span></span><br><span class="line"> wx.request(&#123;</span><br><span class="line">  url: <span class="string">'http://news-at.zhihu.com/api/4/news/latest'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">  <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//将获取到的json数据，存在名字叫zhihu的这个数组中</span></span><br><span class="line">   that.setData(&#123;</span><br><span class="line">   zhihu: res.data.stories,</span><br><span class="line">   <span class="comment">//res代表success函数的事件对，data是固定的，stories是是上面json数据中stories</span></span><br><span class="line"> </span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>index.wxml</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;view &gt;</span><br><span class="line">&lt;swiper indicator-dots=<span class="string">"&#123;&#123;indicatorDots&#125;&#125;"</span></span><br><span class="line"> autoplay=<span class="string">"&#123;&#123;autoplay&#125;&#125;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"banners"</span> interval=<span class="string">"&#123;&#123;interval&#125;&#125;"</span> duration=<span class="string">"&#123;&#123;duration&#125;&#125;"</span>&gt;<span class="comment">//这里边的属性不重要，看下边</span></span><br><span class="line"> &lt;block wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;zhihu&#125;&#125;"</span>&gt;</span><br><span class="line">  &lt;swiper-item <span class="class"><span class="keyword">class</span></span>=<span class="string">"banner"</span> &gt;</span><br><span class="line">   &lt;image src=<span class="string">"&#123;&#123;item.image&#125;&#125;"</span> data-id=<span class="string">"&#123;&#123;item.b&#125;&#125;"</span> bindtap=<span class="string">"bindViewTap"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"banner-image"</span> width=<span class="string">"100%"</span> height=<span class="string">"100%"</span>/&gt;</span><br><span class="line">   &lt;text <span class="class"><span class="keyword">class</span></span>=<span class="string">"banner-title"</span>&gt;&#123;&#123;item.title&#125;&#125;&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>swiper-item&gt;</span><br><span class="line"> &lt;<span class="regexp">/block&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>swiper&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="regexp">/view&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      成功的主要因素：有信念、勤奋、节俭、不断学习、有毅力、建立信誉、好的人际关系、大胆、冷静、谦虚、做事有计划，并尽力做到最好、不要计较眼前得失，一件看起来吃亏的事情，往往会变成有利。
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序 玩" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%8E%A9/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的基本操作</title>
    <link href="http://yoursite.com/2018/07/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/07/03/二叉树的基本操作/</id>
    <published>2018-07-03T12:19:49.000Z</published>
    <updated>2018-07-03T12:38:07.803Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二叉树基本操作的实现</span><br><span class="line">在主程序中编写一个简单的菜单，将有关二叉树的操作</span><br><span class="line">建立一棵二叉树的存储结构</span><br><span class="line">遍历一颗二叉数（包括层次遍历）</span><br><span class="line">统计二叉树的叶子节点的个数</span><br><span class="line">求二叉树的深度</span><br><span class="line">子树交换</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉树基本操作的实现</span></span><br><span class="line"><span class="comment">在主程序中编写一个简单的菜单，将有关二叉树的操作</span></span><br><span class="line"><span class="comment">建立一棵二叉树的存储结构</span></span><br><span class="line"><span class="comment">遍历一颗二叉数（包括层次遍历）</span></span><br><span class="line"><span class="comment">统计二叉树的叶子节点的个数</span></span><br><span class="line"><span class="comment">求二叉树的深度</span></span><br><span class="line"><span class="comment">子树交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=========================二叉树结构定义======================================== </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;*BiTree,BiTNode;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//=========================先序创建二叉树========================================= </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'#'</span>) T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);</span><br><span class="line">        CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=========================遍历一颗二叉数（包括层次遍历）========================================= </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//先序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAtLevel</span><span class="params">(BiTree T)</span> <span class="comment">//层次遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;BiTree&gt; myqueue;</span><br><span class="line">myqueue.push(T);</span><br><span class="line"><span class="keyword">while</span> (!myqueue.empty()) &#123;</span><br><span class="line">BiTree tmp = myqueue.front();</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">myqueue.push(tmp-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">myqueue.push(tmp-&gt;rchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tmp-&gt;data;</span><br><span class="line">myqueue.pop();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//========================统计二叉树的叶子节点的个数============================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!T-&gt;lchild &amp;&amp;!T-&gt;rchild)</span><br><span class="line">&#123;<span class="comment">//如果二叉树左子树和右子树皆为空,说明该二叉树根节点为叶子节点,加1.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=========================求二叉树的深度========================================= </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m=Depth(T-&gt;lchild);</span><br><span class="line">        <span class="keyword">int</span> n=Depth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==========================子树交换(交换所有的左右子树)================================================== </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(BiTree rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> BiTree temp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">if</span>(rt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; rt-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">       temp = rt-&gt;lchild;</span><br><span class="line">       rt-&gt;lchild = rt-&gt;rchild;</span><br><span class="line">       rt-&gt;rchild = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(rt-&gt;lchild)</span><br><span class="line">      exchange(rt-&gt;lchild);</span><br><span class="line"> <span class="keyword">if</span>(rt-&gt;rchild)</span><br><span class="line">      exchange(rt-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===========================menu====================================================</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  system(<span class="string">"color 02"</span>);</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"======================================================主 菜 单=============================================="</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"                           1.建立一棵二叉树            2.中序遍历"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"                           3.先序遍历                  4.后序遍历"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"                           5.层次遍历                  6.统计二叉树的叶子节点的个数"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"                           7.求二叉树的深度            8.左右子树交换"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"                                       Notice: Ctrl+c结束程序"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"============================================================================================================"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==========================主程序================================================== </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    menu(); </span><br><span class="line">    <span class="keyword">int</span> choice; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"--------------------&gt; 输入你的操作码 &lt;--------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;choice;</span><br><span class="line">    <span class="keyword">switch</span>(choice)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历输入(以#结束):"</span>;  </span><br><span class="line">    CreateBiTree(T);  </span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"创建成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    InOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    PreOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"后序遍历"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    PostOrderTraverse(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"层次遍历"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    PrintAtLevel(T);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"叶子节点的个数为："</span>&lt;&lt;LeafCount(T)&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"二叉树的深度为："</span>&lt;&lt;Depth(T)&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"交换所有的左右子树"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    exchange(T);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/2018/07/03/二叉树的基本操作/1.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      C++控制台小程序，二叉树的基本操作
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="二叉树，算法，数据结构" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-No.3 无重复字符的最长字串</title>
    <link href="http://yoursite.com/2018/07/03/LeetCode-No-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/07/03/LeetCode-No-3-无重复字符的最长字串/</id>
    <published>2018-07-03T07:16:35.000Z</published>
    <updated>2018-07-05T09:40:15.638Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，找出不含有重复字符的最长子串的长度。</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给定 <span class="string">"abcabcbb"</span> ，没有重复字符的最长子串是 <span class="string">"abc"</span> ，那么长度就是<span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">给定 <span class="string">"bbbbb"</span> ，最长的子串就是 <span class="string">"b"</span> ，长度是<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">给定 <span class="string">"pwwkew"</span> ，最长子串是 <span class="string">"wke"</span> ，长度是<span class="number">3</span>。请注意答案必须是一个子串，<span class="string">"pwke"</span> 是 子序列  而不是子串。</span><br></pre></td></tr></table></figure><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CleanMak</span><span class="params">(<span class="keyword">int</span> t[] ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">     t[i]=<span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> Tmpmax=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> MaskTable[<span class="number">200</span>];</span><br><span class="line">   </span><br><span class="line">   CleanMak(MaskTable,<span class="number">200</span>);</span><br><span class="line">   <span class="keyword">int</span> preStep=<span class="number">0</span>; </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++) </span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(MaskTable[(<span class="keyword">int</span>)s[i]]==<span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">      MaskTable[(<span class="keyword">int</span>)s[i]]=i;</span><br><span class="line">      count+=<span class="number">1</span>;  </span><br><span class="line">       <span class="keyword">if</span>(count&gt;Tmpmax)</span><br><span class="line">     &#123;</span><br><span class="line">     Tmpmax=count;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123; </span><br><span class="line">    count=<span class="number">0</span>; </span><br><span class="line">    i=MaskTable[(<span class="keyword">int</span>)s[i]]; </span><br><span class="line">    CleanMak(MaskTable,<span class="number">200</span>);  </span><br><span class="line">     &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> Tmpmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">string</span> s=<span class="string">"abak"</span>;    </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;lengthOfLongestSubstring(s)&lt;&lt;<span class="built_in">endl</span>;                                   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>滑动窗口了解一下，可以参考</p><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/</a></p>]]></content>
    
    <summary type="html">
    
      当你想在你的代码中找到一个错误时，这很难；当你认为你的代码是不会有错误时，这就更难了。
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-No.2 两数相加</title>
    <link href="http://yoursite.com/2018/07/02/LeetCode-No-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2018/07/02/LeetCode-No-2-两数相加/</id>
    <published>2018-07-02T11:26:45.000Z</published>
    <updated>2018-07-09T12:08:57.492Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</span><br><span class="line"></span><br><span class="line">你可以假设除了数字 <span class="number">0</span> 之外，这两个数字都不会以零开头。</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line"> ListNode *next;</span><br><span class="line"> ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//链表打印 </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;head-&gt;val&lt;&lt;<span class="string">"  "</span>;</span><br><span class="line">head=head-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//与题无关，单链表转置 </span></span><br><span class="line"><span class="function">ListNode*  <span class="title">Reverse</span><span class="params">(ListNode* Target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode* tmpNode=Target-&gt;next;</span><br><span class="line">Target-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">ListNode* p=Target;</span><br><span class="line">Target=tmpNode;</span><br><span class="line"><span class="keyword">while</span>(Target!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmpNode=Target-&gt;next;</span><br><span class="line">Target-&gt;next=p;</span><br><span class="line">p=Target;</span><br><span class="line">Target=tmpNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     ListNode* result2=result;</span><br><span class="line">     ListNode* head=result;</span><br><span class="line">     <span class="keyword">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>,num3;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">int</span> level=<span class="number">1</span>; </span><br><span class="line">      <span class="keyword">int</span> jinwei=<span class="number">0</span>;</span><br><span class="line">      ListNode* newnode; </span><br><span class="line">      result-&gt;val=  (((l1-&gt;val+l2-&gt;val+jinwei)%<span class="number">10</span>));   </span><br><span class="line">  jinwei=(l1-&gt;val+l2-&gt;val+jinwei)/<span class="number">10</span>; </span><br><span class="line">      l1=l1-&gt;next;</span><br><span class="line">  l2=l2-&gt;next; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123; </span><br><span class="line">        newnode= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     newnode-&gt;val=(((l1-&gt;val+l2-&gt;val+jinwei)%<span class="number">10</span>)); </span><br><span class="line">     jinwei=(l1-&gt;val+l2-&gt;val+jinwei)/<span class="number">10</span>;</span><br><span class="line">result-&gt;next=newnode; </span><br><span class="line">result=newnode;   </span><br><span class="line">l1=l1-&gt;next;</span><br><span class="line">l2=l2-&gt;next; </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     l2=l1;</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        newnode= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     newnode-&gt;val=(((l2-&gt;val+jinwei)%<span class="number">10</span>));  </span><br><span class="line">     jinwei=(l2-&gt;val+jinwei)/<span class="number">10</span>;</span><br><span class="line">result-&gt;next=newnode; </span><br><span class="line">result=newnode;  </span><br><span class="line">    l2=l2-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(jinwei!=<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        newnode= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     newnode-&gt;val=jinwei;  </span><br><span class="line">result-&gt;next=newnode;  </span><br><span class="line">     &#125; </span><br><span class="line">     test(result2);</span><br><span class="line">     <span class="keyword">return</span> result2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ListNode* l1=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     ListNode* ll=l1;</span><br><span class="line">     l1-&gt;val=<span class="number">2</span>;</span><br><span class="line">     </span><br><span class="line">     ListNode* tmp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     tmp-&gt;val=<span class="number">4</span>;</span><br><span class="line">     tmp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     l1-&gt;next=tmp;</span><br><span class="line">     l1=tmp;</span><br><span class="line">     </span><br><span class="line">      tmp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     tmp-&gt;val=<span class="number">3</span>;</span><br><span class="line">     tmp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     l1-&gt;next=tmp;</span><br><span class="line">     l1=tmp; </span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line">     ListNode* l2=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     ListNode* ll2=l2;</span><br><span class="line">     l2-&gt;val=<span class="number">5</span>; </span><br><span class="line">     </span><br><span class="line">      tmp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     tmp-&gt;val=<span class="number">6</span>;</span><br><span class="line">     tmp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     l2-&gt;next=tmp;</span><br><span class="line">     l2=tmp;</span><br><span class="line">     </span><br><span class="line">     tmp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">     tmp-&gt;val=<span class="number">4</span>;</span><br><span class="line">       tmp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     l2-&gt;next=tmp;</span><br><span class="line">     l2=tmp;</span><br><span class="line">      </span><br><span class="line">    test(ll);</span><br><span class="line">      test(ll2); </span><br><span class="line">  ListNode* l3=addTwoNumbers(ll,ll2); </span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>C++中ListNode</p><p>结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;  <span class="comment">//当前结点的值</span></span><br><span class="line">      ListNode *next;  <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">      ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">//初始化当前结点值为x,指针为空</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>常见操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode* temp1 = <span class="keyword">new</span> Solution::ListNode(<span class="number">0</span>); <span class="comment">//创建新元素，</span></span><br><span class="line">ListNode* l1 = temp1; <span class="comment">//最后的结果l1指向temp1，这样可以获取temp所接收的全部元素，而temp的指针由于每次都往下移，所以每次都更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span>)   <span class="comment">//以空格区分各个结点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ungetc(c, <span class="built_in">stdin</span>);  <span class="comment">//把不是空格的字符丢回去</span></span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">                Solution::ListNode* newnode = <span class="keyword">new</span> Solution::ListNode(<span class="number">0</span>);</span><br><span class="line">                newnode-&gt;val = num;<span class="comment">//创建新的结点存放键盘中读入的值</span></span><br><span class="line">                newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                temp2-&gt;next = newnode;<span class="comment">//并将其赋值给temp2</span></span><br><span class="line">                temp2 = newnode; <span class="comment">//此处也可以写成  temp2=temp2-&gt;next,使指针指向下一个，以待接收新元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  Solution::reversePrintListNode(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; head-&gt;val; <span class="comment">//顺序输出</span></span><br><span class="line">    reversePrintListNode(head-&gt;next);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; head-&gt;val; <span class="comment">//逆序输出</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大数问题，单链表提供了一种解决方案</p>]]></content>
    
    <summary type="html">
    
      优秀的判断力来自经验，但经验来自于错误的判断。
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-No.1两数之和</title>
    <link href="http://yoursite.com/2018/07/02/LeetCode-No-1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2018/07/02/LeetCode-No-1两数之和/</id>
    <published>2018-07-02T11:13:03.000Z</published>
    <updated>2018-07-05T09:40:43.384Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</span><br><span class="line"></span><br><span class="line">你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">bool</span> flg=<span class="literal">false</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(i);</span><br><span class="line">    result.push_back(j);</span><br><span class="line">    flg=<span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    nums.push_back(<span class="number">1</span>);</span><br><span class="line">    nums.push_back(<span class="number">2</span>);</span><br><span class="line">    nums.push_back(<span class="number">3</span>);</span><br><span class="line">    nums.push_back(<span class="number">6</span>);</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re=twoSum(nums,<span class="number">5</span>); </span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Vectotr序列容器介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.vector是表示可变大小数组的序列容器。</span><br><span class="line">就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</span><br><span class="line">本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。</span><br><span class="line">vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。</span><br><span class="line">因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。</span><br><span class="line">与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。</span><br></pre></td></tr></table></figure><p>头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><p>操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">声明及初始化：</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;        <span class="comment">//声明一个int型向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">5</span>);     <span class="comment">//声明一个初始大小为5的int向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">//声明一个初始大小为10且值都是1的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(tmp);   <span class="comment">//声明并用tmp向量初始化vec向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(vec.begin(), vec.begin() + <span class="number">3</span>);  <span class="comment">//用向量vec的第0个到第2个值初始化tmp</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(arr, arr + <span class="number">5</span>);      <span class="comment">//将arr数组的元素用于初始化vec向量</span></span><br><span class="line"><span class="comment">//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，</span></span><br><span class="line"><span class="comment">//这个主要是为了和vec.end()指针统一。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(&amp;arr[<span class="number">1</span>], &amp;arr[<span class="number">4</span>]); <span class="comment">//将arr[1]~arr[4]范围内的元素作为vec的初始值</span></span><br><span class="line">常用操作</span><br><span class="line">向量大小： vec.size();</span><br><span class="line">向量最大容量： vec.max_size();</span><br><span class="line">更改向量大小： vec.resize();</span><br><span class="line">向量真实大小： vec.capacity();</span><br><span class="line">向量判空： vec.empty();</span><br><span class="line">减少向量大小到满足元素所占存储空间的大小： vec.shrink_to_fit()</span><br><span class="line">多个元素赋值： vec.assign(); <span class="comment">//类似于初始化时用数组进行赋值</span></span><br><span class="line">末尾添加元素： vec.push_back();</span><br><span class="line">末尾删除元素： vec.pop_back();</span><br><span class="line">任意位置插入元素： vec.insert();</span><br><span class="line">任意位置删除元素： vec.erase();</span><br><span class="line">交换两个向量的元素： vec.swap();</span><br><span class="line">清空向量元素： vec.clear();</span><br><span class="line">开始指针：vec.begin();</span><br><span class="line">末尾指针：vec.end(); <span class="comment">//指向最后一个元素的下一个位置</span></span><br><span class="line">指向常量的开始指针： vec.cbegin(); <span class="comment">//意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</span></span><br><span class="line">指向常量的末尾指针： vec.cend();</span><br><span class="line">下标访问： vec[<span class="number">1</span>]; <span class="comment">//并不会检查是否越界</span></span><br><span class="line">at方法访问： vec.at(<span class="number">1</span>); <span class="comment">//以上两者的区别就是at会检查是否越界，是则抛出out of range异常</span></span><br><span class="line">访问第一个元素： vec.front();</span><br><span class="line">访问最后一个元素： vec.back();</span><br><span class="line">返回一个指针： <span class="keyword">int</span>* p = vec.data(); <span class="comment">//可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      如果建筑工人盖房子的方式跟程序员写程序一样，那第一只飞来的啄木鸟就将毁掉人类文明。
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
