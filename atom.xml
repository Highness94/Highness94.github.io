<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>muxin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/18d4fc6e466a8c32a8b91dfebad50ca5</icon>
  <subtitle>contact me by email:dreamcore@126.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-09T05:56:30.438Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>muxin</name>
    <email>dreamcore@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PersonaDocument</title>
    <link href="http://yoursite.com/2019/09/09/PersonaDocument/"/>
    <id>http://yoursite.com/2019/09/09/PersonaDocument/</id>
    <published>2019-09-09T05:56:30.000Z</published>
    <updated>2019-09-09T05:56:30.438Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="http://yoursite.com/2019/09/08/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/08/常用设计模式/</id>
    <published>2019-09-08T02:05:02.000Z</published>
    <updated>2019-09-08T03:12:52.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">一概念</span><br><span class="line">单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler（Print Spooler是打印后台处理服务，即管理所有本地和网络打印队列及控制所有打印工作。如果此服务被停用，本地计算机上的打印将不可用。），以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</span><br><span class="line"></span><br><span class="line">应用场景</span><br><span class="line"></span><br><span class="line">外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。</span><br><span class="line"></span><br><span class="line">内部资源：大多数软件都有一个（或多个）属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件。</span><br><span class="line"></span><br><span class="line">二、单例模式特点：</span><br><span class="line">　　<span class="number">1</span>、单例类只能有一个实例。</span><br><span class="line">　　<span class="number">2</span>、单例类必须自己创建自己的唯一实例。</span><br><span class="line">　　<span class="number">3</span>、单例类必须给所有其他对象提供这一实例。</span><br><span class="line"></span><br><span class="line">单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。</span><br><span class="line"></span><br><span class="line">三、线程安全的问题</span><br><span class="line"></span><br><span class="line">一方面在获取单例的时候，要保证不能产生多个实例对象，后面会详细讲到若干种实现方式；</span><br><span class="line"></span><br><span class="line">另一方面，在使用单例对象的时候，要注意单例对象内的实例变量是会被多线程共享的，推荐使用无状态的对象，不会因为多个线程的交替调度而破坏自身状态导致线程安全问题，比如我们常用的VO，DTO等（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题）。</span><br><span class="line"></span><br><span class="line">四、单例模式的选择</span><br><span class="line"></span><br><span class="line">还记得我们最早使用的MVC框架Struts1中的action就是单例模式的，而到了Struts2就使用了多例。在Struts1里，当有多个请求访问，每个都会分配一个新线程，在这些线程，操作的都是同一个action对象，每个用户的数据都是不同的，而action却只有一个。到了Struts2， action对象为每一个请求产生一个实例，并不会带来线程安全问题（实际上servlet容器给每个请求产生许多可丢弃的对象，但是并没有影响到性能和垃圾回收问题，有时间会做下研究）。</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&gt; 概念插播：有状态对象和无状态对象</span><br><span class="line">&gt; 第一：基本概念： </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">1</span>、有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。 </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2</span>、无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 第二：看看代加深影响：</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/** </span></span><br><span class="line"><span class="comment">&gt;  * 有状态bean,有state,user等属性，并且user有存偖功能，是可变的。 </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  * @author Peter Wei </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  */</span> </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulBean</span> &#123;</span>  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">int</span> state;  </span><br><span class="line">&gt;     <span class="comment">// 由于多线程环境下，user是引用对象，是非线程安全的  </span></span><br><span class="line">&gt;     <span class="keyword">public</span> User user;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> state;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">this</span>.state = state;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> user;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">this</span>.user = user;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt; <span class="comment">/** </span></span><br><span class="line"><span class="comment">&gt;  * 无状态bean,不能存偖数据。因为没有任何属性，所以是不可变的。只有一系统的方法操作。 </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  * @author Peter Wei </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  */</span> </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessBeanService</span> &#123;</span>  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="comment">// 虽然有billDao属性，但billDao是没有状态信息的，是Stateless Bean.  </span></span><br><span class="line">&gt;     BillDao billDao;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> BillDao <span class="title">getBillDao</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> billDao;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBillDao</span><span class="params">(BillDao billDao)</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">this</span>.billDao = billDao;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="keyword">public</span> List&lt;User&gt; findUser(String Id) &#123;  </span><br><span class="line">&gt;          <span class="keyword">return</span> null;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1、线程安全 </span><br><span class="line">&gt; 　　要搞清楚有状态对象和无状态对象，首先需要弄清楚线程安全的问题。如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，那么就是线程安全的。 </span><br><span class="line">&gt; 　　或者说，一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。 </span><br><span class="line">&gt; 　　线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 2、关于线程安全 </span><br><span class="line">&gt; 1） 常量始终是线程安全的，因为只存在读操作。 </span><br><span class="line">&gt; 2） 每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源（共享堆内存）。 </span><br><span class="line">&gt; 3） 局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="饿汉式单例（立即加载方式）"><a href="#饿汉式单例（立即加载方式）" class="headerlink" title="饿汉式单例（立即加载方式）"></a>饿汉式单例（立即加载方式）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>设计一个类，只能生成该类的一个实例</span><br><span class="line">饿汉单例：在类装载时完成了初始化，静态成员对象初始化成功</span><br><span class="line">类加载速度相比懒汉慢，但获取对象的速度快，是一种典型的以时间换取空间的做法</span><br><span class="line">优点：线程安全</span><br><span class="line">缺点：不管你用不用这个对象，他都会先创建出来，会造成浪费内存空间</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleon()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleon()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Singleon* instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">GetSingleon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> instance;</span><br><span class="line">instance = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleon* Singleon::instance = <span class="keyword">new</span> Singleon();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleon* sl1 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl2 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl3 = Singleon::GetSingleon();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的。</p><p>Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点1.线程安全 </span><br><span class="line">2.在类加载的同时已经创建好一个静态对象，调用时反应速度快</span><br><span class="line">缺点资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</span><br></pre></td></tr></table></figure><h4 id="懒汉式单例（延迟加载方式）"><a href="#懒汉式单例（延迟加载方式）" class="headerlink" title="懒汉式单例（延迟加载方式）"></a>懒汉式单例（延迟加载方式）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleon()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleon()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Singleon*instrance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">GetSingleon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == instrance)</span><br><span class="line">&#123;</span><br><span class="line">instrance = <span class="keyword">new</span> Singleon();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象已经创建成功，无须再建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instrance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> instrance;</span><br><span class="line">instrance = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleon* Singleon::instrance =  <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleon* sl1 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl2 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl3 = Singleon::GetSingleon();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例虽然用延迟加载方式实现了懒汉式单例，但在多线程环境下会产生多个single对象，如何改造请看以下方式:</p><p>使用synchronized同步锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton3 single = null;</span><br><span class="line"></span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        </span><br><span class="line">        // 等同于 synchronized public static Singleton3 getInstance()</span><br><span class="line">        synchronized(Singleton3.class)&#123;</span><br><span class="line">          // 注意：里面的判断是一定要加的，否则出现线程安全问题</span><br><span class="line">            if(single == null)&#123;</span><br><span class="line">                single = new Singleton3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法上加synchronized同步锁或是用同步代码块对类加同步锁，此种方式虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton4 &#123;</span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton4() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton4 single = null;</span><br><span class="line"></span><br><span class="line">    // 双重检查</span><br><span class="line">    public static Singleton4 getInstance() &#123;</span><br><span class="line">        if (single == null) &#123;</span><br><span class="line">            synchronized (Singleton4.class) &#123;</span><br><span class="line">                if (single == null) &#123;</span><br><span class="line">                    single = new Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双重检查进一步做了优化，可以避免整个方法被锁，只对需要锁的代码部分加锁，可以提高执行效率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法</span><br><span class="line">缺点第一次加载时不够快，多线程使用不必要的同步开销大</span><br></pre></td></tr></table></figure><ul><li>饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢、获取对象的速度快、以空间换取时间模式、线程安全、</li><li>懒汉式单例模式：在类加载时不初始化、按照需求创建实例、以时间换取空间模式</li></ul><h4 id="静态类实现"><a href="#静态类实现" class="headerlink" title="静态类实现"></a>静态类实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton6 &#123;</span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton6() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 静态内部类</span><br><span class="line">    private static class InnerObject&#123;</span><br><span class="line">        private static Singleton6 single = new Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton6 getInstance() &#123;</span><br><span class="line">        return InnerObject.single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类虽然保证了单例在多线程并发下的线程安全性，<em>但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的</em>。这种情况不多做说明了，使用时请注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法</span><br><span class="line">缺点第一次加载时反应不够快</span><br></pre></td></tr></table></figure><h4 id="静态代码块实现"><a href="#静态代码块实现" class="headerlink" title="静态代码块实现"></a>静态代码块实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton6 &#123;</span><br><span class="line">    </span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton6() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static Singleton6 single = null;</span><br><span class="line"></span><br><span class="line">    // 静态代码块</span><br><span class="line">    static&#123;</span><br><span class="line">        single = new Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton6 getInstance() &#123;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="概念理论"><a href="#概念理论" class="headerlink" title="概念理论"></a>概念理论</h3><p>在设计模式中,也存在一个类似的模式，提供一个工厂，根据需要可以创建出各种不同类型的对象，该模式称之为简单工程模式。</p><p> <strong>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</strong></p><p> 简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> 简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</span><br><span class="line">适用场合</span><br><span class="line"></span><br><span class="line">1.在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式；</span><br><span class="line">2.由于对象的创建过程是我们不需要去关心的，而我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，如此，方便后期的程序扩展和维护。</span><br><span class="line">1.主要优点</span><br><span class="line">    简单工厂模式的主要优点如下：</span><br><span class="line"></span><br><span class="line">    (1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。也就是说工厂类封装了变化，封装了对象创建的具体细节，对客户端隐藏对象创建的细节，使得客户类针对接口进行编程。满足&quot;针对接口编程而不是针对具体编程原则&quot;。</span><br><span class="line"></span><br><span class="line">    (2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。满足&quot;迪米特法则，也就是和直接朋友通信原则&quot;。</span><br><span class="line"></span><br><span class="line">    (3) 具体对象创建是一个变化过程，因此把对象的创建封装起来，体现了&quot;封装变化原则&quot;。</span><br><span class="line"></span><br><span class="line">2.主要缺点</span><br><span class="line">       简单工厂模式的主要缺点如下：</span><br><span class="line"></span><br><span class="line">       (1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响，违背&quot;单一原则&quot;。</span><br><span class="line"></span><br><span class="line">       (2)使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</span><br><span class="line"></span><br><span class="line">       (3)系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。违背&quot;开发封闭原则&quot;。</span><br><span class="line"></span><br><span class="line">       (4)简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</span><br><span class="line"></span><br><span class="line">3.简单工程模式具体应用</span><br><span class="line">       (1)通常在使用word办公软件的时候，会根据需要绘制出饼状图，柱状图，折线图等图形。可以提供一个工厂类，根据用户的选择创建出不同类型的图形。</span><br><span class="line"></span><br><span class="line">    (2)QQ空间背景样式，博客背景样式等都提供了各种风格的样式。提供一个工厂，根据用户选择的具体风格样式，创建出各个不同的背景风格，用来装饰QQ空间。</span><br><span class="line"></span><br><span class="line">    (3)网页下载工具的开发: 根据需要可以下载新浪网页、腾讯网页、搜狐网页等。根据用户的选择，把网页类型传进工厂，将下载该类型的网页内容。</span><br><span class="line"></span><br><span class="line">    (4)淘宝购物最后一个支付环节，可以选择货到付款、网上银行、支付宝等类型支付。用户可以选择具体的支付方式完成订单,这也是简单工厂模式的一种应用。</span><br><span class="line"></span><br><span class="line">    (5)电影院打折算法: VIP5折、学生票5折、成人票正常收费等打折算法。</span><br><span class="line"></span><br><span class="line">    (6)多功能计算器的开发:封装加减乘除等运算操作(大话设计模式的例子)</span><br><span class="line"></span><br><span class="line">    (7)在很多游戏场合，游戏角色可以选择各种各样的武器，如:手枪、AK47、步枪、大刀等。</span><br><span class="line"></span><br><span class="line">    (8)如果电脑上装有QQ输入法、搜狗输入法、微软拼音输入法，用户可以设置使用哪种类型的输入法。类似的还可以设置IE浏览器、谷歌浏览器、火狐浏览器。可以设置word2003或者金山的WPS。这些都可以理解为简单工厂模式的一种运用。</span><br><span class="line"></span><br><span class="line">    (9)软件公司决策是否开发哪一种产品，银行卡识别、身份证识别还是驾驶证识别。</span><br><span class="line"></span><br><span class="line">    (10)生活中也有很多类似的工厂: 富士康代工工厂；安踏加工厂；咖啡生产基地；沃尔玛等超市提供各种产品供用户使用；肯德基马当劳等。</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> ProductTypeTag</span><br><span class="line">&#123;</span><br><span class="line">  TypeA,</span><br><span class="line">  TypeB,</span><br><span class="line">  TypeC</span><br><span class="line">&#125;PRODUCTTYPE;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> :</span> <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm ProductA"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> :</span> <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm ProductB"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductC</span> :</span> <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm ProductC"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">CreateProduct</span><span class="params">(PRODUCTTYPE type)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> TypeA:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> TypeB:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> TypeC:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProductC();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// First, create a factory object</span></span><br><span class="line">  Factory *ProductFactory = <span class="keyword">new</span> Factory();</span><br><span class="line">  Product *productObjA = ProductFactory-&gt;CreateProduct(TypeA);</span><br><span class="line">  <span class="keyword">if</span> (productObjA != <span class="literal">NULL</span>)</span><br><span class="line">    productObjA-&gt;Show();</span><br><span class="line">  </span><br><span class="line">  Product *productObjB = ProductFactory-&gt;CreateProduct(TypeB);</span><br><span class="line">  <span class="keyword">if</span> (productObjB != <span class="literal">NULL</span>)</span><br><span class="line">    productObjB-&gt;Show();</span><br><span class="line">  </span><br><span class="line">  Product *productObjC = ProductFactory-&gt;CreateProduct(TypeC);</span><br><span class="line">  <span class="keyword">if</span> (productObjC != <span class="literal">NULL</span>)</span><br><span class="line">    productObjC-&gt;Show();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> ProductFactory;</span><br><span class="line">  ProductFactory = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> productObjA;</span><br><span class="line">  productObjA = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> productObjB;</span><br><span class="line">  productObjB = <span class="literal">NULL</span>;    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> productObjC;</span><br><span class="line">  productObjC = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yoursite.com/2019/09/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2019/09/07/布隆过滤器/</id>
    <published>2019-09-07T01:57:00.000Z</published>
    <updated>2019-09-07T01:57:00.213Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20190904Code_record</title>
    <link href="http://yoursite.com/2019/09/05/20190904Code-record/"/>
    <id>http://yoursite.com/2019/09/05/20190904Code-record/</id>
    <published>2019-09-05T01:46:56.000Z</published>
    <updated>2019-09-05T04:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-最小盒数"><a href="#1-最小盒数" class="headerlink" title="1.最小盒数"></a>1.最小盒数</h2><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        res=i*<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(n==res+<span class="number">4</span>*j)&#123;</span><br><span class="line">                 <span class="built_in">cout</span>&lt;&lt;i+j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                 <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(res+<span class="number">4</span>*j&gt;n)&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Undefinedvalue=<span class="number">-1000</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;variable;</span><br><span class="line"><span class="built_in">string</span> finalstr=<span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vararry;</span><br><span class="line">    <span class="built_in">string</span> tmpstr=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'='</span>||str[i]==<span class="string">'+'</span>)&#123;</span><br><span class="line">            vararry.push_back(tmpstr);</span><br><span class="line">            tmpstr=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmpstr+=str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vararry.push_back(tmpstr);</span><br><span class="line">    <span class="built_in">string</span> pre=vararry[<span class="number">0</span>];</span><br><span class="line">    finalstr=pre;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vararry.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vararry[i][<span class="number">0</span>]&lt;=<span class="string">'9'</span>&amp;&amp;vararry[i][<span class="number">0</span>]&gt;=<span class="string">'0'</span>)&#123;</span><br><span class="line">            res+=<span class="built_in">std</span>::stoi(vararry[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(variable.find(vararry[i])!=variable.end()&amp;&amp;variable[vararry[i]]!=Undefinedvalue)&#123;</span><br><span class="line">                res+=variable[vararry[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                variable[pre]=Undefinedvalue;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    variable[pre]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,str);</span><br><span class="line">        solve(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(variable.find(finalstr)!=variable.end()&amp;&amp;variable[finalstr]!=Undefinedvalue)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;variable[finalstr]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NA"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxlen=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> mask[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> [] 一对失一个</span></span><br><span class="line"><span class="comment"> &#123;&#125; 一对失一个</span></span><br><span class="line"><span class="comment"> ""一对失一个</span></span><br><span class="line"><span class="comment"> ,少一个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">FilteroutSpace</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">   <span class="keyword">int</span> loc=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(str[i]!=<span class="string">' '</span>)&#123;</span><br><span class="line">          tmp+=str[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">string</span> totalstr=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> objmount=<span class="number">0</span>;  <span class="comment">//对象的1个数</span></span><br><span class="line">    <span class="keyword">int</span> linemount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> colonnumber=<span class="number">0</span>;  <span class="comment">//冒号个数</span></span><br><span class="line">    <span class="keyword">int</span>  Keyvalue_pair_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jsonArray=<span class="number">0</span>;<span class="comment">//有几个json数组</span></span><br><span class="line">    <span class="built_in">string</span>  strlist[maxlen];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,strlist[linemount]);</span><br><span class="line">        <span class="keyword">if</span>(strlist[linemount].length()==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        colonnumber+= count(strlist[linemount].begin(),strlist[linemount].end(),<span class="string">':'</span>);</span><br><span class="line">        totalstr+=strlist[linemount];</span><br><span class="line">        linemount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//solve    breaking point: 冒号不会失去</span></span><br><span class="line">    <span class="keyword">int</span> prearryflg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;linemount;i++)<span class="comment">//找出有几个对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        strlist[i]=FilteroutSpace(strlist[i]);<span class="comment">//去除可能有的空格干扰</span></span><br><span class="line">       <span class="keyword">if</span>(((<span class="keyword">int</span>)strlist[i].find(<span class="string">':'</span>))!=<span class="number">-1</span>&amp;&amp;(<span class="keyword">int</span>)strlist[i].find(<span class="string">':'</span>)&gt;=strlist[i].length()<span class="number">-2</span>)&#123;</span><br><span class="line">            objmount++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(((<span class="keyword">int</span>)strlist[i].find(<span class="string">':'</span>))!=<span class="number">-1</span>)<span class="comment">//键值对</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(prearryflg==<span class="number">0</span>)&#123;</span><br><span class="line">               jsonArray++;</span><br><span class="line">                   prearryflg=<span class="number">4</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                prearryflg=<span class="number">4</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           prearryflg=<span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Keyvalue_pair_num=colonnumber-objmount;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">']'</span>)!=objmount||count(totalstr.begin(),totalstr.end(),<span class="string">'['</span>)!=objmount) &#123;</span><br><span class="line">       mask[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">'"'</span>)!=Keyvalue_pair_num*<span class="number">4</span>+objmount*<span class="number">2</span>) &#123;</span><br><span class="line">       mask[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">'&#123;'</span>)!=jsonArray+<span class="number">1</span>||count(totalstr.begin(),totalstr.end(),<span class="string">'&#125;'</span>)!=jsonArray+<span class="number">1</span>) &#123;</span><br><span class="line">       mask[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">','</span>)!=Keyvalue_pair_num-objmount) &#123;</span><br><span class="line">       mask[<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-最小盒数&quot;&gt;&lt;a href=&quot;#1-最小盒数&quot; class=&quot;headerlink&quot; title=&quot;1.最小盒数&quot;&gt;&lt;/a&gt;1.最小盒数&lt;/h2&gt;&lt;h2 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>各大排序算法总结</title>
    <link href="http://yoursite.com/2019/09/04/%E5%90%84%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/09/04/各大排序算法总结/</id>
    <published>2019-09-04T06:19:32.000Z</published>
    <updated>2019-09-04T09:55:01.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(table[j<span class="number">-1</span>]&gt;table[j])</span><br><span class="line">          &#123;</span><br><span class="line">            swap(table[j<span class="number">-1</span>],table[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    insert_sort(table);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;table.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> tmploc=i;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;table.size();j++)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(table[tmploc]&gt;table[j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmploc=j;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       swap(table[i],table[tmploc]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Select_sort(table);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flg=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;table.size()<span class="number">-1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       flg=<span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;table.size()<span class="number">-1</span>-i;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(table[j]&gt;table[j+<span class="number">1</span>])</span><br><span class="line">           &#123;</span><br><span class="line">               swap(table[j],table[j+<span class="number">1</span>]);</span><br><span class="line">               flg=<span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(flg)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    bubble_sort(table);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.快速排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3.堆排序"></a>3.堆排序</h2><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在二叉树的第ｉ（ｉ&gt;=１）层最多有２i<span class="number">-1</span>个结点；</span><br><span class="line">&gt; 深度为k(k&gt;=<span class="number">0</span>)的二叉树最少有k个结点，最多有２k<span class="number">-1</span>个结点；</span><br><span class="line">&gt; 对于任一棵非空二叉树，若其叶结点数为n0，度为<span class="number">2</span>的非叶结点数为n2，则n0 = n2 ＋１；</span><br><span class="line">&gt; 具有n个结点的完全二叉树的深度为int_UP（<span class="built_in">log</span>(<span class="number">2</span>，ｎ+<span class="number">1</span>)）；</span><br><span class="line">&gt; 如果将一棵有n个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号１，２，３，．．．．．．，ｎ，然后按此结点编号将树中各结点顺序的存放于一个一维数组，并简称编号为i的结点为结点i（ｉ&gt;=１ &amp;&amp; ｉ&lt;=ｎ）,则有以下关系： </span><br><span class="line">&gt; （<span class="number">1</span>）若 ｉ= <span class="number">1</span>，则结点i为根，无父结点；若 ｉ&gt; <span class="number">1</span>，则结点 i的父结点为结点int_DOWN（ｉ / ２）; </span><br><span class="line">&gt; </span><br><span class="line">&gt; （<span class="number">2</span>）若 ２*ｉ &lt;= ｎ，则结点 ｉ 的左子女为结点 ２*ｉ； </span><br><span class="line">&gt; （<span class="number">3</span>）若２*ｉ＜＝ｎ，则结点ｉ的右子女为结点２*ｉ＋１； </span><br><span class="line">&gt; （<span class="number">4</span>）若结点编号ｉ为奇数，且ｉ！＝１，它处于右兄弟位置，则它的左兄弟为结点ｉ－１； </span><br><span class="line">&gt; （<span class="number">5</span>）若结点编号ｉ为偶数，且ｉ！＝ｎ，它处于左兄弟位置，则它的右兄弟为结点ｉ＋１； </span><br><span class="line">&gt; （<span class="number">6</span>）结点ｉ所在的层次为 int_DOWN（<span class="built_in">log</span>（<span class="number">2</span>，ｉ））＋１。 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table,<span class="keyword">int</span> loclen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loclen==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;table.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;table[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(loclen/<span class="number">2</span>)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        left=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=loclen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(table[left]&gt;table[i])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(table[left],table[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(table[left]&gt;table[i]&amp;&amp;table[left]&gt;table[right])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(table[left],table[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(table[right]&gt;table[i]&amp;&amp;table[right]&gt;table[left])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(table[right],table[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     swap(table[loclen<span class="number">-1</span>],table[<span class="number">0</span>]);</span><br><span class="line">    heapsort(table,loclen<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     heapsort(table,table.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若i从0开始索引，当前节点为i时，父节点（i/2）-1，左子节点：2*i+1,右子节点：2*i+2</span><br></pre></td></tr></table></figure><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [left,mid]  [mid+1,right]</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;leftpart;</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rightpart;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mid-left+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         leftpart.push_back(table[i+left]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-mid;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         rightpart.push_back(table[i+mid+<span class="number">1</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">int</span> leftloc=<span class="number">0</span>,rightloc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftloc&lt;leftpart.size()&amp;&amp;rightloc&lt;rightpart.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(leftpart[leftloc]&lt;rightpart[rightloc])</span><br><span class="line">        &#123;</span><br><span class="line">             table[left]=leftpart[leftloc++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table[left]=rightpart[rightloc++];</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(leftloc&lt;leftpart.size())</span><br><span class="line">    &#123;</span><br><span class="line">      table[left++]=leftpart[leftloc++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(rightloc&lt;rightpart.size())</span><br><span class="line">    &#123;</span><br><span class="line">       table[left++]=rightpart[rightloc++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">  merge_sort(table,left,mid);     <span class="comment">// [left,mid]</span></span><br><span class="line">  merge_sort(table,mid+<span class="number">1</span>,right);   <span class="comment">//[mid+1,right]</span></span><br><span class="line">  merge(table,left,mid,right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    merge_sort(table,<span class="number">0</span>,table.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分治法，分而合，合之前左右皆有序。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; title=&quot;1.插入排序&quot;&gt;&lt;/a&gt;1.插入排序&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理论易错点总结-LTS</title>
    <link href="http://yoursite.com/2019/09/01/%E7%90%86%E8%AE%BA%E6%98%93%E9%94%99%E7%82%B9%E6%80%BB%E7%BB%93-LTS/"/>
    <id>http://yoursite.com/2019/09/01/理论易错点总结-LTS/</id>
    <published>2019-09-01T08:36:55.000Z</published>
    <updated>2019-09-09T06:28:13.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-中-和-gt-的区别"><a href="#1-C-中-和-gt-的区别" class="headerlink" title="1 C++中.和-&gt;的区别"></a>1 C++中.和-&gt;的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">c++中当定义类对象是指针对象时候，就需要用到-&gt;指向类中的成员；当定义一般对象时候时就需要用到&quot;.&quot;指向类中的成员。</span><br><span class="line">A *p则使用：p-&gt;play(); 左边是结构指针。</span><br><span class="line"></span><br><span class="line">A p 则使用：p.paly(); 左边是结构变量。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">箭头（-&gt;）：左边必须为指针；</span><br><span class="line"></span><br><span class="line">点号（.）：左边必须为实体。</span><br><span class="line">-------------------------------------------------</span><br><span class="line">1、-&gt;是指针指向其成员的运算符。</span><br><span class="line"></span><br><span class="line"> . 是结构体的成员运算符。</span><br><span class="line"></span><br><span class="line">最大的区别是-&gt;前面放的是指针，而.前面跟的是结构体变量。</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">::是域作用符，是各种域性质的实体（比如类（不是对象）、名字空间等）调用其成员专用的。</span><br><span class="line">（如果有个局部变量与全局变量同名（假设都是int a;），默认调用的 a 是局部变量，如果要访问全局变量a，就要这么写“::a”。使用域作用符来加以区别；前面没写具体的域名，就是指默认域）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.是成员作用符，是对象专用的。</span><br></pre></td></tr></table></figure><h2 id="2-this指针"><a href="#2-this指针" class="headerlink" title="2 this指针"></a>2 this指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1. this指针的用处:</span><br><span class="line"></span><br><span class="line">　　一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。　　例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 .</span><br><span class="line"></span><br><span class="line">2. this指针的使用:</span><br><span class="line"></span><br><span class="line">一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n）。</span><br><span class="line"></span><br><span class="line">3. this指针程序示例:</span><br><span class="line"></span><br><span class="line">this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址。</span><br><span class="line"></span><br><span class="line">5. 类的this指针有以下特点：</span><br><span class="line"></span><br><span class="line">（1）this只能在成员函数中使用。</span><br><span class="line"></span><br><span class="line">全局函数、静态函数都不能使用this.</span><br><span class="line"></span><br><span class="line">实际上，成员函数默认第一个参数为T * const this。 </span><br><span class="line"></span><br><span class="line">其中，func的原型在编译器看来应该是：</span><br><span class="line"></span><br><span class="line">  int func(A * const this,int p);</span><br><span class="line"></span><br><span class="line">（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。</span><br><span class="line"></span><br><span class="line">这个生命周期同任何一个函数的参数是一样的，没有任何区别。</span><br><span class="line"></span><br><span class="line">当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">a.func(10);</span><br><span class="line"></span><br><span class="line">此处，编译器将会编译成：</span><br><span class="line"></span><br><span class="line">A::func(&amp;a,10);</span><br><span class="line"></span><br><span class="line">看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高--如VC通常是通过ecx寄存器传递this参数的。</span><br><span class="line"></span><br><span class="line">（3）几个this指针的易混问题。</span><br><span class="line"></span><br><span class="line">A. this指针是什么时候创建的？</span><br><span class="line"></span><br><span class="line">this在成员函数的开始执行前构造，在成员的执行结束后清除。</span><br><span class="line"></span><br><span class="line">但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用 TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答。</span><br><span class="line"></span><br><span class="line">B. this指针存放在何处？堆、栈、全局变量，还是其他？</span><br><span class="line"></span><br><span class="line">this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</span><br><span class="line"></span><br><span class="line">C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</span><br><span class="line"></span><br><span class="line">大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</span><br><span class="line"></span><br><span class="line">在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</span><br><span class="line"></span><br><span class="line">D. this指针是如何访问类中的变量的？</span><br><span class="line"></span><br><span class="line">如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。 </span><br><span class="line">在C++中 ,类和结构是只有一个区别的：类的成员默认是private，而结构是public。</span><br><span class="line"></span><br><span class="line">this是类的指针，如果换成结构，那this就是结构的指针了。</span><br><span class="line"> </span><br><span class="line">E. 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</span><br><span class="line"></span><br><span class="line">this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</span><br><span class="line"></span><br><span class="line">F. 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</span><br><span class="line"></span><br><span class="line">普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</span><br></pre></td></tr></table></figure><h2 id="3-C-函数定义和调用过程"><a href="#3-C-函数定义和调用过程" class="headerlink" title="3.C++函数定义和调用过程"></a>3.C++函数定义和调用过程</h2><h2 id="4-C-数组大小"><a href="#4-C-数组大小" class="headerlink" title="4  C++数组大小"></a>4  C++数组大小</h2><ul><li><strong>函数内申请的变量，数组，是在栈（stack）中申请的一段连续的空间。栈的默认大小为2M或1M，开的比较小。</strong></li><li><strong>全局变量，全局数组，静态数组（static）则是开在全局区（静态区）（static）。大小为2G，所以能够开的很大。</strong></li><li><strong>而malloc、new出的空间，则是开在堆（heap）的一段不连续的空间。理论上则是硬盘大小。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">20000</span>][<span class="number">20000</span>]; <span class="comment">//全局数组能开到20000*20000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">100</span>][<span class="number">100</span>]; <span class="comment">// 函数中二维数组最大能开100*100</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">4</span>*<span class="number">518028</span>]; <span class="comment">// 函数中的char数组最大能开4*518028</span></span><br><span class="line">    <span class="keyword">int</span> b1[<span class="number">500000</span>]; <span class="comment">// int最大能开到518028。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[<span class="number">20000</span>][<span class="number">20000</span>]; <span class="comment">//static能开到10^7*10^7，注意 static和 全局开的是同一块空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-默认值"><a href="#5-默认值" class="headerlink" title="5.默认值"></a>5.默认值</h2><p>对全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在GCC编译器下各个类型的全局变量的默认值：</span><br><span class="line"></span><br><span class="line"> 表示数字的变量类型默认值都为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">bool</span>型默认值为<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">string</span>型默认值为空字符串</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> 型比较特殊。<span class="keyword">char</span>类型默认值为<span class="string">'\0'</span>， 即字符串结束标志，其整数值为<span class="number">0</span>。如果用<span class="built_in">printf</span>(<span class="string">"%d"</span>)输出时值为 <span class="number">0</span>， 但用<span class="built_in">printf</span>(<span class="string">"%c"</span>),或<span class="built_in">cout</span> 输出时显示为<span class="string">"a"</span>， <span class="keyword">char</span>型数组默认值为空字符串，其中的每个元素与单个<span class="keyword">char</span>类型相同，所以用<span class="built_in">puts</span>() 和<span class="built_in">printf</span>(<span class="string">"%s"</span>) 输出都是空字符串。</span><br></pre></td></tr></table></figure><p>static的默认初始化为0.和全局变量一致，因为全局变量也存储在静态数据区。</p><h2 id="6-Vector-赋值"><a href="#6-Vector-赋值" class="headerlink" title="6 Vector 赋值"></a>6 Vector 赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>的几种初始化及赋值方式：</span><br><span class="line">（<span class="number">1</span>）不带参数的构造函数初始化</span><br><span class="line"><span class="comment">//初始化一个size为0的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc;</span><br><span class="line">（<span class="number">2</span>）带参数的构造函数初始化</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc(<span class="number">10</span>);    <span class="comment">//初始化了10个默认值为0的元素</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cde(<span class="number">10</span>，<span class="number">1</span>);    <span class="comment">//初始化了10个值为1的元素</span></span><br><span class="line">（<span class="number">3</span>）通过数组地址初始化</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a, a+<span class="number">5</span>);</span><br><span class="line">（<span class="number">4</span>）通过同类型的<span class="built_in">vector</span>初始化</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//通过a初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a);</span><br><span class="line">（<span class="number">5</span>）通过insert初始化</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">vecot&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a[0]~a[2]插入到b中，b.size()由0变为3</span></span><br><span class="line">b.insert(b.begin(), a.begin(), a.begin() + <span class="number">3</span>);</span><br><span class="line">insert也可通过数组地址区间实现插入</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a的所有元素插入到b中</span></span><br><span class="line">b.insert(b.begin(), a, a+<span class="number">7</span>);</span><br><span class="line">此外，insert还可以插入m个值为n的元素</span><br><span class="line"></span><br><span class="line"><span class="comment">//在b开始位置处插入6个6</span></span><br><span class="line">b.insert(b.begin(), <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">（<span class="number">6</span>）通过copy函数赋值</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">5</span>] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间*/</span></span><br><span class="line">copy(a.begin(), a.end(), b.begin());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//拷贝区间也可以是数组地址构成的区间</span></span><br><span class="line">copy(a1, a1+<span class="number">5</span>, b.begin() + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-C-中-和-gt-的区别&quot;&gt;&lt;a href=&quot;#1-C-中-和-gt-的区别&quot; class=&quot;headerlink&quot; title=&quot;1 C++中.和-&amp;gt;的区别&quot;&gt;&lt;/a&gt;1 C++中.和-&amp;gt;的区别&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux相关操作</title>
    <link href="http://yoursite.com/2019/08/31/Linux%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/08/31/Linux相关操作/</id>
    <published>2019-08-31T13:44:48.000Z</published>
    <updated>2019-08-31T13:47:45.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下还是有很多超棒的开发工具的。</p></blockquote><p>在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C/C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。</p><p>开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I/O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>开发及调试<ul><li>编辑器：vim</li><li>编译器：gcc/g++</li><li>调试工具：gdb</li><li>查看依赖库：ldd</li><li>二进制文件分析：objdump</li><li>ELF文件格式分析：readelf</li><li>跟踪进程中系统调用：strace</li><li>跟踪进程栈：pstack</li><li>进程内存映射：pmap</li></ul></li><li>文件处理<ul><li>文件查找：find</li><li>文本搜索：grep</li><li>排序：sort</li><li>转换：tr</li><li>按列切分文本：cut</li><li>按列拼接文本：paste</li><li>统计行和字符：wc</li><li>文本替换：sed</li><li>数据流处理：awk</li></ul></li><li>性能分析<ul><li>进程查询：ps</li><li>进程监控：top</li><li>打开文件查询：lsof</li><li>内存使用量：free</li><li>监控性能指标：sar</li></ul></li><li>网络工具<ul><li>网卡配置：ifconfig</li><li>查看当前网络连接：netstat</li><li>查看路由表：route</li><li>检查网络连通性：ping</li><li>转发路径：traceroute</li><li>网络Debug分析：nc</li><li>命令行抓包：tcpdump</li><li>域名解析工具：dig</li><li>网络请求：curl</li></ul></li><li>其他<ul><li>终止进程：kill</li><li>修改文件权限：chmod</li><li>创建链接：ln</li><li>显示文件尾：tail</li><li>版本控制：git</li><li>设置别名：alias</li></ul></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="开发及调试"><a href="#开发及调试" class="headerlink" title="开发及调试"></a>开发及调试</h3><blockquote><p>开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。</p></blockquote><ol><li><p>编辑器：vim</p><ul><li>服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。</li><li><a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>编译器：gcc/g++</p><ul><li>C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。</li><li><a href="http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>调试工具：gdb</p><ul><li>服务器端调试必备。</li><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>查看依赖库：ldd</p><ul><li>程序依赖库查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ldd后接可执行文件</span><br><span class="line"># 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址</span><br><span class="line"># 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置</span><br><span class="line"></span><br><span class="line">ldd a.out</span><br></pre></td></tr></table></figure></li><li><p>二进制文件分析：objdump</p><ul><li>反汇编，需要理解汇编语言</li><li><a href="http://man.linuxde.net/objdump" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>ELF文件格式分析：readelf</p><ul><li>可以得到ELF文件各段内容，分析链接、符号表等需要用到</li><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>跟踪进程中系统调用：strace</p><ul><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>跟踪进程栈：pstack</p><ul><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>进程内存映射：pmap</p><ul><li>显示进程内存映射</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -x显示扩展信息，后接进程pid</span><br><span class="line"># Address: 内存开始地址</span><br><span class="line"># 显示信息：</span><br><span class="line">    Kbytes: 占用内存的字节数</span><br><span class="line">    RSS: 保留内存的字节数</span><br><span class="line">    Dirty: 脏页的字节数（包括共享和私有的）</span><br><span class="line">    Mode: 内存的权限：read、write、execute、shared、private</span><br><span class="line">    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）</span><br><span class="line">    Device: 设备名 (major:minor)</span><br><span class="line"></span><br><span class="line">pmap -x 12345</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><blockquote><p>Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。</p></blockquote><ol><li><p>文件查找：find</p><p>按名查找：</p><ul><li>查找具体文件（一般方式）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name *.cpp</span><br></pre></td></tr></table></figure><ul><li>查找具体文件（正则方式）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -regex为正则查找，-iregex为忽略大小写的正则查找 </span><br><span class="line"></span><br><span class="line">find -regex &quot;.*.cpp$&quot;</span><br></pre></td></tr></table></figure><p>定制查找：</p><ul><li>按类型查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># f(file)为文件，d(dictionary)为目录，l(link)为链接</span><br><span class="line"></span><br><span class="line">find . -type f</span><br></pre></td></tr></table></figure><ul><li>按时间查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># atime为访问时间，x天内加参数&quot;-atime -x&quot;，超过x天加&quot;-atime -x&quot;</span><br><span class="line"># mtime为修改时间</span><br><span class="line"></span><br><span class="line">find . -type f -atime -7</span><br></pre></td></tr></table></figure><ul><li>按大小查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)</span><br><span class="line"></span><br><span class="line">find . -type f -size -1k</span><br></pre></td></tr></table></figure><ul><li>按权限查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -perm后接权限</span><br><span class="line"></span><br><span class="line">find . -type -perm 644</span><br></pre></td></tr></table></figure></li><li><p>文本搜索：grep</p><ul><li>模式匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 匹配test.cpp文件中含有&quot;iostream&quot;串的内容</span><br><span class="line"></span><br><span class="line">grep &quot;iostream&quot; test.cpp</span><br></pre></td></tr></table></figure><ul><li>多个模式匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 匹配test.cpp文件中含有&quot;iostream&quot;和&quot;using&quot;串的内容</span><br><span class="line"></span><br><span class="line">grep -e &quot;using&quot; -e &quot;iostream&quot; test.cpp</span><br></pre></td></tr></table></figure><ul><li>输出信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br><span class="line"></span><br><span class="line">grep -n &quot;iostream&quot; test.cpp</span><br></pre></td></tr></table></figure></li><li><p>排序：sort</p><ul><li>文件内容行排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 排序在内存进行，不改变文件</span><br><span class="line"># -n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="line"># -k N表示按各行第N列进行排序</span><br><span class="line"># -r(reverse)为逆序排序</span><br><span class="line"></span><br><span class="line">sort -n -k 1 test</span><br></pre></td></tr></table></figure></li><li><p>转换：tr</p><ul><li>字符替换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 转换在内存进行，不改变文件</span><br><span class="line"># 将打开文件中所有目标字符替换</span><br><span class="line"></span><br><span class="line">cat test | tr &apos;1&apos; &apos;2&apos;</span><br></pre></td></tr></table></figure><ul><li>字符删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 转换在内存进行，不改变文件</span><br><span class="line"># -d删除(delete)</span><br><span class="line"></span><br><span class="line">cat test | tr -d &apos;1&apos;</span><br></pre></td></tr></table></figure><ul><li>字符压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 转换在内存进行，不改变文件</span><br><span class="line"># -s位于后部</span><br><span class="line"></span><br><span class="line">cat test | tr &apos; &apos; -s</span><br></pre></td></tr></table></figure></li><li><p>按列切分文本：cut</p><ul><li>截取特定列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 截取的内存进行，不改变文件</span><br><span class="line"># -b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="line"># 数字为具体列范围</span><br><span class="line"></span><br><span class="line">cut -f 1,2 test</span><br></pre></td></tr></table></figure><ul><li>指定界定符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 截取的内存进行，不改变文件</span><br><span class="line"># -d后接界定符</span><br><span class="line"></span><br><span class="line">cut -f 2 -d &apos;,&apos; new</span><br></pre></td></tr></table></figure></li><li><p>按列拼接文本：paste</p><ul><li>按列拼接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在内存中拼接，不改变文件</span><br><span class="line"># 将两个文件按对应列拼接</span><br><span class="line"># 最后加上-d &quot;x&quot;会将x作为指定分隔符（paste test1 test2 -d &quot;,&quot;）</span><br><span class="line"># 两文件列数可以不同 </span><br><span class="line"></span><br><span class="line">paste test1 test2</span><br></pre></td></tr></table></figure><ul><li>指定界定符拼接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在内存中拼接，不改变文件</span><br><span class="line"># 按照-d之后给出的界定符拼接</span><br><span class="line"></span><br><span class="line">paste test1 test2 -d &quot;,&quot;</span><br></pre></td></tr></table></figure></li><li><p>统计行和字符：wc</p><ul><li>基本统计</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><span class="line"></span><br><span class="line">wc -l test</span><br></pre></td></tr></table></figure></li><li><p>文本替换：sed</p><ul><li>区别于上面的命令，sed是可以直接改变被编辑文件内容的。</li><li><a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>数据流处理：awk</p><ul><li>区别于上面的命令，awk是可以直接改变被编辑文件内容的。</li><li><a href="http://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">详见</a></li></ul></li></ol><hr><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><blockquote><p>性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I/O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。</p></blockquote><ol><li><p>进程查询：ps</p><ul><li>查看正在运行进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 常结合grep筛选信息(e.g, ps -ef | grep xxx)</span><br><span class="line"></span><br><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li>以完整格式显示所有进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 常结合grep筛选信息</span><br><span class="line"></span><br><span class="line">ps -ajx</span><br></pre></td></tr></table></figure></li><li><p>进程监控：top</p><ul><li>显示实时进程信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是个大招，都不带参数的，具体信息通过grep筛选</span><br><span class="line"># 交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列</span><br><span class="line"># %id表示CPU空闲率，过低表示可能存在CPU存在瓶颈</span><br><span class="line"># %wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析</span><br><span class="line"></span><br><span class="line">top</span><br></pre></td></tr></table></figure></li><li><p>打开文件查询：lsof</p><ul><li>查看占用某端口的进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 最常见的就是mysql端口被占用使用(lsof i:3307)</span><br><span class="line"># 周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)</span><br><span class="line"></span><br><span class="line">lsof -i:53</span><br></pre></td></tr></table></figure><ul><li>查看某用户打开的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -u(user)为用户，后接用户名</span><br><span class="line"></span><br><span class="line">lsof -u inx</span><br></pre></td></tr></table></figure><ul><li>查看指定进程打开的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -p(process)为进程，后接进程PID</span><br><span class="line"></span><br><span class="line">lsof -p 12345</span><br></pre></td></tr></table></figure><ul><li>查看指定目录下被进程打开的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里是&quot;+d&quot;，需要注意，使用&quot;+D&quot;递归目录</span><br><span class="line"></span><br><span class="line">lsof +d /test</span><br></pre></td></tr></table></figure></li><li><p>内存使用量：free</p><ul><li>内存使用量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 可获得内存及交换区的总量，已使用量，空闲量等信息</span><br><span class="line"></span><br><span class="line">free</span><br></pre></td></tr></table></figure></li><li><p>监控性能指标：sar</p><p>监控CPU</p><ul><li>监控CPU负载</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="line"># 这里&quot;1&quot;表示采样时间间隔是1秒，这里&quot;2&quot;表示采样次数为2</span><br><span class="line"></span><br><span class="line">sar -q 1 2</span><br></pre></td></tr></table></figure><ul><li>监控CPU使用率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以显示CPU使用情况</span><br><span class="line"># 参数意义同上</span><br><span class="line"></span><br><span class="line">sar -u 1 2</span><br></pre></td></tr></table></figure><p>监控内存</p><ul><li>查询内存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以显示内存使用情况</span><br><span class="line"># 参数意义同上 </span><br><span class="line"></span><br><span class="line">sar -r 1 2</span><br></pre></td></tr></table></figure><ul><li>页面交换查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br><span class="line"># 参数意义同上</span><br><span class="line"></span><br><span class="line">sar -W 1 2</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h3><blockquote><p>网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。</p></blockquote><ol><li><p>网卡配置（链路层）：ifconfig</p><ul><li>显示设备信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 可以显示已激活的网络设备信息</span><br><span class="line"></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li>启动关闭指定网卡</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 前一个参数为具体网卡，后一个为开关信息</span><br><span class="line"># up为打开，down为关闭</span><br><span class="line"></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><ul><li>配置IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 前一个参数为具体网卡，后一个为配置的IP地址</span><br><span class="line"></span><br><span class="line">ifconfig eth0 192.168.1.1</span><br></pre></td></tr></table></figure><ul><li>设置最大传输单元</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前一个参数为具体网卡，后面为MTU的大小</span><br><span class="line"># 设置链路层MTU值，通常为1500</span><br><span class="line"></span><br><span class="line">ifconfig eth0 mtu 1500</span><br></pre></td></tr></table></figure><ul><li>启用和关闭ARP协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开启arp如下，若关闭则-arp</span><br><span class="line"></span><br><span class="line">ifconfig eth0 arp</span><br></pre></td></tr></table></figure></li><li><p>查看当前网络连接（链路层/网络层/传输层）：netstat</p><ul><li>网络接口信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 显示网卡信息，可结合ifconfig学习</span><br><span class="line"></span><br><span class="line">netstat -i</span><br></pre></td></tr></table></figure><ul><li>列出端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口</span><br><span class="line"># -l(listening)表示正在监听的端口</span><br><span class="line"></span><br><span class="line">netstat -at</span><br></pre></td></tr></table></figure><ul><li>显示端口统计信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -s(status)显示各协议信息</span><br><span class="line"># -加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息</span><br><span class="line"></span><br><span class="line">netstat -s</span><br></pre></td></tr></table></figure><ul><li>显示使用某协议的应用名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><span class="line"></span><br><span class="line">netstat -pt</span><br></pre></td></tr></table></figure><ul><li>查找指定进程、端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="line"># 第二个操作可以用lsof替代</span><br><span class="line"></span><br><span class="line">netstat -ap | grep ssh</span><br><span class="line">netstat -an | grep &apos;:80&apos;</span><br></pre></td></tr></table></figure></li><li><p>查看路由表（网络层IP协议）：route</p><ul><li>查看路由信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 得到路由表信息，具体分析路由表工作需要网络知识</span><br><span class="line"># 可以通过netstat -r(route)得到同样的路由表</span><br><span class="line"></span><br><span class="line">route</span><br></pre></td></tr></table></figure></li><li><p>检查网络连通性（网络层ICMP协议）：ping</p><ul><li>检查是否连通</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 主要功能是检测网络连通性</span><br><span class="line"># 可以额外得到网站的ip地址和连接最大/最小/平均耗时。</span><br><span class="line"></span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure></li><li><p>转发路径（网络层ICMP协议）：traceroute</p><ul><li>文件包途径的IP</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"># 可以打印从沿途经过的路由器IP地址</span><br><span class="line"></span><br><span class="line">traceroute baidu.com</span><br></pre></td></tr></table></figure></li><li><p>网络Debug分析（网络层/传输层）：nc</p><ul><li>端口扫描</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 黑客很喜欢</span><br><span class="line"># 扫描某服务器端口使用情况</span><br><span class="line"># -v(view)显示指令执行过程，-w(wait)设置超时时长</span><br><span class="line"># -z使用输入输出模式（只在端口扫描时使用）</span><br><span class="line"># 数字为扫描的端口范围 </span><br><span class="line"></span><br><span class="line">nc -v -w 1 baidu.com  -z 75-1000</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.oschina.net/translate/linux-netcat-command" target="_blank" rel="noopener">其他详见</a></li></ul></li><li><p>命令行抓包（网络层/传输层）：tcpdump</p><ul><li>抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。</li><li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>域名解析工具（应用层DNS协议）：dig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 应用层，DNS</span><br><span class="line"># 打印域名解析结果</span><br><span class="line"># 打印域名解析过程中涉及的各级DNS服务器地址</span><br><span class="line"></span><br><span class="line">dig baidu.com</span><br></pre></td></tr></table></figure></li><li><p>网络请求（应用层）：curl</p><ul><li><a href="http://www.cnblogs.com/gbyukg/p/3326825.html" target="_blank" rel="noopener">详见</a></li></ul></li></ol><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote><p>这里都是日常开发中高频命令。</p></blockquote><ol><li><p>终止进程：kill</p><ul><li>杀死具体进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 加具体进程PID</span><br><span class="line"></span><br><span class="line">kill 12345</span><br></pre></td></tr></table></figure><ul><li>杀死某进程相关进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 加上&quot;-9&quot;杀死某进程相关进程</span><br><span class="line"></span><br><span class="line">kill -9 12345</span><br></pre></td></tr></table></figure></li><li><p>修改文件权限：chmod</p><ul><li>更改文件权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="line"># 文件可以有三种权限，r(read)，w(write)，x(execute)</span><br><span class="line"># 这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="line"># 这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br><span class="line"></span><br><span class="line">chmod u+r file</span><br><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure></li><li><p>创建链接：ln</p><ul><li>创建硬链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><span class="line"></span><br><span class="line">ln file1 file2</span><br></pre></td></tr></table></figure><ul><li>创建软（符号链接）链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -s(symbol)为符号链接，仅仅是引用路径</span><br><span class="line"># 相比于硬链接最大特点是可以跨文件系统</span><br><span class="line"># 类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><span class="line"></span><br><span class="line">ln -s file1 file2</span><br></pre></td></tr></table></figure></li><li><p>显示文件尾：tail</p><ul><li>查看文件尾部</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="line"># 查看日志时常用</span><br><span class="line"></span><br><span class="line">tail -f test</span><br></pre></td></tr></table></figure></li><li><p>版本控制：git</p><ul><li>版本控制最好用的软件，没有之一。至少要知道”git init”，”git add”，”git commit”，”git pull”，”git push”几个命令。</li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>设置别名：alias</p><ul><li>常用命令添加别名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># &quot;.bashrc&quot;文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令</span><br><span class="line"></span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。</p><p>先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。<a href="https://github.com/linw7/TKeed" target="_blank" rel="noopener">代码</a></p><ol><li>单步调试：gdb</li></ol><ul><li>运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。</li></ul><ol><li>动态库依赖：ldd</li></ol><ul><li>命令：ldd ./server</li><li>可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。</li></ul><ol><li>性能分析：top</li></ol><ul><li>top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。</li></ul><ol><li>系统调用：strace</li></ol><ul><li>命令：strace ./server</li><li>上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。</li></ul><ol><li>打印进程：ps</li></ol><ul><li>命令：ps -ejH</li><li>我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。</li></ul><ol><li>打开文件：lsof</li></ol><ul><li>lsof -i:3000</li><li>比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。</li></ul><ol><li>修改权限：chmod</li></ol><ul><li>chmod 000 ./index.html</li><li>可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000/index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。</li></ul><ol><li>网卡信息：ifconfig</li></ol><ul><li>ifconfig</li><li>如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。</li></ul><ol><li>抓包分析：tcpdump</li></ol><ul><li>tcpdump -i eth0 port 3000</li><li>可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux下还是有很多超棒的开发工具的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C/C++开发者至
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2019/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/08/31/计算机网络/</id>
    <published>2019-08-31T13:43:19.000Z</published>
    <updated>2019-08-31T13:43:35.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="网络层-IP"><a href="#网络层-IP" class="headerlink" title="网络层(IP)"></a>网络层(IP)</h3><blockquote><p>待补充</p></blockquote><hr><h3 id="传输层-TCP-UDP"><a href="#传输层-TCP-UDP" class="headerlink" title="传输层(TCP/UDP)"></a>传输层(TCP/UDP)</h3><ol><li><p>ISO七层模型中表示层和会话层功能是什么？</p><ul><li>表示层：图像、视频编码解，数据加密。</li><li>会话层：建立会话，如session认证、断点续传。</li></ul></li><li><p>描述TCP头部？</p><ul><li>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。</li><li>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。</li><li>首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。</li><li>标志位（6bit）：<ul><li>URG：标志紧急指针是否有效。</li><li>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li><li>PSH：提示接收端立即从缓冲读走数据。</li><li>RST：表示要求对方重新建立连接（复位报文段）。</li><li>SYN：表示请求建立一个连接（连接报文段）。</li><li>FIN：表示关闭连接（断开报文段）。</li></ul></li><li>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</li><li>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</li></ul></li><li><p>三次握手过程？</p><ul><li>第一次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&gt; SYN_SEND）</li><li>第二次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -&gt; SYN_RECV）</li><li>第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&gt; ESTABLISH，服 -&gt; ESTABLISH）</li></ul></li><li><p>四次挥手过程？</p><ul><li>第一次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&gt; FIN_WAIT_1）</li><li>第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&gt; CLOSE_WAIT，客 -&gt; FIN_WAIT_2）<ul><li>此处有等待</li></ul></li><li>第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&gt; LAST_ACK，客 -&gt; TIME_WAIT）<ul><li>此处有等待</li></ul></li><li>第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -&gt; CLOSED）</li></ul></li><li><p>为什么握手是三次，挥手是四次？</p><ul><li>对于握手：握手只需要确认双方通信时的初始化序号，保证通信不会乱序。（第三次握手必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同一个客户机保持多个连接，造成资源浪费。）</li><li>对于挥手：TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。</li></ul></li><li><p>TCP连接状态？</p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li><li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li><li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li><li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li><li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li><li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li></ul></li><li><p>解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？</p><ul><li>FIN_WAIT_2：<ul><li>半关闭状态。</li><li>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li></ul></li><li>CLOSE_WAIT状态：<ul><li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li><li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。</li></ul></li><li>TIME_WAIT状态：<ul><li>又叫2MSL等待状态。</li><li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li><li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li></ul></li></ul></li><li><p>解释RTO，RTT和超时重传？</p><ul><li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul><li>发送的数据没能到达接收端，所以对方没有响应。</li><li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li><li>接收端拒绝或丢弃数据。</li></ul></li><li>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。<ul><li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li><li>重传次数到达上限之后停止重传。</li></ul></li><li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li></ul></li><li><p>流量控制原理？</p><ul><li>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li><li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。<ul><li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li><li>接收窗：用来标记可以接收的数据大小。</li></ul></li><li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</li><li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li></ul></li><li><p>拥塞控制原理？</p><ul><li>拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</li><li>TCP拥塞控制算法：<ul><li>慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。</li><li>快速重传 &amp; 快速恢复：略。</li><li>最终拥塞窗口会收敛于稳定值。</li></ul></li></ul></li><li><p>如何区分流量控制和拥塞控制？</p><ul><li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li><li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li></ul></li><li><p>TCP如何提供可靠数据传输的？</p><ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul></li><li><p>TCP soctet交互流程？</p><ul><li><p>服务器：</p><ul><li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p><ul><li>domain：协议域，决定了socket的地址类型，IPv4为AF_INET。</li><li>type：指定socket类型，SOCK_STREAM为TCP连接。</li><li>protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。</li></ul></li><li><p>绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><ul><li>sockfd：socket返回的套接字描述符，类似于文件描述符fd。</li><li>addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IPv4的sockaddr地址结构</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family;    // 协议类型，AF_INET</span><br><span class="line">    in_port_t sin_port;    // 端口号</span><br><span class="line">    struct in_addr sin_addr;    // IP地址</span><br><span class="line">&#125;;</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addrlen：地址长度。</li></ul></li><li><p>监听端口号 -&gt; int listen(int sockfd, int backlog);</p><ul><li>sockfd：要监听的sock描述字。</li><li>backlog：socket可以排队的最大连接数。</li></ul></li><li><p>接收用户请求 -&gt; int accept(int sockfd, struct sockaddr <em>addr, socklen_t </em>addrlen);</p><ul><li>sockfd：服务器socket描述字。</li><li>addr：指向地址结构指针。</li><li>addrlen：协议地址长度。</li><li>注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。</li></ul></li><li><p>从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);</p><ul><li>fd：连接描述字。</li><li>buf：缓冲区buf。</li><li>count：缓冲区长度。</li><li>注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。</li></ul></li><li><p>关闭socket -&gt; int close(int fd);</p><ul><li>fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。</li><li>注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。</li></ul></li></ul></li><li><p>客户机：</p><ul><li>创建socket -&gt; int socket(int domain, int type, int protocol);</li><li>连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);<ul><li>sockfd客户端的sock描述字。</li><li>addr：服务器的地址。</li><li>addrlen：socket地址长度。</li></ul></li><li>向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);<ul><li>fd、buf、count：同read中意义。</li><li>大于0表示写了部分或全部数据，小于0表示出错。</li></ul></li><li>关闭oscket -&gt; int close(int fd);<ul><li>fd：同服务器端fd。</li></ul></li></ul></li></ul></li></ol><hr><h3 id="应用层-HTTP"><a href="#应用层-HTTP" class="headerlink" title="应用层(HTTP)"></a>应用层(HTTP)</h3><p>HTTP协议工作在应用层，端口号是80。HTTP协议被用于网络中两台计算机间的通信，相比于TCP/IP这些底层协议，HTTP协议更像是高层标记型语言，浏览器根据从服务器得到的HTTP响应体中分别得到报文头，响应头和信息体（HTML正文等），之后将HTML文件解析并呈现在浏览器上。同样，我们在浏览器地址栏输入网址之后，浏览器相当于用户代理帮助我们组织好报文头，请求头和信息体（可选），之后通过网络发送到服务器，，服务器根据请求的内容准备数据。所以如果想要完全弄明白HTTP协议，你需要写一个浏览器 + 一个Web服务器，一侧来生成请求信息，一侧生成响应信息。</p><p>从网络分层模型来看，HTTP工作在应用层，其在传输层由TCP协议为其提供服务。所以可以猜到，HTTP请求前，客户机和服务器之间一定已经通过三次握手建立起连接，其中套接字中服务器一侧的端口号为HTTP周知端口80。在请求和传输数据时也是有讲究的，通常一个页面上不只有文本数据，有时会内嵌很多图片，这时候有两种选择可以考虑。一种是对每一个文件都建立一个TCP连接，传送完数据后立马断开，通过多次这样的操作获取引用的所有数据，但是这样一个页面的打开需要建立多次连接，效率会低很多。另一种是对于有多个资源的页面，传送完一个数据后不立即断开连接，在同一次连接下多次传输数据直至传完，但这种情况有可能会长时间占用服务器资源，降低吞吐率。上述两种模式分别是HTTP 1.0和HTTP 1.1版本的默认方式，具体是什么含义会在后面详细解释。</p><p><strong>HTTP工作流程</strong></p><p>一次完整的HTTP请求事务包含以下四个环节：</p><ul><li>建立起客户机和服务器连接。</li><li>建立连接后，客户机发送一个请求给服务器。</li><li>服务器收到请求给予响应信息。</li><li>客户端浏览器将返回的内容解析并呈现，断开连接。</li></ul><p><strong>HTTP协议结构</strong></p><p>请求报文</p><p>对于HTTP请求报文我们可以通过以下两种方式比较直观的看到：一是在浏览器调试模式下（F12）看请求响应信息，二是通过wireshark或者tcpdump抓包实现。通过前者看到的数据更加清晰直观，通过后者抓到的数据更真实。但无论是用哪种方式查看，得到的请求报文主题体信息都是相同的，对于请求报文，主要包含以下四个部分，每一行数据必须通过”\r\n”分割，这里可以理解为行末标识符。</p><ul><li><p>报文头（只有一行）</p><p>结构：method uri version</p><ul><li><p>method</p><p>HTTP的请求方法，一共有9中，但GET和POST占了99%以上的使用频次。GET表示向特定资源发起请求，当然也能提交部分数据，不过提交的数据以明文方式出现在URL中。POST通常用于向指定资源提交数据进行处理，提交的数据被包含在请求体中，相对而言比较安全些。</p></li><li><p>uri</p><p>用来指代请求的文件，≠URL。</p></li><li><p>version</p><p>HTTP协议的版本，该字段有HTTP/1.0和HTTP/1.1两种。</p></li></ul></li><li><p>请求头（多行）</p><p>在HTTP/1.1中，请求头除了Host都是可选的。包含的头五花八门，这里只介绍部分。</p><ul><li>Host：指定请求资源的主机和端口号。端口号默认80。</li><li>Connection：值为keep-alive和close。keep-alive使客户端到服务器的连接持续有效，不需要每次重连，此功能为HTTP/1.1预设功能。</li><li>Accept：浏览器可接收的MIME类型。假设为text/html表示接收服务器回发的数据类型为text/html，如果服务器无法返回这种类型，返回406错误。</li><li>Cache-control：缓存控制，Public内容可以被任何缓存所缓存，Private内容只能被缓存到私有缓存，non-cache指所有内容都不会被缓存。</li><li>Cookie：将存储在本地的Cookie值发送给服务器，实现无状态的HTTP协议的会话跟踪。</li><li>Content-Length：请求消息正文长度。</li></ul><p>另有User-Agent、Accept-Encoding、Accept-Language、Accept-Charset、Content-Type等请求头这里不一一罗列。由此可见，请求报文是告知服务器请求的内容，而请求头是为了提供服务器一些关于客户机浏览器的基本信息，包括编码、是否缓存等。</p></li><li><p>空行（一行）</p></li><li><p>可选消息体（多行）</p></li></ul><p>响应报文</p><p>响应报文是服务器对请求资源的响应，通过上面提到的方式同样可以看到，同样地，数据也是以”\r\n”来分割。</p><ul><li><p>报文头（一行）</p><p>结构：version status_code status_message</p><ul><li><p>version</p><p>描述所遵循的HTTP版本。</p></li><li><p>status_code</p><p>状态码，指明对请求处理的状态，常见的如下。</p><ul><li>200：成功。</li><li>301：内容已经移动。</li><li>400：请求不能被服务器理解。</li><li>403：无权访问该文件。</li><li>404：不能找到请求文件。</li><li>500：服务器内部错误。</li><li>501：服务器不支持请求的方法。</li><li>505：服务器不支持请求的版本。</li></ul></li><li><p>status_message</p><p>显示和状态码等价英文描述。</p></li></ul></li><li><p>响应头（多行）</p><p>这里只罗列部分。</p><ul><li>Date：表示信息发送的时间。</li><li>Server：Web服务器用来处理请求的软件信息。</li><li>Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。</li><li>Content-Length：服务器告知浏览器自己响应的对象长度。</li><li>Content-Type：告知浏览器响应对象类型。</li></ul></li><li><p>空行（一行）</p></li><li><p>信息体（多行）</p><p>实际有效数据，通常是HTML格式的文件，该文件被浏览器获取到之后解析呈现在浏览器中。</p></li></ul><p><strong>CGI与环境变量</strong></p><ul><li><p>CGI程序</p><p>服务器为客户端提供动态服务首先需要解决的是得到用户提供的参数再根据参数信息返回。为了和客户端进行交互，服务器需要先创建子进程，之后子进程执行相应的程序去为客户服务。CGI正是帮助我们解决参数获取、输出结果的。</p><p>动态内容获取其实请求报文的头部和请求静态数据时完全相同，但请求的资源从静态的HTML文件变成了后台程序。服务器收到请求后fork()一个子进程，子进程执行请求的程序，这样的程序称为CGI程序（Python、Perl、C++等均可）。通常在服务器中我们会预留一个单独的目录（cgi-bin）用来存放所有的CGI程序，请求报文头部中请求资源的前缀都是/cgi-bin，之后加上所请求调用的CGI程序即可。</p><p>所以上述流程就是：客户端请求程序 -&gt; 服务器fork()子进程 -&gt; 执行被请求程序。接下来需要解决的问题就是如何获取客户端发送过来的参数和输出信息怎么传递回客户端。</p></li><li><p>环境变量</p><p>对CGI程序来说，CGI环境变量在创建时被初始化，结束时被销毁。当CGI程序被HTTP服务器调用时，因为是被服务器fork()出来的子进程，所以其继承了其父进程的环境变量，这些环境变量包含了很多基本信息，请求头中和响应头中列出的内容（比如用户Cookie、客户机主机名、客户机IP地址、浏览器信息等），CGI程序所需要的参数也在其中。</p><ul><li><p>GET方法下参数获取</p><p>服务器把接收到的参数数据编码到环境变量QUERY_STRING中，在请求时只需要直接把参数写到URL最后即可，比如”http:127.0.0.1:80/cgi-bin/test?a=1&amp;b=2&amp;c=3”，表示请求cgi-bin目录下test程序，’?’之后部分为参数，多个参数用’&amp;’分割开。服务器接收到请求后环境变量QUERY_STRING的值即为a=1&amp;b=2&amp;c=3。</p><p>在CGI程序中获取环境变量值的方法是：getenv()，比如我们需要得到上述QUERY_STRING的值，只需要下面这行语句就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *value = getenv(&quot;QUERY_STRING&quot;);</span><br></pre></td></tr></table></figure><p>之后对获得的字符串处理一下提取出每个参数信息即可。</p></li><li><p>POST方法下参数获取</p><p>POST方法下，CGI可以直接从服务器标准输入获取数据，不过要先从CONTENT_LENGTH这个环境变量中得到POST参数长度，再获取对应长度内容。</p></li></ul></li></ul><p><strong>会话机制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</span><br><span class="line"></span><br><span class="line">- Cookie</span><br><span class="line"></span><br><span class="line">    Cookie是客户端保持状态的方法。</span><br><span class="line"></span><br><span class="line">    Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</span><br><span class="line"></span><br><span class="line">    除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</span><br><span class="line"></span><br><span class="line">- Session</span><br><span class="line"></span><br><span class="line">    Session是服务器保持状态的方法。</span><br><span class="line"></span><br><span class="line">    首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</span><br><span class="line"></span><br><span class="line">当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h1&gt;&lt;h3 id=&quot;网络层-IP&quot;&gt;&lt;a href=&quot;#网络层-IP&quot; class=&quot;headerlink&quot; title=&quot;网络层(IP)&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://yoursite.com/2019/08/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/31/网络编程/</id>
    <published>2019-08-31T13:42:07.000Z</published>
    <updated>2019-08-31T13:47:42.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h3><ol><li>网络编程一般步骤？<ul><li>TCP：<ul><li>服务端：socket -&gt; bind -&gt; listen -&gt; accept -&gt; recv/send -&gt; close。</li><li>客户端：socket -&gt; connect -&gt; send/recv -&gt; close。</li></ul></li><li>UDP：<ul><li>服务端：socket -&gt; bind -&gt; recvfrom/sendto -&gt; close。</li><li>客户端：socket -&gt; sendto/recvfrom -&gt; close。</li></ul></li></ul></li><li>send、sendto区别，recv、recvfrom区别？</li></ol><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><ol><li>TCP和UDP区别？<ul><li>TCP面向连接（三次握手），通信前需要先建立连接；UDP面向无连接，通信前不需要连接。</li><li>TCP通过序号、重传、流量控制、拥塞控制实现可靠传输；UDP不保障可靠传输，尽最大努力交付。</li><li>TCP面向字节流传输，因此可以被分割并在接收端重组；UDP面向数据报传输。</li></ul></li><li>TCP为什么不是两次握手而是三次？<ul><li>如果仅两次连接可能出现一种情况：客户端发送完连接报文（第一次握手）后由于网络不好，延时很久后报文到达服务端，服务端接收到报文后向客户端发起连接（第二次握手）。此时客户端会认定此报文为失效报文，但在两次握手情况下服务端会认为已经建立起了连接，服务端会一直等待客户端发送数据，但因为客户端会认为服务端第二次握手的回复是对失效请求的回复，不会去处理。这就造成了服务端一直等待客户端数据的情况，浪费资源。</li></ul></li><li>TCP为什么挥手是四次而不是三次？<ul><li>TCP是全双工的，它允许两个方向的数据传输被独立关闭。当主动发起关闭的一方关闭连接之后，TCP进入半关闭状态，此时主动方可以只关闭输出流。</li><li>之所以不是三次而是四次主要是因为被动关闭方将”对主动关闭报文的确认”和”关闭连接”两个操作分两次进行。</li><li>“对主动关闭报文的确认”是为了快速告知主动关闭方，此关闭连接报文已经收到。此时被动方不立即关闭连接是为了将缓冲中剩下的数据从输出流发回主动关闭方（主动方接收到数据后同样要进行确认），因此要把”确认关闭”和”关闭连接”分两次进行。</li><li><strong>Linux的close实际上是同时关闭输入流和输出流，并不是我们常说的四次握手。半关闭函数为shutdown，它可以用来断开某个具体描述符的TCP输入流或输出流。</strong></li></ul></li><li>为什么要有TIME_WAIT状态，TIME_WAIT状态过多怎么解决？<ul><li>主动关闭连接一方在发送对被动关闭方关闭连接的确认报文时，有可能因为网络状况不佳，被动关闭方超时未能收到此报文而重发断开连接（FIN）报文，此时如果主动方不等待而是直接进入CLOSED状态，则接收到被动关闭方重发的断开连接的报文会触发RST分组而非ACK分组，当被动关闭一方接收到RST后会认为出错了。所以说处于TIME_WAIT状态就是为了在重新收到断开连接分组情况下进行确认。</li><li>解决方法：<ul><li>可以通过修改sysctl中TIME_WAIT时间来减少此情况（HTTP 1.1也可以减少此状态）。</li><li>利用SO_LINGER选项的强制关闭方式，发RST而不是FIN，来越过TIMEWAIT状态，直接进入CLOSED状态。</li></ul></li></ul></li><li>TCP建立连接及断开连接是状态转换？<ul><li>客户端：SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT。</li><li>服务端：LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED。</li></ul></li><li>TCP流量控制和拥塞控制的实现？<ul><li>流量控制：TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节，在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限，发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。</li><li>拥塞控制：网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象。严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。</li></ul></li><li>TCP重传机制？<ul><li>滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少、尚未确认的字节数、尚待发送的字节数；让接收方知道已经确认收到的字节数。</li><li>选择重传，用于对传输出错的序列进行重传。</li></ul></li><li>三次握手过程？<ul><li>主动建立连接方A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号x进行同步，表明在后面传送数据时的第一个数据字节的序号是x + 1。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。</li><li>接收连接方B的TCP收到连接请求报文段后，如同意则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为x + 1，同时也为自己选择一个序号y。</li><li>主动方A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为y + 1，而自己的序号为x + 1。</li></ul></li><li>四次挥手过程？<ul><li>主动关闭主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，将发往主机B的TCP报文段首部的终止比特FIN置1，其序号x等于前面已传送过的数据的最后一个字节的序号加1。</li><li>被动关闭主机B的TCP收到释放连接通知后即发出确认，其序号为y，确认号为x + 1，同时通知高层应用进程，这样，从A到B的连接就释放了，连接处于半关闭状态。但若主机B还有一些数据要发送主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。</li><li>若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须将终止比特FIN和确认比特ACK置1，并使其序号仍为y，但还必须重复上次已发送过的ACK = x + 1。</li><li>主机A必须对此发出确认，将ACK置1，ACK = y + 1，而自己的序号是x + 1。这样才把从B到A的反方向的连接释放掉。主机A的TCP再向其应用进程报告，整个连接已经全部释放。</li></ul></li></ol><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><ol><li>阻塞和非阻塞I/O区别？<ul><li>如果内核缓冲没有数据可读时，read()系统调用会一直等待有数据到来后才从阻塞态中返回，这就是阻塞I/O。</li><li>非阻塞I/O在遇到上述情况时会立即返回给用户态进程一个返回值，并设置errno为EAGAIN。</li><li>对于往缓冲区写的操作同理。</li></ul></li><li>同步和异步区别？<ul><li>同步I/O指处理I/O操作的进程和处理I/O操作的进程是同一个。</li><li>异步I/O中I/O操作由操作系统完成，并不由产生I/O的用户进程执行。</li></ul></li><li>Reactor和Proactor区别？<ul><li>Reactor模式已经是同步I/O，处理I/O操作的依旧是产生I/O的程序；Proactor是异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。</li><li>异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。</li></ul></li><li>epoll和select及poll区别？<ul><li>文件描述符数量限制：select文件描述符数量受到限制，最大为2048（FD_SETSIZE），可重编内核修改但治标不治本；poll没有最大文件描述符数量限制；epoll没有最大文件描述符数量限制。</li><li>检查机制：select和poll会以遍历方式（轮询机制）检查每一个文件描述符以确定是否有I/O就绪，每次执行时间会随着连接数量的增加而线性增长；epoll则每次返回后只对活跃的文件描述符队列进行操作（每个描述符都通过回调函数实现，只有活跃的描述符会调用回调函数并添加至队列中）。<strong>当大量连接是非活跃连接时epoll相对于select和poll优势比较大，若大多为活跃连接则效率未必高（设计队列维护及红黑树创建）</strong></li><li>数据传递方式：select和poll需要将FD_SET在内核空间和用户空间来回拷贝；epoll则避免了不必要的数据拷贝。</li></ul></li><li>epoll中ET和LT模式的区别与实现原理？<ul><li>LT：默认工作方式，同时支持阻塞I/O和非阻塞I/O，LT模式下，内核告知某一文件描述符读、写是否就绪了，然后你可以对这个就绪的文件描述符进行I/O操作。如果不作任何操作，内核还是会继续通知。这种模式编程出错误可能性较小但由于重复提醒，效率相对较低。传统的select、poll都是这种模型的代表。</li><li>ET：高速工作方式（因为减少了epoll_wait触发次数），适合高并发，只支持非阻塞I/O，ET模式下，内核告知某一文件描述符读、写是否就绪了，然后他假设已经知道该文件描述符是否已经就绪，内核不会再为这个文件描述符发更多的就绪通知（epoll_wait不会返回），直到某些操作导致文件描述符状态不再就绪。</li></ul></li><li>ET模式下要注意什么（如何使用ET模式）？<ul><li>对于读操作，如果read没有一次读完buff数据，下一次将得不到就绪通知（ET特性），造成buff中数据无法读出，除非有新数据到达。<ul><li>解决方法：将套接字设置为非阻塞，用while循环包住read，只要buff中有数据，就一直读。一直读到产生EAGIN错误。</li></ul></li><li>对于写操作主要因为ET模式下非阻塞需要我们考虑如何将用户要求写的数据写完。<ul><li>解决方法：只要buff还有空间且用户请求写的数据还未写完，就一直写。</li></ul></li></ul></li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>Linux下进程间通信方式？<ul><li>管道：<ul><li>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</li></ul></li><li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</li><li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</li><li>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</li></ul></li><li>Linux下同步机制？<ul><li>POSIX信号量：可用于进程同步，也可用于线程同步。</li><li>POSIX互斥锁 + 条件变量：只能用于线程同步。</li></ul></li><li>线程和进程的区别？<ul><li>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li><li>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</li><li>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li><li>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</li></ul></li><li>介绍虚拟内存？</li><li>内存分配及碎片管理？</li><li>有很多小的碎片文件怎么处理？</li></ol><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ol><li>fork系统调用？</li><li>什么场景用共享内存，什么场景用匿名管道？</li><li>有没有用过开源的cgi框架？</li><li>epoll和select比有什么优势有什么劣势，epoll有什么局限性？<ul><li>epoll优势：1. 没有描述符数量限制；2. 通过回调代替轮询；3. 内存映射代替数据在用户和内核空间来回拷贝。</li><li>epoll劣势（局限性）：select可以跨平台，epoll只能在Linux上使用。</li></ul></li><li>线程（POSIX）锁有哪些？<ul><li>互斥锁（mutex）<ul><li>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。</li></ul></li><li>条件变量(cond)</li><li>自旋锁(spin)<ul><li>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</li><li>虽然它的效率比互斥锁高，但是它也有些不足之处：<ul><li>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</li><li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</li></ul></li><li>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</li></ul></li><li>读写锁（rwlock）</li></ul></li></ol><h2 id="TKeed"><a href="#TKeed" class="headerlink" title="TKeed"></a>TKeed</h2><ol><li>项目整体架构是什么？请求怎么进来？处理完怎么出去？<ul><li>整体架构为：I/O多路复用 + 非阻塞I/O + 线程池，即Reactor反应堆模型。</li><li>处理流程：<ul><li>创建监听描述符并在epoll中注册。</li><li>监听到新请求，epoll从阻塞中返回并建立新连接。</li><li>将新建的连接描述符在epoll中注册。</li><li>当某个连接接收到用户请求数据时，将任务投放到线程池任务队列中。</li><li>工作线程被条件变量（任务队列不为空）唤醒，并互斥访问线程池。</li><li>得到任务的线程完成解析及响应。<ul><li>工作线程执行函数为do_request，参数即为task结构。<ul><li>每个task结构在建立连接是被初始化，包含描述符、缓冲区等信息是，并在do_request执行时记录解析结果及状态。</li></ul></li></ul></li></ul></li></ul></li><li>在做压测时，机器配置是什么样的？数据如何？<ul><li>本地测试。<ul><li>四核i5处理器 + 128G固态硬盘。</li></ul></li></ul></li><li>为了QPS（Query per second, 1秒内完成的请求数量）更高可以做哪些改进？<ul><li>对请求结果做缓存。</li><li>多次搜索请求采用异步I/O，改串行为并行。</li><li>调整并发线程数量（通常和CPU核心数相同）。</li></ul></li><li>有没有注意到压测时内存，CPU，I/O指标？<ul><li>压测同时打开top -H -p pid查看CPU，I/O，内存信息。</li></ul></li><li>压测时有没有见过TIME_WAIT？怎么样会见到？怎么解决？<ul><li>当服务端关闭连接时会产生TIME_WAIT。</li><li>解决方案：<ul><li>HTTP 1.1在同一个TCP连接上尽量传输更多数据。</li><li>通过修改sysctl配置减小TIME_WAIT时间。</li></ul></li></ul></li><li>是会主动关闭还是会等待客户端关闭连接?<ul><li>服务端会在完成请求之后关闭连接。</li></ul></li><li>写一个Server需要注意哪些问题？<ul><li>只支持request/response，除此之外是否需要支持cgi。</li><li>并发量，QPS，资源占用（内存，CPU，I/O，网络流量等）。<ul><li>CPU占用是否过高。</li><li>内存是否泄露。</li></ul></li></ul></li><li>项目中遇到什么困难，你是如何解决的？<ul><li>CPU占用过高。</li><li>压测时，每次最后会挂掉。</li></ul></li><li>做这个项目的目的是什么？</li><li>定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？</li><li>如果发生超时，在关闭连接时同时又收到了新的数据怎么办？</li><li>用什么数据结构存放url，怎么解析的？<ul><li>使用tk_request_t结构中buff读取用户请求，buff为循环缓冲（8192 Bytes）。</li><li>每次进入while循环时读取用户请求到buff中循环队列尾位置（plast），之后解析用户请求并响应。</li><li>支持HTTP 1.1，只要有数据就读取 -&gt; 解析 -&gt; 响应。</li></ul></li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>层序遍历二叉树？</li><li>map和hashmap的区别是什么？</li><li>Hash发生冲突时怎么处理？</li><li>hashmap的时间复杂度是多少？map的时间复杂度？</li><li>优先队列时间复杂度？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;h3 id=&quot;Socket-API&quot;&gt;&lt;a href=&quot;#Socket-API&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统理论</title>
    <link href="http://yoursite.com/2019/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/08/31/操作系统理论/</id>
    <published>2019-08-31T13:40:08.000Z</published>
    <updated>2019-08-31T13:40:30.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a>进程线程模型</h3><p>线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。</p><p><strong>多线程</strong></p><p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。我们必须知道，做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p><p>对于线程，我认为弄清以下两点非常重要：</p><ul><li>线程之间有无先后访问顺序（线程依赖关系）</li><li>多个线程共享访问同一变量（同步互斥问题）</li></ul><p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p><ol><li><p>线程创建和结束</p><ul><li><p>背景知识：</p><p>在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p></li><li><p>相关接口：</p><ul><li><p>创建线程：int pthread_create(pthread_t <em>pthread, const pthread_attr_t </em>attr, void <em>(</em>start_routine)(void <em>), void </em>agr);</p><p>创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。</p><ul><li>pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。</li><li>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</li><li>start_routine：线程执行函数的首地址，传入函数指针。</li><li>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</li></ul></li><li><p>获得线程ID：pthread_t pthread_self();</p><p>调用时，会打印线程ID。</p></li><li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);</p><p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li>tid：创建线程时通过指针得到tid值。</li><li>retval：指向返回值的指针。</li></ul></li><li><p>结束线程：pthread_exit(void *retval);</p><p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p>分离线程：int pthread_detach(pthread_t tid);</p><p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p><ul><li>tid：同上。</li></ul></li></ul></li></ul></li><li><p>线程属性值修改</p><ul><li><p>背景知识：</p><p>线程属性对象类型为pthread_attr_t，结构体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int etachstate;    // 线程分离的状态</span><br><span class="line">    int schedpolicy;    // 线程调度策略</span><br><span class="line">    struct sched_param schedparam;    // 线程的调度参数</span><br><span class="line">    int inheritsched;    // 线程的继承性</span><br><span class="line">    int scope;    // 线程的作用域</span><br><span class="line">    // 以下为线程栈的设置</span><br><span class="line">    size_t guardsize;    // 线程栈末尾警戒缓冲大小</span><br><span class="line">    int stackaddr_set;    // 线程的栈设置</span><br><span class="line">    void *    stackaddr;    // 线程栈的位置</span><br><span class="line">    size_t stacksize;    // 线程栈大小</span><br><span class="line">&#125;pthread_arrt_t;</span><br></pre></td></tr></table></figure></li><li><p>相关接口：</p><p>对上述结构体中各参数大多有：pthread_attr_get<strong><em>()和pthread_attr_set</em></strong>()系统调用函数来设置和获取。这里不一一罗列。</p></li></ul></li><li><p>线程同步</p><ul><li><a href="https://github.com/linw7/Skill-Tree/blob/master/操作系统.md#mutex" target="_blank" rel="noopener">详见同步互斥专题</a></li></ul></li></ol><p><strong>多进程</strong></p><p>每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。</p><p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p><ol><li><p>进程创建与结束</p><ul><li><p>背景知识：</p><p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></li><li><p>相关接口：</p><ul><li><p>创建进程：pid_t fork(void);</p><p>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid == 0</p></li><li><p>结束进程：void exit(int status);</p><ul><li>status是退出状态，保存在全局变量中S?，通常0表示正常退出。</li></ul></li><li><p>获得PID：pid_t getpid(void);</p><p>返回调用者pid。</p></li><li><p>获得父进程PID：pid_t getppid(void);</p><p>返回父进程pid。</p></li></ul></li><li><p>其他补充：</p><ul><li><p>正常退出方式：exit()、_exit()、return（在main中）。</p><p>exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p><p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p></li><li><p>异常退出方式：abort()、终止信号。</p></li></ul></li></ul></li><li><p>僵尸进程、孤儿进程</p><ul><li><p>背景知识：</p><p>父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。</p></li><li><p>相关接口：</p><ul><li><p>回收进程（1）：pid_t wait(int *status);</p><p>一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。</p><ul><li>status：指向子进程结束状态值。</li></ul></li><li><p>回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options);</p><p>返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。</p><ul><li>pid：子进程识别码，控制等待哪些子进程。<ol><li>pid &lt; -1，等待进程组识别码为pid绝对值的任何进程。</li><li>pid = -1，等待任何子进程。</li><li>pid = 0，等待进程组识别码与目前进程相同的任何子进程。</li><li>pid &gt; 0，等待任何子进程识别码为pid的子进程。</li></ol></li><li>status：指向返回码的指针。</li><li>options：选项决定父进程调用waitpid后的状态。<ol><li>options = WNOHANG，即使没有子进程退出也会立即返回。</li><li>options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。</li></ol></li></ul></li></ul></li></ul></li><li><p>守护进程</p></li></ol><ul><li><p>背景知识：</p><p>守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。</p></li><li><p>操作步骤：</p><ul><li>创建子进程，父进程退出：fork() + if(pid &gt; 0){exit(0);}，使子进程称为孤儿进程被init进程收养。</li><li>在子进程中创建新会话：setsid()。</li><li>改变当前目录结构为根：chdir(“/“)。</li><li>重设文件掩码：umask(0)。</li><li>关闭文件描述符：for(int i = 0; i &lt; 65535; ++i){close(i);}。</li></ul></li></ul><ol><li>Linux进程控制</li></ol><ul><li><p>进程地址空间（地址空间）</p><p>虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些”敏感”的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p></li><li><p>进程控制块（处理机）</p><p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p></li><li><p>上下文切换</p><p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p></li></ul><p><strong>线程、进程比较</strong></p><p>关于进程和线程的区别这里就不一一罗列了，主要对比下线程和进程操作中主要的接口。</p><ul><li><p>fork()和pthread_create()</p><p>负责创建。调用fork()后返回两次，一次标识主进程一次标识子进程；调用pthread_create()后得到一个可以独立执行的线程。</p></li><li><p>wait()和pthread_join()</p><p>负责回收。调用wait()后父进程阻塞；调用pthread_join()后主线程阻塞。</p></li><li><p>exit()和pthread_exit()</p><p>负责退出。调用exit()后调用进程退出，控制权交给系统；调用pthread_exit()后线程退出，控制权交给主线程。</p></li></ul><hr><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p><p><strong>管道</strong></p><ul><li>无名管道<ul><li>无名管道特点：<ul><li>无名管道是一种特殊的文件，这种文件只存在于内存中。</li><li>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</li><li>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</li></ul></li><li>相关接口：<ul><li>int pipe(int fd[2]);<ul><li>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</li></ul></li></ul></li></ul></li><li>有名管道：<ul><li>有名管道特点：<ul><li>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</li><li>无名管道可以在不具有亲缘关系的进程间进行通信。</li></ul></li><li>相关接口：<ul><li>int mkfifo(const char *pathname, mode_t mode);<ul><li>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</li><li>mode：和open()中的参数相同。</li></ul></li></ul></li></ul></li></ul><p><strong>消息队列</strong></p><p><strong>共享内存</strong></p><p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p><ul><li><p>相关接口</p><ul><li><p>创建共享内存：int shmget(key_t key, int size, int flag);</p><p>成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。</p><ul><li>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</li><li>size：共享内存容量。</li><li>flag：权限标志位，和open的mode参数一样。</li></ul></li><li><p>连接到共享内存地址空间：void <em>shmat(int shmid, void </em>addr, int flag);</p><p>返回值即共享内存实际地址。</p><ul><li>shmid：shmget()返回的标识。</li><li>addr：决定以什么方式连接地址。</li><li>flag：访问模式。</li></ul></li><li><p>从共享内存分离：int shmdt(const void *shmaddr);</p><p>调用成功返回0，失败返回-1。</p><ul><li>shmaddr：是shmat()返回的地址指针。</li></ul></li></ul></li><li><p>其他补充</p><p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p><p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p></li></ul><p><strong>信号量</strong></p><p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量， 而在进程里使用SYSTEM V信号量。</p><ul><li><p>相关接口</p><ul><li><p>创建信号量：int semget(key_t key, int nsems, int semflag);</p><p>创建成功返回信号量标识符，失败返回-1。</p><ul><li>key：进程pid。</li><li>nsems：创建信号量的个数。</li><li>semflag：指定信号量读写权限。</li></ul></li><li><p>改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);</p><p>我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p><p>struct sembuf结构体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sembuf&#123;</span><br><span class="line">    short sem_num;</span><br><span class="line">    short sem_op;</span><br><span class="line">    short sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成功返回信号量标识符，失败返回-1。</p><ul><li>semid：信号量集标识符，由semget()函数返回。</li><li>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</li><li>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</li></ul></li><li><p>直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);</p><ul><li>semid：信号量集标识符。</li><li>semnum：信号量集数组上的下标，表示某一个信号量。</li><li>arg：union semun类型。</li></ul></li></ul></li></ul><p><strong>辅助命令</strong></p><p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p><ul><li>ipcs -a：列出共享内存、信号量和消息队列信息。</li><li>ipcs -l：列出系统限额。</li><li>ipcs -u：列出当前使用情况。</li></ul><p><strong>套接字</strong></p><ul><li><a href="https://github.com/linw7/Skill-Tree/blob/master/计算机网络.md" target="_blank" rel="noopener">详见socket交互流程</a></li><li><a href="https://github.com/linw7/Skill-Tree/blob/master/操作系统.md#netio" target="_blank" rel="noopener">详见网络I/O模型</a></li></ul><hr><h3 id="同步互斥机制"><a href="#同步互斥机制" class="headerlink" title="同步互斥机制"></a>同步互斥机制</h3><blockquote><p>待补充</p></blockquote><hr><h3 id="网络I-O模型"><a href="#网络I-O模型" class="headerlink" title="网络I/O模型"></a>网络I/O模型</h3><p>在描述这块内容的诸多书籍中，很多都只说笼统的概念，我们将问题具体化，暂时只考虑服务器端的网络I/O情形。我们假定目前的情形是服务器已经在监听用户请求，建立连接后服务器调用read()函数等待读取用户发送过来的数据流，之后将接收到的数据打印出来。</p><p>所以服务器端简单是这样的流程：建立连接 -&gt; 监听请求 -&gt; 等待用户数据 -&gt; 打印数据。我们总结网络通信中的等待：</p><ul><li>建立连接时等待对方的ACK包（TCP）。</li><li>等待客户端请求（HTTP）。</li><li>输入等待：服务器用户数据到达内核缓冲区（read函数等待）。</li><li>输出等待：用户端等待缓冲区有足够空间可以输入（write函数等待）。</li></ul><p>另外为了能够解释清楚网络I/O模型，还需要了解一些基础。对服务器而言，打印出用户输入的字符串（printf函数）和从网络中获取数据（read函数）需要单独来看。服务器首先accept用户连接请求后首先调用read函数等待数据，这里的read函数是系统调用，运行于内核态，使用的也是内核地址空间，并且从网络中取得的数据需要先写入到内核缓冲区。当read系统调用获取到数据后将这些数据再复制到用户地址空间的用户缓冲区中，之后返回到用户态执行printf函数打印字符串。我们需要明确两点：</p><ul><li>read执行在内核态且数据流先读入内核缓冲区；printf运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来。</li><li>printf函数一定是在read函数已经准备好数据之后才能执行，但read函数作为I/O操作通常需要等待而触发阻塞。调用read函数的是服务器进程，一旦被read调用阻塞，整个服务器在获取到用户数据前都不能接受任何其他用户的请求（单进程/线程）。</li></ul><p>有了上面的基础，我们就可以介绍下面四种网路I/O模型。</p><p><strong>阻塞式</strong></p><ul><li>阻塞表示一旦调用I/O函数必须等整个I/O完成才返回。正如上面提到的那种情形，当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -&gt; 用户态）。</li><li>很显然，阻塞式I/O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程/线程）。为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I/O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。</li><li>多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I/O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。</li></ul><p><strong>非阻塞I/O</strong></p><ul><li>阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。</li><li>可以使用以下语句将句柄fd设置为非阻塞I/O：fcntl(fd, F_SETFL, O_NONBLOCK);</li><li>非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。</li><li>非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。</li></ul><p><strong>I/O多路复用（事件驱动模型）</strong></p><p>前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。</p><p>所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I/O多路复用就是这么一种模型。Linux下I/O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I/O范畴。</p><ol><li><p>select</p><ul><li><p>相关接口：</p><p>int select (int maxfd, fd_set <em>readfds, fd_set </em>writefds, fd_set <em>errorfds, struct timeval </em>timeout);</p><p>FD_ZERO(int fd, fd_set* fds) //清空集合</p><p>FD_SET(int fd, fd_set* fds) //将给定的描述符加入集合</p><p>FD_ISSET(int fd, fd_set* fds) //将给定的描述符从文件中删除</p><p>FD_CLR(int fd, fd_set* fds) //判断指定描述符是否在集合中</p></li><li><p>参数： maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。</p><p>readfds：指向读文件队列集合（fd_set）的指针。</p><p>writefds：同上，指向读集合的指针。</p><p>writefds：同上，指向错误集合的指针。</p><p>timeout：指向timeval结构指针，用于设置超时。</p></li><li><p>其他：</p><p>判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。</p></li></ul></li><li><p>poll</p><ul><li><p>相关接口： int poll(struct pollfd *fds, unsigned int nfds, int timeout);</p></li><li><p>结构体定义： struct pollfd{ int fd; // 文件描述符 short events; // 等到的事件 short revents; // 实际发生的事件 }</p></li><li><p>参数： fds：指向pollfd结构体数组的指针。</p><p>nfds：pollfd数组当前已被使用的最大下标。</p><p>timeout：等待毫秒数。</p></li><li><p>其他：</p><p>判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。</p></li></ul></li><li><p>epoll</p><ul><li><p>相关接口： int epoll_create(int size); // 创建epoll句柄 int epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event); // 事件注册函数 int epoll_wait(int epfd, struct epoll_event </em> events, int maxevents, int timeout);</p></li><li><p>结构体定义： struct epoll_event{ <strong>uint32_t events; epoll_data_t data; }; typedef union epoll_data{ void *ptr; int fd; </strong>uint32_t u32; __uint64_t u64; }epoll_data_t;</p></li><li><p>参数：</p><p>size：用来告诉内核要监听的数目。</p><p>epfd：epoll函数的返回值。</p><p>op：表示动作（EPOLL_CTL_ADD/EPOLL_CTL_FD/EPOLL_CTL_DEL）。</p><p>fd：需要监听的fd。</p><p>events：指向epoll_event的指针，该结构记录监听的事件。</p><p>maxevents：告诉内核events的大小。</p><p>timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。</p></li></ul></li><li><p>select、poll和epoll区别</p><ul><li><p>操作方式及效率：</p><p>select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。</p></li><li><p>最大连接数：</p><p>select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。</p></li><li><p>fd拷贝：</p><p>select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。</p></li><li><p>其他：</p><p>select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。</p></li></ul></li></ol><p><strong>异步I/O模型</strong></p><ul><li>上面三种I/O方式均属于同步I/O。</li><li>从阻塞式I/O到非阻塞I/O，我们已经做到了调用I/O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I/O能够立即返回又能不一直轮询的话会更符合我们的预期。</li><li>之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I/O结果。如果内核能够在完成I/O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I/O就是这么回事。</li><li>异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞。看上去异步I/O和非阻塞I/O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程线程模型&quot;&gt;&lt;a href=&quot;#进程线程模型&quot; class=&quot;headerlink&quot; title=&quot;进程线程模型&quot;&gt;&lt;/a&gt;进程线程模型&lt;/h3&gt;&lt;p&gt;线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++理论</title>
    <link href="http://yoursite.com/2019/08/31/C-%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/08/31/C-理论/</id>
    <published>2019-08-31T13:37:55.000Z</published>
    <updated>2019-08-31T13:38:46.156Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h3><p>C/C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。</p><ol><li>变量声明和定义区别？<ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</li><li>相同变量可以再多处声明（外部变量extern），但只能在一处定义。</li></ul></li><li>“零值比较”？<ul><li>bool类型：if(flag)</li><li>int类型：if(flag == 0)</li><li>指针类型：if(flag == null)</li><li>float类型：if((flag &gt;= -0.000001) &amp;&amp; (flag &lt;= 0. 000001))</li></ul></li><li>strlen和sizeof区别？<ul><li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li><li><strong>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</strong></li></ul></li><li>同一不同对象可以互相赋值吗？<ul><li>可以，但含有指针成员时需要注意。</li><li>对比类的对象赋值时深拷贝和浅拷贝。</li></ul></li><li>结构体内存对齐问题？<ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</li></ul></li><li>static作用是什么？在C和C++中有何区别？<ul><li>static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。</li><li>C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。</li><li>static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。</li><li>未初始化时，static变量默认值为0。</li></ul></li><li><p>结构体和类的区别？</p><ul><li>结构体的默认限定符是public；类是private。</li></ul><p>- <del>结构体不可以继承，类可以。</del> C++中结构体也可以继承。</p></li><li><p>malloc和new的区别？</p><ul><li>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</li><li>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</li><li>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</li></ul></li><li><p>指针和引用区别？    - 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</p><ul><li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul></li><li><p>宏定义和函数有何区别？</p><ul><li>宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</li><li>宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。</li><li>宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li><li>宏函数不要在最后加分号。</li></ul></li><li><p>宏定义和const区别？</p><ul><li>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</li><li>宏不检查类型；const会检查数据类型。</li><li>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</li></ul></li><li><p>宏定义和typedef区别？</p><ul><li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</li><li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li><li>宏不检查类型；typedef会检查数据类型。</li><li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li><li>注意对指针的操作，typedef char <em> p_char和#define p_char char </em>区别巨大。</li></ul></li><li><p>宏定义和内联函数(inline)区别？</p><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li>内联函数本身是函数，强调函数特性，具有重载等功能。</li><li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</li></ul></li><li><p>条件编译#ifdef, #else, #endif作用？</p><ul><li>可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。</li><li>用于子程序前加#define DEBUG用于程序调试。</li><li>应对硬件的设置（机器类型等）。</li><li>条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。</li></ul></li><li><p>区别以下几种变量？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br><span class="line">const int *a;</span><br><span class="line">int *const a;</span><br></pre></td></tr></table></figure><ul><li>int const a和const int a均表示定义常量类型a。</li><li>const int <em>a，其中a为指向int型变量的指针，const在 </em> 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)</li><li>int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</li></ul></li><li><p>volatile有什么作用？</p><ul><li>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。</li><li>多线程中被几个任务共享的变量需要定义为volatile类型。</li></ul></li><li><p>什么是常引用？</p><ul><li>常引用可以理解为常量指针，形式为const typename &amp; refname = varname。</li><li>常引用下，原变量值不会被别名所修改。</li><li>原变量的值可以通过原名修改。</li><li>常引用通常用作只读变量别名或是形参传递。</li></ul></li><li><p>区别以下指针类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p[10]</span><br><span class="line">int (*p)[10]</span><br><span class="line">int *p(int)</span><br><span class="line">int (*p)(int)</span><br></pre></td></tr></table></figure><ul><li>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li><li>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li><li>int <em>p(int)是函数声明，函数名是p，参数是int类型的，返回值是int </em>类型的。</li><li>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li></ul></li><li><p>常量指针和指针常量区别？</p><ul><li>常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const <em>p或const int </em>p。</li><li>指针常量是一个不能给改变指向的指针。如int *const p。</li></ul></li><li><p>a和&amp;a有什么区别？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设数组int a[10];</span><br><span class="line">int (*p)[10] = &amp;a;</span><br></pre></td></tr></table></figure><ul><li>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。</li><li>&amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若(int <em>)p ，此时输出 </em>p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li></ul></li><li><p>数组名和指针（这里为指向数组首元素的指针）区别？</p><ul><li>二者均可通过增减偏移量来访问数组中的元素。</li><li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li><li>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</li></ul></li><li><p>野指针是什么？</p><ul><li>也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。</li><li>产生原因及解决办法：<ul><li>指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。</li><li>指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</li></ul></li></ul></li><li><p>堆和栈的区别？</p><ul><li>申请方式不同。<ul><li>栈由系统自动分配。</li><li>堆由程序员手动分配。</li></ul></li><li>申请大小限制不同。<ul><li>栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li><li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li></ul></li><li>申请效率不同。<ul><li>栈由系统分配，速度快，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li></ul></li><li><p>delete和delete[]区别？</p><ul><li>delete只会调用一次析构函数。</li><li>delete[]会调用数组中每个元素的析构函数。</li></ul></li></ol><h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><p>能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。</p><ol><li><p>面向对象三大特性？</p><ul><li>封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。</li><li>继承性：让某种类型对象获得另一个类型对象的属性和方法。</li><li>多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</li></ul></li><li><p>public/protected/private的区别？</p><ul><li>public的变量和函数在类的内部外部都可以访问。</li><li>protected的变量和函数只能在类的内部和其派生类中访问。</li><li>private修饰的元素只能在类内访问。</li></ul></li><li><p>对象存储空间？</p><ul><li>非静态成员的数据类型大小之和。</li><li>编译器加入的额外成员变量（如指向虚函数表的指针）。</li><li>为了边缘对齐优化加入的padding。</li></ul></li><li><p>C++空类有哪些成员函数?</p><ul><li>首先，空类大小为1字节。</li><li>默认函数有：<ul><li>构造函数</li><li>析构函数</li><li>拷贝构造函数</li><li>赋值运算符</li></ul></li></ul></li><li><p>构造函数能否为虚函数，析构函数呢？</p><ul><li>析构函数：<ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li><li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul></li><li>构造函数：<ul><li>构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。</li></ul></li></ul></li><li><p>构造函数调用顺序，析构函数呢？</p><ul><li>调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅</li><li>基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。</li><li>如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。</li><li>成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。</li><li>派生类的构造函数。</li><li>析构函数与之相反。</li></ul></li><li><p>拷贝构造函数中深拷贝和浅拷贝区别？</p><ul><li>深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。</li><li>浅拷贝仅仅是拷贝指针字面值。</li><li>当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。</li></ul></li><li><p>拷贝构造函数和赋值运算符重载的区别？</p><ul><li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p></li><li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p></li><li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p></li><li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = s;    // 调用拷贝构造函数</span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    // 赋值运算符操作</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符</strong></p></li><li><p>虚函数和纯虚函数区别？</p><ul><li>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</li><li>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</li></ul></li><li><p>覆盖、重载和隐藏的区别？</p><ul><li>覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。</li><li>隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。</li><li>重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。</li></ul></li><li><p>在main执行之前执行的代码可能是什么？</p><ul><li>全局对象的构造函数。</li></ul></li><li><p>哪几种情况必须用到初始化成员列表？</p><ul><li>初始化一个const成员。</li><li>初始化一个reference成员。</li><li>调用一个基类的构造函数，而该函数有一组参数。</li><li>调用一个数据成员对象的构造函数，而该函数有一组参数。</li></ul></li><li><p>什么是虚指针？</p><ul><li>虚指针或虚函数指针是虚函数的实现细节。</li><li>虚指针指向虚表结构。</li></ul></li><li><p>重载和函数模板的区别？</p><ul><li>重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。</li><li>模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。</li></ul></li><li><p>this指针是什么？</p><ul><li>this指针是类的指针，指向对象的首地址。</li><li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</li><li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</li></ul></li><li><p>类模板是什么？</p><ul><li>用于解决多个功能相同、数据类型不同的类需要重复定义的问题。</li><li>在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。</li><li>类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。</li></ul></li><li><p>构造函数和析构函数调用时机？</p><ul><li>全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。</li><li>局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。</li><li>动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。</li><li>静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。</li></ul></li></ol><hr><h3 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h3><p>STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了：</p><ul><li><p>怎么用？</p><p>各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。</p></li><li><p>怎么实现？</p><p>本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。</p></li><li><p>如何避免错误？</p><p>在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。</p></li></ul><p><strong>string</strong></p><p><strong>vector</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">    vector&lt;T&gt; vec;</span><br><span class="line"></span><br><span class="line">插入元素：</span><br><span class="line">    vec.push_back(element);</span><br><span class="line">    vec.insert(iterator, element);</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    vec.pop_back();</span><br><span class="line">    vec.erase(iterator);</span><br><span class="line"></span><br><span class="line">修改元素：</span><br><span class="line">    vec[position] = element;</span><br><span class="line"></span><br><span class="line">遍历容器：</span><br><span class="line">    for(auto it = vec.begin(); it != vec.end(); ++it) &#123;......&#125;</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">    vec.empty();    //判断是否空</span><br><span class="line">    vec.size();    // 实际元素</span><br><span class="line">    vec.capacity();    // 容器容量</span><br><span class="line">    vec.begin();    // 获得首迭代器</span><br><span class="line">    vec.end();    // 获得尾迭代器</span><br><span class="line">    vec.clear();    // 清空</span><br></pre></td></tr></table></figure><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp" target="_blank" rel="noopener">模拟Vector实现</a></p><ul><li>线性表，数组实现。<ul><li>支持随机访问。</li><li>插入删除操作需要大量移动数据。</li></ul></li><li>需要连续的物理存储空间。</li><li>每当大小不够时，重新分配内存（*2），并复制原内容。</li></ul><p>错误避免：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp" target="_blank" rel="noopener">迭代器失效</a></p><ul><li>插入元素<ul><li>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</li><li>中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</li></ul></li><li>删除元素<ul><li>尾后删除：只有尾迭代失效。</li><li>中间删除：删除位置之后所有迭代失效。</li></ul></li></ul><p><strong>map</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">    map&lt;T_key, T_value&gt; mymap;</span><br><span class="line"></span><br><span class="line">插入元素：</span><br><span class="line">    mymap.insert(pair&lt;T_key, T_value&gt;(key, value));    // 同key不插入</span><br><span class="line">    mymap.insert(map&lt;T_key, T_value&gt;::value_type(key, value));    // 同key不插入</span><br><span class="line">    mymap[key] = value;    // 同key覆盖</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    mymap.erase(key);    // 按值删</span><br><span class="line">    mymap.erase(iterator);    // 按迭代器删</span><br><span class="line"></span><br><span class="line">修改元素：</span><br><span class="line">    mymap[key] = new_value;</span><br><span class="line"></span><br><span class="line">遍历容器：</span><br><span class="line">      for(auto it = mymap.begin(); it != mymap.end(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &apos;\n&apos;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/tree/master/code/RBTree" target="_blank" rel="noopener">RBTree实现</a></p><ul><li>树状结构，RBTree实现。<ul><li>插入删除不需要数据复制。</li><li>操作复杂度仅跟树高有关。</li></ul></li><li>RBTree本身也是二叉排序树的一种，key值有序，且唯一。<ul><li>必须保证key可排序。</li></ul></li></ul><p>基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。</p><p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p><ol><li><p>它是二叉排序树（继承二叉排序树特显）：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ul></li><li><p>它满足如下几点要求：</p><ul><li>树中所有节点非红即黑。</li><li>根节点必为黑节点。</li><li>红节点的子节点必为黑（黑节点子节点可为黑）。</li><li>从根到NULL的任何路径上黑结点数相同。</li></ul></li><li><p>查找时间一定可以控制在O(logn)。</p></li><li><p>红黑树的节点定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    RED = 0,</span><br><span class="line">    BLACK = 1</span><br><span class="line">&#125;;</span><br><span class="line">struct RBTreeNode &#123;</span><br><span class="line">    struct RBTreeNode*left, *right, *parent;</span><br><span class="line">    int key;</span><br><span class="line">    int data;</span><br><span class="line">    Color color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。</p><p>相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</p><p>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高。</p><p><strong>set</strong></p><hr><h3 id="编译及调试"><a href="#编译及调试" class="headerlink" title="编译及调试"></a>编译及调试</h3><p><strong>编译</strong></p><p>预处理</p><ul><li>展开所有的宏定义，完成字符常量替换。</li><li>处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。</li><li>处理#include指令，将被包含的文件插入到该指令所在位置。</li><li>过滤掉所有注释语句。</li><li>添加行号和文件名标识。</li><li>保留所有#pragma编译器指令。</li></ul><p>编译</p><ul><li>词法分析。</li><li>语法分析。</li><li>语义分析。</li><li>中间语言生成。</li><li>目标代码生成与优化。</li></ul><p>链接</p><p>各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。</p><ul><li><p>静态链接</p><p>静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib<em>**</em>.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。</p><p>既然静态链接是对目标文件的打包，这里介绍些打包命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test1.c    // 生成test1.o</span><br><span class="line">gcc -c test2.c    // 生成test2.c</span><br><span class="line">ar cr libtest.a test1.o test2.o</span><br></pre></td></tr></table></figure><p>首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -ltest</span><br></pre></td></tr></table></figure></li><li><p>动态链接</p><p>静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。</p><p>动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c test1.c </span><br><span class="line">gcc -fPIC -c test2.c</span><br><span class="line">gcc -shared test1.o test2.o -o libtest.so</span><br></pre></td></tr></table></figure><p>使用动态链接的用法也和静态链接相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -ltest</span><br></pre></td></tr></table></figure></li></ul><p>如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。</p><p>比较静态库和动态库我们可以得到二者的优缺点。</p><ul><li>动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。</li><li>动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。</li><li>不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。</li></ul><p>makefile编写</p><p>对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。</p><ul><li><p>基本规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:B</span><br><span class="line">(tab)&lt;command&gt;</span><br></pre></td></tr></table></figure><p>其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。</p></li><li><p>变量</p><p>makefile的书写非常像shell脚本，可以在文件中定义”变量名 = 变量值”的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。</p></li></ul><p><strong>链接</strong></p><p>符号解析</p><ul><li><p>可重定位目标文件</p><p>对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。</p></li><li><p>解析符号表</p><p>解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。</p></li></ul><p>重定位</p><ul><li><p>合并节</p><p>多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。</p></li><li><p>重定位符号引用</p><p>这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（”符号”）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。</p></li></ul><p>可执行目标文件</p><ul><li><p>ELF头部</p><p>描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。</p></li><li><p>段头部表</p><p>描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。</p></li><li><p>其他段</p><p>和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。</p></li></ul><p>加载</p><ul><li><p>克隆</p><p>新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。</p></li><li><p>重新映射</p><p>当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。</p></li><li><p>虚页调入</p><p>加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编程基础&quot;&gt;&lt;a href=&quot;#编程基础&quot; class=&quot;headerlink&quot; title=&quot;编程基础&quot;&gt;&lt;/a&gt;编程基础&lt;/h3&gt;&lt;p&gt;C/C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>阿里笔试20190830</title>
    <link href="http://yoursite.com/2019/08/31/%E9%98%BF%E9%87%8C%E7%AC%94%E8%AF%9520190830/"/>
    <id>http://yoursite.com/2019/08/31/阿里笔试20190830/</id>
    <published>2019-08-31T01:10:57.000Z</published>
    <updated>2019-08-31T01:54:09.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择题知识点总结"><a href="#选择题知识点总结" class="headerlink" title="选择题知识点总结"></a>选择题知识点总结</h1><h2 id="网络协议相关"><a href="#网络协议相关" class="headerlink" title="网络协议相关"></a>网络协议相关</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OSI:</span><br><span class="line">物理层：EIA/TIA<span class="number">-232</span>, EIA/TIA<span class="number">-499</span>, V<span class="number">.35</span>, V<span class="number">.24</span>, RJ45, Ethernet, <span class="number">802.3</span>, <span class="number">802.5</span>, FDDI, NRZI, NRZ, B8ZS</span><br><span class="line">数据链路层：Frame Relay, HDLC, PPP, IEEE <span class="number">802.3</span>/<span class="number">802.2</span>, FDDI, ATM,  IEEE <span class="number">802.5</span>/<span class="number">802.2</span>, 【ARP,RARP】</span><br><span class="line">网络层：IP，IPX，AppleTalk DDP</span><br><span class="line">传输层：TCP，UDP，SPX </span><br><span class="line">会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP </span><br><span class="line">表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML </span><br><span class="line">应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP</span><br></pre></td></tr></table></figure><p><img src="/2019/08/31/阿里笔试20190830/12.jpg" alt="12"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</span><br><span class="line"></span><br><span class="line">RPC是基于Socket的，即工作在会话层</span><br><span class="line">RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</span><br><span class="line">反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。网络管理员在局域网网关路由器里创建一个表以映射物理地址（MAC）和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向路由器上的 RARP 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IGMP协议是一个组管理协议，它帮助多播路由器创建以及更新与每一个路由接口相连的忠实成员列表（就是与该路由接口连接频率较高）。ICMP协议实际上就是差错控制协议，弥补了IP协议没有差错纠正机制以及差错报告的缺憾。ARP是一个地址映射协议，可以把一个IP地址映射为MAC地址。</span><br></pre></td></tr></table></figure><h2 id="红黑树相关操作"><a href="#红黑树相关操作" class="headerlink" title="红黑树相关操作"></a>红黑树相关操作</h2><p>参考：<a href="https://blog.csdn.net/weixin_40170902/article/details/80877147" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40170902/article/details/80877147</a></p><h1 id="编程题总结"><a href="#编程题总结" class="headerlink" title="编程题总结"></a>编程题总结</h1><h2 id="第一道"><a href="#第一道" class="headerlink" title="第一道"></a>第一道</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题意：链表跳表 </span><br><span class="line">给出整个实现类的基本框架，补全插入和查找函数</span><br></pre></td></tr></table></figure><p>参考代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> key;</span><br><span class="line">    <span class="keyword">uint64_t</span> value;</span><br><span class="line">    LinkNode* next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkipLinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    LinkNode* pointer = <span class="literal">NULL</span>;</span><br><span class="line">    SkipLinkNode* next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipLinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SkipLinkList(<span class="keyword">int</span> skipStep = <span class="number">128</span>);</span><br><span class="line">    ~SkipLinkList();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">simpleCheck</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkNode* _listHeader = <span class="literal">NULL</span>;</span><br><span class="line">    SkipLinkNode* _skipListHeader = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> _skipStep;</span><br><span class="line">    <span class="keyword">int</span> _itemCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SkipLinkList::SkipLinkList(<span class="keyword">int</span> skipStep)</span><br><span class="line">: _skipStep(skipStep)</span><br><span class="line">, _listHeader(<span class="literal">NULL</span>)</span><br><span class="line">, _skipListHeader(<span class="literal">NULL</span>)</span><br><span class="line">, _itemCount(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SkipLinkList::~SkipLinkList()</span><br><span class="line">&#123;</span><br><span class="line">    LinkNode* node = _listHeader;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkNode* toDelNode = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SkipLinkNode* skipNode = _skipListHeader;</span><br><span class="line">    <span class="keyword">while</span> (skipNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SkipLinkNode* toDelNode = skipNode;</span><br><span class="line">        skipNode = skipNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> SkipLinkList::simpleCheck()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> lastKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nodeCount = <span class="number">0</span>;</span><br><span class="line">    LinkNode* node = _listHeader;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodeCount++;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; lastKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastKey = node-&gt;key;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodeCount &lt; _skipStep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (_skipListHeader == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> skipNodeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> expectNodeCount = <span class="number">0</span>;</span><br><span class="line">    SkipLinkNode* skipNode = _skipListHeader;</span><br><span class="line">    <span class="keyword">while</span> (skipNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        skipNodeCount++;</span><br><span class="line">        <span class="keyword">if</span> (skipNode-&gt;key &lt; lastKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastKey = skipNode-&gt;key;</span><br><span class="line">        expectNodeCount += skipNode-&gt;count;</span><br><span class="line">        skipNode = skipNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeCount == expectNodeCount &amp;&amp;</span><br><span class="line">        skipNodeCount &gt;= ((nodeCount + _skipStep - <span class="number">1</span>) / _skipStep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 请完成下面这个函数，实现题目要求的功能 **/</span></span><br><span class="line"><span class="keyword">void</span> SkipLinkList::insert(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> char</span></span><br><span class="line">    <span class="keyword">if</span>(_skipListHeader==<span class="literal">NULL</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        _listHeader=<span class="keyword">new</span> LinkNode();</span><br><span class="line">        _listHeader-&gt;key=key;</span><br><span class="line">        _listHeader-&gt;value=value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        _skipListHeader=<span class="keyword">new</span> SkipLinkNode();</span><br><span class="line">        _skipListHeader-&gt;key=key;</span><br><span class="line">        _skipListHeader-&gt;count=<span class="number">1</span>;</span><br><span class="line">         _skipListHeader-&gt;pointer=_listHeader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        SkipLinkNode *tmpskiphead=_skipListHeader;</span><br><span class="line">        <span class="keyword">while</span> (tmpskiphead-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmpskiphead=tmpskiphead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//zhodao</span></span><br><span class="line">        LinkNode *tmplistnode=tmpskiphead-&gt;pointer;</span><br><span class="line">        <span class="keyword">while</span> (tmplistnode-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmplistnode=tmplistnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">         LinkNode *newnode=<span class="keyword">new</span> LinkNode();</span><br><span class="line">         newnode-&gt;key=key;</span><br><span class="line">         newnode-&gt;value=value;</span><br><span class="line">         tmplistnode-&gt;next=tmplistnode;</span><br><span class="line">         tmplistnode=tmplistnode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(tmpskiphead-&gt;count&gt;<span class="number">128</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           SkipLinkNode *newskipList=<span class="keyword">new</span> SkipLinkNode();</span><br><span class="line">            _skipListHeader-&gt;key=key;</span><br><span class="line">            _skipListHeader-&gt;count=<span class="number">1</span>;</span><br><span class="line">             _skipListHeader-&gt;pointer=tmplistnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _skipListHeader-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> SkipLinkList::find(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    SkipLinkNode *tmpskiphead=_skipListHeader;</span><br><span class="line">     SkipLinkNode *pre=_skipListHeader;</span><br><span class="line">    <span class="keyword">if</span>(tmpskiphead==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tmpskiphead-&gt;key&lt;key) &#123;</span><br><span class="line">        pre=tmpskiphead;</span><br><span class="line">        tmpskiphead=tmpskiphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmpskiphead-&gt;key==key) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   LinkNode *tmplistnode=pre-&gt;pointer;</span><br><span class="line">   <span class="keyword">while</span> (tmpskiphead-&gt;key&lt;=key) &#123;</span><br><span class="line">       <span class="keyword">if</span>(tmpskiphead-&gt;key==key)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       tmpskiphead=tmpskiphead-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 请完成上面的函数，实现题目要求的功能 **/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sepStr) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(text)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sep</span><span class="params">(sepStr)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="number">0</span>, old = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        n = str.find(sep, n);</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(str.substr(old, n - old));</span><br><span class="line">            n += sep.length();</span><br><span class="line">            old = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec.push_back(str.substr(old, str.length() - old));</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stringToInteger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = text.c_str();</span><br><span class="line">    <span class="keyword">char</span>* endPtr = <span class="literal">NULL</span>;</span><br><span class="line">    value = (T)strtol(str, &amp;endPtr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> (endPtr &amp;&amp; *endPtr == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">testSkipLinkList</span><span class="params">(<span class="built_in">string</span> inputParam)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; inputVec = splitString(inputParam, <span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (inputVec.size() != <span class="number">2</span> || (inputVec[<span class="number">0</span>] != <span class="string">"list"</span> &amp;&amp; inputVec[<span class="number">0</span>] != <span class="string">"count"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input format error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prepare data</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt; &gt; keyValueVec;</span><br><span class="line">    <span class="keyword">if</span> (inputVec[<span class="number">0</span>] == <span class="string">"list"</span>) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; kvVec = splitString(inputVec[<span class="number">1</span>], <span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kvVec.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; kvStr = splitString(kvVec[i], <span class="string">","</span>);</span><br><span class="line">            <span class="keyword">uint64_t</span> key, value;</span><br><span class="line">            <span class="keyword">if</span> (kvStr.size() != <span class="number">2</span> ||</span><br><span class="line">                !stringToInteger&lt;<span class="keyword">uint64_t</span>&gt;(kvStr[<span class="number">0</span>], key) ||</span><br><span class="line">                !stringToInteger&lt;<span class="keyword">uint64_t</span>&gt;(kvStr[<span class="number">1</span>], value))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"key-value list format error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            keyValueVec.push_back(make_pair(key, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputVec[<span class="number">0</span>] == <span class="string">"count"</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> count;</span><br><span class="line">        <span class="keyword">if</span> (!stringToInteger&lt;<span class="keyword">uint64_t</span>&gt;(inputVec[<span class="number">1</span>], count)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"count format error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint64_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            keyValueVec.push_back(make_pair(i, i));</span><br><span class="line">        &#125;</span><br><span class="line">        random_shuffle(keyValueVec.begin(), keyValueVec.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> maxKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function">SkipLinkList <span class="title">list</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; keyValueVec.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>.insert(keyValueVec[i].first, keyValueVec[i].second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test find</span></span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="built_in">list</span>.find(keyValueVec[i].first, value);</span><br><span class="line">        <span class="keyword">if</span> (!ret || value != keyValueVec[i].second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"test find error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// test replace</span></span><br><span class="line">        <span class="built_in">list</span>.insert(keyValueVec[i].first, keyValueVec[i].second + <span class="number">1</span>);</span><br><span class="line">        ret = <span class="built_in">list</span>.find(keyValueVec[i].first, value);</span><br><span class="line">        <span class="keyword">if</span> (!ret || value != keyValueVec[i].second + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"test replace error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxKey = max(maxKey, keyValueVec[i].first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test not exist key</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>.find(maxKey + <span class="number">1</span>, value))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"find not exist error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>.simpleCheck();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line">    <span class="built_in">string</span> _inputParam;</span><br><span class="line">    getline(<span class="built_in">cin</span>, _inputParam);</span><br><span class="line">    res = testSkipLinkList(_inputParam);</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"PASS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"FAIL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题意：飞鸽传书</span><br><span class="line">一只鸽子能发出两种不同的声音，</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  maxbirdmount=<span class="number">20</span>;<span class="comment">//   6 per</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getlocbit</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//最少的位置位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">pow</span>(<span class="number">2</span>,i)&lt;n)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxdatamount</span><span class="params">()</span><span class="comment">//单披最大传输量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i;i++)<span class="comment">//weizhi</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">int</span> birdmount=<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">       <span class="keyword">if</span>(birdmount&gt;maxbirdmount)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       res=max(res,birdmount*(<span class="number">6</span>-i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMinBatchnumber</span><span class="params">(<span class="keyword">int</span> bitlen)</span><span class="comment">//获取最少的批数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  Maxdatamount=GetMaxdatamount();</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)<span class="comment">//批次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Maxdatamount*i&gt;=bitlen)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMmaxSing</span><span class="params">(<span class="keyword">int</span> bitlen )</span><span class="comment">//  在最小批数已知的情况下 每批最小放飞的鸽子数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MinBatchnumber=GetMinBatchnumber(bitlen);</span><br><span class="line">    <span class="keyword">int</span> avgbit=<span class="built_in">ceil</span>(bitlen/MinBatchnumber);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> birdnum=<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">       <span class="keyword">int</span> minlocbit=Getlocbit(birdnum);</span><br><span class="line">       <span class="keyword">if</span>((<span class="number">6</span>-minlocbit)*birdnum&gt;=avgbit)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span>  birdnum;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求放飞批次最小的情况下每批次最小大放飞量</span></span><br><span class="line">    <span class="comment">//放飞批次最小</span></span><br><span class="line">    <span class="keyword">char</span>* str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> bitlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[len]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;;</span><br><span class="line">        len++;</span><br><span class="line">        bitlen=<span class="number">5</span>*len;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;GetMmaxSing(bitlen)&lt;&lt;<span class="string">" "</span>&lt;&lt;GetMinBatchnumber(bitlen)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">个人题意理解：</span><br><span class="line">一只信鸽携带的数据应该包括：信包序号+数据</span><br><span class="line">至于信鸽序号的位数确定：因为信鸽不会丢失，所以解码人可以根据一次接受到的信鸽数来判断信包序号的位数</span><br><span class="line">题意给出的需要传输的字符有31个，所以数据位是5位，因为2^5=32,所以提意我们可以假定用11111表示结束位，如果最后一只信鸽收到的不是结束位，说明还要继续接受下一批次的信鸽，直至收到结束位为止。(抑或将一只信鸽能传输的六位中的最后一位设为接受标志位，不然相对浪费资源，故舍去)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择题知识点总结&quot;&gt;&lt;a href=&quot;#选择题知识点总结&quot; class=&quot;headerlink&quot; title=&quot;选择题知识点总结&quot;&gt;&lt;/a&gt;选择题知识点总结&lt;/h1&gt;&lt;h2 id=&quot;网络协议相关&quot;&gt;&lt;a href=&quot;#网络协议相关&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="校招 笔试 C++ 总结" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B-%E7%AC%94%E8%AF%95-C-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>huawei20190928-笔试</title>
    <link href="http://yoursite.com/2019/08/29/huawei20190928-%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2019/08/29/huawei20190928-笔试/</id>
    <published>2019-08-29T01:26:39.000Z</published>
    <updated>2019-08-29T02:19:42.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给一个周长，求出其能满足的直角三角形有多少种。</span><br><span class="line"></span><br><span class="line">限制：周长&lt;=100000</span><br><span class="line"></span><br><span class="line">时间限制：&lt;1s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long  num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    double yy;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(x=1;x&lt;num/3;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        yy=1.0*(((num*num)-2*num*x))/(2*num-2*x);</span><br><span class="line">        if(yy-floor(yy)&gt;1e-10)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        y=(int)yy;</span><br><span class="line">        z=num-x-y;</span><br><span class="line">        if(x&lt;=y&amp;&amp;y&lt;z)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note：</span><br><span class="line"><span class="number">1.</span>防止运算过程中数据溢出。</span><br><span class="line"><span class="number">2.</span><span class="keyword">double</span>是不精确的，所以不能将之与某个数值相比，必须确定一个极小区间如<span class="number">1e-8</span>，比如<span class="keyword">if</span>(x-<span class="built_in">floor</span>(x)&gt;<span class="number">1e-8</span>)</span><br></pre></td></tr></table></figure><h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">水题</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">5</span>][<span class="number">5</span>]=&#123;    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,    &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,    &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>&#125;,    &#123;<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>&#125;,    &#123;<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>,<span class="number">45</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> mask[<span class="number">5</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> movex[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> movey[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    mask[x][y]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)   &#123;</span><br><span class="line">        <span class="keyword">if</span>(x+movex[i]&lt;<span class="number">0</span>||x+movex[i]&gt;<span class="number">4</span>||y+movey[i]&lt;<span class="number">0</span>||x+movey[i]&gt;<span class="number">4</span>)       &#123;</span><br><span class="line">            <span class="keyword">continue</span>;       &#125;</span><br><span class="line">        <span class="keyword">if</span>(mask[x+movex[i]][y+movey[i]]==<span class="number">-1</span>)       &#123;</span><br><span class="line">            <span class="keyword">continue</span>;       &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mask[x+movex[i]][y+movey[i]]==<span class="number">1</span>)       &#123;</span><br><span class="line">            solve(x+movex[i],y+movey[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa,b,c,d,e,f;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;aa&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">6</span>]=&#123;aa,b,c,d,e,f&#125;;</span><br><span class="line">        sort(a,a+<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">int</span> loc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startx,starty;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)            &#123;</span><br><span class="line">                <span class="keyword">if</span>(loc&lt;<span class="number">6</span>&amp;&amp;table[i][j]==a[loc])               &#123;</span><br><span class="line">                    loc++;</span><br><span class="line">                    mask[i][j]=<span class="number">1</span>;</span><br><span class="line">                    startx=i;</span><br><span class="line">                    starty=j;</span><br><span class="line">                &#125;               <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mask[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solve(startx,starty);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)   &#123;</span><br><span class="line">                <span class="keyword">if</span>(mask[i][j]==<span class="number">-1</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">6</span>)        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;        <span class="keyword">else</span>        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">俩整数数组，二者元素全部相同，仅顺序不同，求删去最少的元素使得俩整数数组相等。</span><br><span class="line">比如&#123;1，3，2&#125;、&#123;3，2，1&#125;，最少删去1后&#123;3、2&#125;&#123;3，2&#125;相同符合要求，所以结果为1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="keyword">int</span> *table1=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="keyword">int</span> *table2=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="keyword">int</span> *dp=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;locmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;table1[i];</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;table2[i];</span><br><span class="line">        locmap[table2[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxlts=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(locmap[table1[i]]&gt;locmap[table1[j]])</span><br><span class="line">           &#123;</span><br><span class="line">               dp[i]=max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlts=max(maxlts,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num-maxlts&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">欢迎找出反例</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="校招 C++" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B-C/"/>
    
  </entry>
  
  <entry>
    <title>程序纠错</title>
    <link href="http://yoursite.com/2019/08/26/%E7%A8%8B%E5%BA%8F%E7%BA%A0%E9%94%99/"/>
    <id>http://yoursite.com/2019/08/26/程序纠错/</id>
    <published>2019-08-26T08:34:03.000Z</published>
    <updated>2019-08-29T02:32:57.630Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">整个公司的人员结构可以看作是一棵标准的多叉树。树的头节点是公司唯一的老板，除老板外，每个员工都有唯一的直接上级，叶节点是没有任何下属的基层员工，除基层员工外，每个员工都有一个或多个直接下级，另外每个员工都有一个快乐值。</span><br><span class="line">这个公司现在要办 party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下的原则：</span><br><span class="line">1.如果某个员工来了，那么这个员工的所有直接下级都不能来。</span><br><span class="line">2.派对的整体快乐值是所有到场员工快乐值的累加。</span><br><span class="line">3.你的目标是让派对的整体快乐值尽量大。</span><br><span class="line">给定一棵多叉树，请输出派对的最大快乐值。</span><br><span class="line">输入描述:</span><br><span class="line">第一行两个整数 n 和 root，n 表示公司的总人数，root 表示公司的老板。</span><br><span class="line"></span><br><span class="line">第二行 n 个整数 happy_i 表示员工 i 的快乐值。</span><br><span class="line"></span><br><span class="line">接下来 n - 1 行每行两个整数 u_i 和 v_i 表示 u_i 是 v_i 的直接上级。</span><br><span class="line">输出描述:</span><br><span class="line">输出一个整数表示最大快乐值。</span><br><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line">复制</span><br><span class="line">3 1</span><br><span class="line">5 1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">输出</span><br><span class="line">复制</span><br><span class="line">5</span><br><span class="line">备注:</span><br><span class="line">1 \le n \le 5000001≤n≤500000</span><br><span class="line">0 \le happy_i \le 10000≤happy </span><br><span class="line">i</span><br><span class="line">​</span><br><span class="line"> ≤1000</span><br><span class="line">输入保证是一棵树</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxlen=<span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,root;</span><br><span class="line"><span class="keyword">int</span> ye[maxlen]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> happy[maxlen];</span><br><span class="line"><span class="keyword">int</span> mask0[maxlen]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> mask1[maxlen]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;fathr_son;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GetHappyness</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> flg)</span><span class="comment">//flg=1,可去可不去。。。 flg=0,一定去不了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ye[val]==<span class="number">0</span>)    <span class="comment">//叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(flg==<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span>  happy[val]  ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flg==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask0[val]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  mask0[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flg==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask1[val]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  mask1[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt;::iterator itor;</span><br><span class="line">    <span class="keyword">if</span>(flg==<span class="number">0</span>)             <span class="comment">//本节点选择不去，下节点可以选择去或不去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        itor=fathr_son.find(val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fathr_son.count(val);i++)</span><br><span class="line">        &#123;</span><br><span class="line">               tmp+=max(GetHappyness(itor-&gt;second,<span class="number">1</span>),GetHappyness(itor-&gt;second,<span class="number">0</span>));</span><br><span class="line">               itor++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask0[val]=tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                  <span class="comment">//本节点选择去，下节点肯定不能去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=happy[val];</span><br><span class="line"></span><br><span class="line">        itor=fathr_son.find(val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fathr_son.count(val);i++)</span><br><span class="line">        &#123;</span><br><span class="line">               tmp+=GetHappyness(itor-&gt;second,<span class="number">0</span>);</span><br><span class="line">               itor++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask1[val]=tmp;;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;happy[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">      fathr_son.insert(make_pair(a,b));</span><br><span class="line">       ye[a]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max(GetHappyness(root,<span class="number">1</span>),GetHappyness(root,<span class="number">0</span>))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="快乐值 树形dp" scheme="http://yoursite.com/tags/%E5%BF%AB%E4%B9%90%E5%80%BC-%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多线程</title>
    <link href="http://yoursite.com/2019/08/20/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/20/C-多线程/</id>
    <published>2019-08-20T14:23:28.000Z</published>
    <updated>2019-08-20T14:30:10.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、C-C-多线程操作说明"><a href="#一、C-C-多线程操作说明" class="headerlink" title="一、C/C++多线程操作说明"></a>一、C/C++多线程操作说明</h1><ol><li>C/C++多线程基本操作如下：<br>\1. 线程的建立结束<br>\2. 线程的互斥和同步<br>\3. 使用信号量控制线程<br>\4. 线程的基本属性配置 </li></ol><p>在C/C++代码编写时，使用多线程机制，首先需要做的事情就是声明引用，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pthread.h&quot;</span><br></pre></td></tr></table></figure><h1 id="二、线程基本操作方法"><a href="#二、线程基本操作方法" class="headerlink" title="二、线程基本操作方法"></a>二、线程基本操作方法</h1><p>基本线程操作：</p><p>\1. pthread_create()：创建线程开始运行相关线程函数，运行结束则线程退出</p><p>\2. pthread_eixt()：因为exit()是用来结束进程的，所以则需要使用特定结束线程的函数</p><p>\3. pthread_join()：挂起当前线程，用于阻塞式地等待线程结束，如果线程已结束则立即返回，0=成功</p><p>\4. pthread_cancel()：发送终止信号给thread线程，成功返回0，但是成功并不意味着thread会终止</p><p>\5. pthread_testcancel()：在不包含取消点，但是又需要取消点的地方创建一个取消点，以便在一个没有包含取消点的执行代码线程中响应取消请求.</p><p>\6. pthread_setcancelstate()：设置本线程对cancle线程的反应</p><p>\7. pthread_setcanceltype()：设置取消状态 继续运行至下一个取消点再退出或者是立即执行取消动作</p><p>\8. pthread_setcancel()：设置取消状态</p><h1 id="三、线程互斥与同步机制"><a href="#三、线程互斥与同步机制" class="headerlink" title="三、线程互斥与同步机制"></a>三、线程互斥与同步机制</h1><p>基本的互斥与同步的操作方法：</p><p>\1. pthread_mutex_init()：互斥锁的初始化</p><p>\2. pthread_mutex_lock()：锁定互斥锁，如果尝试锁定已经被上锁的互斥锁则阻塞至可用为止</p><p>\3. pthread_mutex_trylock()：非阻塞的锁定互斥锁</p><p>\4. pthread_mutex_unlock()：释放互斥锁</p><p>\5. pthread_mutex_destory()：互斥锁销毁函数</p><h1 id="四、信号量线程控制机制"><a href="#四、信号量线程控制机制" class="headerlink" title="四、信号量线程控制机制"></a>四、信号量线程控制机制</h1><p>C/C++在使用信号量机制的时候，默认的信号量为匿名信号量。</p><p>\1. sem_init(sem)：初始化一个定位在sem的匿名信号量</p><p>\2. sem_wait()：把信号量减1操作，如果信号量的当前值为0则进入阻塞，为原子操作</p><p>\3. sem_trywait()：如果信号量的当前值为0则返回错误而不是阻塞调用(errno=EAGAIN),其实是sem_wait()的非阻塞版本</p><p>\4. sem_post()：给信号量的值加1，它是一个“原子操作”，即同时对同一个信号量做加1,操作的两个线程是不会冲突的</p><p>\5. sem_getvalue(sval)：把sem指向的信号量当前值放置在sval指向的整数上</p><p>\6. sem_destory(sem)：销毁由sem指向的匿名信号量</p><h1 id="五、多线程实践"><a href="#五、多线程实践" class="headerlink" title="五、多线程实践"></a>五、多线程实践</h1><h3 id="1-基本的线程及建立运行"><a href="#1-基本的线程及建立运行" class="headerlink" title="1. 基本的线程及建立运行"></a>1. 基本的线程及建立运行</h3><p>下面的代码是C/C++开发的基本的线程的运行，使用的就是最基本的pthread.h：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER       3                 <span class="comment">/*线程数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER       5                 <span class="comment">/*每个线程中的小任务数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS  10.0             <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">/* 线程函数例程 */</span></span><br><span class="line">    <span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">int</span> delay_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++) &#123;</span><br><span class="line">        delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">        sleep(delay_time);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>, thrd_num, count, delay_time);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line">     <span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line">     <span class="keyword">void</span> * thrd_ret;</span><br><span class="line">     srand(time(<span class="literal">NULL</span>));    </span><br><span class="line">     <span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          <span class="comment">/* 创建多线程 */</span></span><br><span class="line">          res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line">          <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line">               <span class="built_in">exit</span>(res);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line">     <span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          <span class="comment">/* 等待线程结束 */</span></span><br><span class="line">          res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">          <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例程中循环3次建立3条线程，并且使用pthread_join函数依次等待线程结束；<br>线程中使用rand()获取随机值随机休眠5次，随意会出现后执行的线程先执行完成；<br>运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ gcc thread.c -lpthread</span><br><span class="line">$ ./a.out </span><br><span class="line">Create treads success</span><br><span class="line"> Waiting <span class="keyword">for</span> threads to finish...</span><br><span class="line">Thread <span class="number">0</span> is starting</span><br><span class="line">Thread <span class="number">1</span> is starting</span><br><span class="line">Thread <span class="number">2</span> is starting</span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">0</span> delay = <span class="number">2</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">1</span> delay = <span class="number">2</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">0</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">0</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">1</span> delay = <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">2</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">1</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">2</span> delay = <span class="number">3</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">3</span> delay = <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">2</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">3</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">4</span> delay = <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> finished</span><br><span class="line">        Thread <span class="number">2</span>: job <span class="number">3</span> delay = <span class="number">6</span></span><br><span class="line">        Thread <span class="number">0</span>: job <span class="number">4</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span> finished</span><br><span class="line">Thread <span class="number">0</span> joined</span><br><span class="line">Thread <span class="number">1</span> joined</span><br><span class="line">        Thread <span class="number">2</span>: job <span class="number">4</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">2</span> finished</span><br><span class="line">Thread <span class="number">2</span> joined</span><br></pre></td></tr></table></figure><p>可以看到，线程1先于线程0执行，但是pthread_join的调用时间顺序，先等待线程0执行；<br>由于线程1已经早结束，所以线程0被pthread_join等到的时候，线程1已结束，就在等待到线程1时，直接返回； </p><h3 id="2-线程执行的互斥和同步pthread-mutex-lock"><a href="#2-线程执行的互斥和同步pthread-mutex-lock" class="headerlink" title="2. 线程执行的互斥和同步pthread_mutex_lock"></a>2. 线程执行的互斥和同步pthread_mutex_lock</h3><p>下面我们在上面的程序中增加互斥锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*thread_mutex.c*/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">#define THREAD_NUMBER        3            /* 线程数 */</span><br><span class="line">#define REPEAT_NUMBER        3            /* 每个线程的小任务数 */</span><br><span class="line">#define DELAY_TIME_LEVELS 10.0         /*小任务之间的最大时间间隔*/</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"> </span><br><span class="line">void *thrd_func(void *arg) &#123;</span><br><span class="line">     int thrd_num = (int)arg;</span><br><span class="line">     int delay_time = 0, count = 0;</span><br><span class="line">     int res;</span><br><span class="line">     /* 互斥锁上锁 */</span><br><span class="line">     res = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">     if (res) &#123;</span><br><span class="line">          printf(&quot;Thread %d lock failed\n&quot;, thrd_num);</span><br><span class="line">          pthread_exit(NULL);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;Thread %d is starting\n&quot;, thrd_num);</span><br><span class="line">     for (count = 0; count &lt; REPEAT_NUMBER; count++) &#123;          </span><br><span class="line">         delay_time = (int)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + 1;</span><br><span class="line">         sleep(delay_time);</span><br><span class="line">         printf(&quot;\tThread %d: job %d delay = %d\n&quot;, </span><br><span class="line">                                      thrd_num, count, delay_time);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;Thread %d finished\n&quot;, thrd_num);</span><br><span class="line">     pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void) &#123;</span><br><span class="line">     pthread_t thread[THREAD_NUMBER];</span><br><span class="line">     int no = 0, res;</span><br><span class="line">     void * thrd_ret;</span><br><span class="line"> </span><br><span class="line">     srand(time(NULL));</span><br><span class="line">     /* 互斥锁初始化 */</span><br><span class="line">     pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">     for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          res = pthread_create(&amp;thread[no], NULL, thrd_func, (void*)no);</span><br><span class="line">          if (res != 0) &#123;</span><br><span class="line">              printf(&quot;Create thread %d failed\n&quot;, no);</span><br><span class="line">              exit(res);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;     </span><br><span class="line">     printf(&quot;Create treads success\n Waiting for threads to finish...\n&quot;);</span><br><span class="line">     for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">          res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">          if (!res) &#123;</span><br><span class="line">                printf(&quot;Thread %d joined\n&quot;, no);</span><br><span class="line">          &#125; else  &#123;</span><br><span class="line">              printf(&quot;Thread %d join failed\n&quot;, no);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;   </span><br><span class="line">     /****互斥锁解锁***/</span><br><span class="line">     pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">     pthread_mutex_destroy(&amp;mutex);          </span><br><span class="line">     return 0;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例程中直接添加同步锁pthread_mutex_t；<br>在线程中加入，于是程序在执行线程程序时；<br>调用pthread_mutex_lock上锁，发现上锁时候后进入等待，等待锁再次释放后重新上锁；<br>所以线程程序加载到队列中等待，等待成功上锁后继续执行程序代码；<br>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$gcc thread_mutex.c -lpthread</span><br><span class="line">$ ./a.out </span><br><span class="line">Create treads success</span><br><span class="line"> Waiting for threads to finish...</span><br><span class="line">Thread 0 is starting</span><br><span class="line">        Thread 0: job 0 delay = 9</span><br><span class="line">        Thread 0: job 1 delay = 4</span><br><span class="line">        Thread 0: job 2 delay = 7</span><br><span class="line">Thread 0 finished</span><br><span class="line">Thread 0 joined</span><br><span class="line">Thread 1 is starting</span><br><span class="line">        Thread 1: job 0 delay = 6</span><br><span class="line">        Thread 1: job 1 delay = 4</span><br><span class="line">        Thread 1: job 2 delay = 7</span><br><span class="line">Thread 1 finished</span><br><span class="line">Thread 1 joined</span><br><span class="line">Thread 2 is starting</span><br><span class="line">        Thread 2: job 0 delay = 3</span><br><span class="line">        Thread 2: job 1 delay = 1</span><br><span class="line">        Thread 2: job 2 delay = 6</span><br><span class="line">Thread 2 finished</span><br><span class="line">Thread 2 joined</span><br></pre></td></tr></table></figure><h3 id="3-使用信号量控制线程的执行顺序sem-post"><a href="#3-使用信号量控制线程的执行顺序sem-post" class="headerlink" title="3. 使用信号量控制线程的执行顺序sem_post"></a>3. 使用信号量控制线程的执行顺序sem_post</h3><p>修改上面例程，上面的是使用pthread_mutex_lock互斥锁控制线程执行顺序，<br>使用另外一种线程执行顺序的控制：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/* thread_sem.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"> </span><br><span class="line">#define THREAD_NUMBER       3</span><br><span class="line">#define REPEAT_NUMBER       3</span><br><span class="line">#define DELAY_TIME_LEVELS   10.0</span><br><span class="line"> </span><br><span class="line">sem_t sem[THREAD_NUMBER];</span><br><span class="line"> </span><br><span class="line">void * thrd_func(void *arg) &#123;</span><br><span class="line">    int thrd_num = (int)arg;</span><br><span class="line">    int delay_time = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    sem_wait(&amp;sem[thrd_num]);</span><br><span class="line">    printf(&quot;Thread %d is starting\n&quot;, thrd_num);</span><br><span class="line">    for (count = 0; count &lt; REPEAT_NUMBER; count++) &#123;</span><br><span class="line">        delay_time = (int)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + 1;</span><br><span class="line">        sleep(delay_time);</span><br><span class="line">        printf(&quot;\tThread %d: job %d delay = %d\n&quot;, thrd_num, count, delay_time);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Thread %d finished\n&quot;, thrd_num);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void) &#123;</span><br><span class="line">    pthread_t thread[THREAD_NUMBER];</span><br><span class="line">    int no = 0, res;</span><br><span class="line">    void * thrd_ret;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">        sem_init(&amp;sem[no], 0, 0);</span><br><span class="line">        res = pthread_create(&amp;thread[no], NULL, thrd_func, (void*)no);</span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line">            printf(&quot;Create thread %d failed\n&quot;, no);</span><br><span class="line">            exit(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Create treads success\n Waiting for threads to finish...\n&quot;);</span><br><span class="line">    sem_post(&amp;sem[THREAD_NUMBER - 1]);</span><br><span class="line">    for (no = THREAD_NUMBER - 1; no &gt;= 0; no--) &#123;</span><br><span class="line">        res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">        if (!res) &#123;</span><br><span class="line">            printf(&quot;Thread %d joined\n&quot;, no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;Thread %d join failed\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;sem[(no + THREAD_NUMBER - 1) % THREAD_NUMBER]);           </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (no = 0; no &lt; THREAD_NUMBER; no++) &#123;</span><br><span class="line">        sem_destroy(&amp;sem[no]);      </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果，仍然是建立3条线程，每条线程执行时休眠随机时长：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ gcc thread_sem.c -lpthread </span><br><span class="line">$ ./a.out </span><br><span class="line">Create treads success</span><br><span class="line"> Waiting for threads to finish...</span><br><span class="line">Thread 2 is starting</span><br><span class="line">        Thread 2: job 0 delay = 9</span><br><span class="line">        Thread 2: job 1 delay = 9</span><br><span class="line">        Thread 2: job 2 delay = 5</span><br><span class="line">Thread 2 finished</span><br><span class="line">Thread 2 joined</span><br><span class="line">Thread 1 is starting</span><br><span class="line">        Thread 1: job 0 delay = 5</span><br><span class="line">        Thread 1: job 1 delay = 7</span><br><span class="line">        Thread 1: job 2 delay = 4</span><br><span class="line">Thread 1 finished</span><br><span class="line">Thread 1 joined</span><br><span class="line">Thread 0 is starting</span><br><span class="line">        Thread 0: job 0 delay = 3</span><br><span class="line">        Thread 0: job 1 delay = 9</span><br><span class="line">        Thread 0: job 2 delay = 8</span><br><span class="line">Thread 0 finished</span><br><span class="line">Thread 0 joined</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>执行结果与第2个例程非常相似，只不过教材中进行倒序执行而已；<br>那么这种方式其实与使用互斥锁相比，代码量可读性基本持平不相上下；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、C-C-多线程操作说明&quot;&gt;&lt;a href=&quot;#一、C-C-多线程操作说明&quot; class=&quot;headerlink&quot; title=&quot;一、C/C++多线程操作说明&quot;&gt;&lt;/a&gt;一、C/C++多线程操作说明&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;C/C++多线程基本操作如下：&lt;br
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++  并发</title>
    <link href="http://yoursite.com/2019/08/20/C-%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2019/08/20/C-并发/</id>
    <published>2019-08-20T14:13:36.000Z</published>
    <updated>2019-08-21T09:34:51.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yi并发"><a href="#yi并发" class="headerlink" title="yi并发"></a>yi并发</h1><h1 id="一-并发"><a href="#一-并发" class="headerlink" title="一 并发"></a>一 并发</h1><h2 id="1-1，-什么叫并发-concurrency"><a href="#1-1，-什么叫并发-concurrency" class="headerlink" title="1.1， 什么叫并发 concurrency?"></a>1.1， 什么叫并发 concurrency?</h2><p>一遍走路一边说话；你打球我游泳</p><p>单核计算机上的并发是个假象，其实只是<strong>任务切换</strong>（task switching）需要上下文切换<br>多处理器或一个处理器上有多个核上的并发才是自然的并发，叫<strong>硬件并发</strong></p><p>并发种类： </p><h3 id="1，多进程并发"><a href="#1，多进程并发" class="headerlink" title="1，多进程并发"></a>1，多进程并发</h3><p>这些进程间可通过正常的进程通信渠道（信号，套接字，文件，管道等）<br>缺点：1；通信建立较复杂或者慢；2；操作系统需要花时间启动进程和管理进程资源等<br>优点：1；更容易写安全的并发代码比如Erlang语言 2；可以运行在不同的机器上 </p><p><img src="/2019/08/20/C-并发/cf01ff5499ce6602833d34363c9bb58.png" alt="cf01ff5499ce6602833d34363c9bb58"></p><h3 id="2，多线程并发"><a href="#2，多线程并发" class="headerlink" title="2，多线程并发"></a>2，多线程并发</h3><p>线程像轻量级的进程；每个线程互相独立，一个进程的所有线程分享同一个地址空间，多数数据可以共享，比如全局变量，指针和引用可以在线程间传递；<br>优点：共享地址空间和没有数据保护使得使用多线程程序比多进程程序代价小<br>The shared address space and lack of protection of data between threads makes the overhead associated with using multi- ple threads much smaller than that from using multiple pro- cesses<br> <img src="/2019/08/20/C-并发/4243b496ca682cc595c8ac101d8eefb.png" alt="4243b496ca682cc595c8ac101d8eefb"></p><h2 id="1-2-为什么使用并发"><a href="#1-2-为什么使用并发" class="headerlink" title="1.2 为什么使用并发"></a>1.2 为什么使用并发</h2><p>1，分离关注点<br>考虑一个桌面DVD应用<br>one thread can handle the user interface and another the DVD playback；<br>该应用线程的个数不受当前核数影响，而是根据设计而非纯粹提高吞吐量</p><p>2，性能<br>1，任务并行： 把任务划分为几部分并行执行 ；任务之间很可能有依赖<br>2，数据并行： 每个线程完成不同数据部分的相同操作<br>易并行算法 embarrassingly parallel、naturally parallel、 conveniently concurrent；扩展性好<br>nice scalability, cpu 核越多越好，视频处理，不同部分的图像可以并行处理</p><p>1.3 什么时候不使用并发<br>一般使用并发的代码更难理解，尤其是有额外复杂性的多线程代码将会导致更多的bug. 除非能带来性能提升或分离关注点，否则不要使用多线程<br>每个线程都会消耗stack 1M左右 比如32位系统， 总共4G，最多支持4096个线程，没有多余空间作为静态数据和堆数据了，64位系统也会只有有限的其它资源；通过线程池可以限制线程的数量（比如服务端程序限制连接数目）</p><p>1.4 C98<br>Posix C pthread lib 不支持跨平台<br>Boost and ACE 支持跨平台<br>C++11 支持 新的线程意识的内存模型；管理线程；保护共享数据；线程同步；低级原子操作<br>许多命名和结构从boost过来<br>支持原子操作让程序员写出更高效的跨平台代码 </p><h1 id="二线程之间的通信"><a href="#二线程之间的通信" class="headerlink" title="二线程之间的通信"></a>二线程之间的通信</h1><p>C++线程的通信方式有很多种,这里记录一下常用的几种:</p><p><strong>1.全局变量</strong></p><p><strong>2.互斥量</strong></p><p><strong>3.信号量</strong></p><p><strong>4.事件</strong></p><p><strong>5.临界区</strong></p><h2 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1.全局变量"></a>1.全局变量</h2><p>通过全局变量进行通信,要对该变量加关键字volatile<br>volatile(易变的):每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> signalNum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == signalNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signalNum not changed!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signalNum has changed!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signalNum = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:<img src="/2019/08/20/C-并发/1.png" alt="1"></p><h2 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2.互斥量"></a>2.互斥量</h2><p>互斥器的功能和临界区域很相似。区别是：Mutex所花费的时间比Critical Section多的多，但是Mutex是核心对象(Event、Semaphore也是)，可以跨进程使用，而且等待一个被锁住的Mutex可以设定 TIMEOUT，不会像Critical Section那样无法得知临界区域的情况，而一直死等。MFC中的对应类为CMutex。Win32函数有：创建互斥体CreateMutex() ，打开互斥体OpenMutex()，释放互斥体ReleaseMutex()。Mutex的拥有权并非属于那个产生它的线程，而是最后那个对此 Mutex进行等待操作（WaitForSingleObject等等）并且尚未进行ReleaseMutex()操作的线程。线程拥有Mutex就好像进入Critical Section一样，一次只能有一个线程拥有该Mutex。如果一个拥有Mutex的线程在返回之前没有调用ReleaseMutex()，那么这个 Mutex就被舍弃了，但是当其他线程等待(WaitForSingleObject等)这个Mutex时，仍能返回，并得到一个 WAIT_ABANDONED_0返回值。能够知道一个Mutex被舍弃是Mutex特有的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过互斥量实现线程间的同步，初始化为没有加锁的状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE mutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//对互斥量加锁,如果已经加锁了则等待其解锁,等待时间为INFINITE(表示永久)</span></span><br><span class="line">WaitForSingleObject(mutex, INFINITE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WaitForSingleObject(mutex, INFINITE);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment">这里可以做对共享资源的操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ReleaseMutex(mutex);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA lock mutex，please wait~~~~~~\n"</span>);</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA unlock mutex!!!!!!!!!!!!!!!!\n"</span>);</span><br><span class="line"><span class="comment">//互斥量解锁</span></span><br><span class="line">ReleaseMutex(mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line">WaitForSingleObject(mutex, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This is threadFuncB ~~~~~~\n"</span>);</span><br><span class="line">ReleaseMutex(mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadB, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="/2019/08/20/C-并发/2.png" alt="2"></p><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h2><p>信号量是最具历史的同步机制。信号量是解决producer/consumer问题的关键要素。对应的MFC类是Csemaphore。Win32函数 CreateSemaphore（）用来产生信号量。ReleaseSemaphore（）用来解除锁定。Semaphore的现值代表的意义是目前可用的资源数，如果Semaphore的现值为1，表示还有一个锁定动作可以成功。如果现值为5，就表示还有五个锁定动作可以成功。当调用Wait…等函数要求锁定，如果Semaphore现值不为0，Wait…马上返回，资源数减1。当调用ReleaseSemaphore（）资源数加1，当时不会超过初始设定的资源总数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用信号量</span></span><br><span class="line"><span class="comment">参数2:当前可用的信号的量个数 范围为(0 - 参数3)</span></span><br><span class="line"><span class="comment">参数3:信号量的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE signalSemaphore = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line">WaitForSingleObject(signalSemaphore, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 使用了一个信号量!\n"</span>);</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 释放了一个信号量!\n"</span>);</span><br><span class="line">ReleaseSemaphore(signalSemaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里会使信号量减1</span></span><br><span class="line">WaitForSingleObject(signalSemaphore, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncB 使用了一个信号量!\n"</span>);</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//信号量+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncB 释放了一个信号量!\n"</span>);</span><br><span class="line">ReleaseSemaphore(signalSemaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:<img src="/2019/08/20/C-并发/3.png" alt="3"></p><h2 id="4-事件"><a href="#4-事件" class="headerlink" title="4.事件"></a>4.事件</h2><p>用事件（Event）来同步线程是最具弹性的了。一个事件有两种状态：激发状态和未激发状态。也称有信号状态和无信号状态。事件又分两种类型：手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒“一个”等待中的线程，然后自动恢复为未激发状态。所以用自动重置事件来同步两个线程比较理想。MFC中对应的类为 CEvent.。CEvent的构造函数默认创建一个自动重置的事件，而且处于未激发状态。共有三个函数来改变事件的状态:SetEvent,ResetEvent和PulseEvent。用事件来同步线程是一种比较理想的做法，但在实际的使用过程中要注意的是，对自动重置事件调用SetEvent和PulseEvent有可能会引起死锁，必须小心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件进行通信</span></span><br><span class="line"><span class="comment">/*创建事件CreateEvent</span></span><br><span class="line"><span class="comment">LPSECURITY_ATTRIBUTESlpEventAttributes,// 安全属性</span></span><br><span class="line"><span class="comment">BOOLbManualReset,// 复位方式,如果是TRUE，那么必须用ResetEvent函数来复原到无信号状态。FALSE自动将事件状态复原为无信号状态。</span></span><br><span class="line"><span class="comment">BOOLbInitialState,// 初始状态,TRUE有信号,FALESE无信号</span></span><br><span class="line"><span class="comment">LPCTSTRlpName // 对象名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE threadEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 等待事件有信号!\n"</span>);</span><br><span class="line">WaitForSingleObject(threadEvent, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncA 等待事件信号成功,并把事件自动设置为无信号状态!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//给事件赋予信号</span></span><br><span class="line">SetEvent(threadEvent);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadFuncB 给了事件信号!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="/2019/08/20/C-并发/4.png" alt="4"></p><p>5.临界区<br>CRITICAL_SECTION是最快的。其他内核锁（事件、互斥体），每进一次内核，都需要上千个CPU周期。<br>使用临界区域的第一个忠告就是不要长时间锁住一份资源。这里的长时间是相对的，视不同程序而定。对一些控制软件来说，可能是数毫秒，但是对另外一些程序来说，可以长达数分钟。但进入临界区后必须尽快地离开，释放资源。如果不释放的话，会如何？答案是不会怎样。如果是主线程（GUI线程）要进入一个没有被释放的临界区，呵呵，程序就会挂了！临界区域的一个缺点就是：Critical Section不是一个核心对象，无法获知进入临界区的线程是生是死，如果进入临界区的线程挂了，没有释放临界资源，系统无法获知，而且没有办法释放该临界资源。这个缺点在互斥器(Mutex)中得到了弥补。Critical Section在MFC中的相应实现类是CcriticalSection。CcriticalSection：：Lock()进入临界区，CcriticalSection：：UnLock()离开临界区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxmt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用临界区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CCriticalSection cs;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncA</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncA 等待临界区解锁!\n"</span>);</span><br><span class="line">cs.Lock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncA 等待临界区解锁成功,对其加锁!\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncA 把临界区解锁!\n"</span>);</span><br><span class="line">cs.Unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">threadFuncB</span><span class="params">(LPVOID lpParamter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cs.Lock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncB 把临界区锁住了!\n"</span>);</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************threadFuncB 把临界区解锁!\n"</span>);</span><br><span class="line">cs.Unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE threadA = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE threadB = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, threadFuncB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">WaitForSingleObject(threadA, INFINITE);</span><br><span class="line">CloseHandle(threadA);<span class="comment">//CloseHandle只是关闭了系统句柄,该线程还是可以正常的运行</span></span><br><span class="line">CloseHandle(threadB);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/20/C-并发/20190718152652341.png" alt="20190718152652341"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yi并发&quot;&gt;&lt;a href=&quot;#yi并发&quot; class=&quot;headerlink&quot; title=&quot;yi并发&quot;&gt;&lt;/a&gt;yi并发&lt;/h1&gt;&lt;h1 id=&quot;一-并发&quot;&gt;&lt;a href=&quot;#一-并发&quot; class=&quot;headerlink&quot; title=&quot;一 并发&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++ 并发" scheme="http://yoursite.com/tags/C-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Seek Offer</title>
    <link href="http://yoursite.com/2019/08/20/Seek-Offer/"/>
    <id>http://yoursite.com/2019/08/20/Seek-Offer/</id>
    <published>2019-08-20T13:45:34.000Z</published>
    <updated>2019-08-20T13:45:34.276Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20190129记记录-Day_01</title>
    <link href="http://yoursite.com/2019/01/29/20190129%E8%AE%B0%E8%AE%B0%E5%BD%95-Day-01/"/>
    <id>http://yoursite.com/2019/01/29/20190129记记录-Day-01/</id>
    <published>2019-01-29T02:42:05.000Z</published>
    <updated>2019-02-08T12:40:48.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一动态规划"><a href="#一动态规划" class="headerlink" title="一动态规划"></a>一动态规划</h1><h1 id="二-C-进阶"><a href="#二-C-进阶" class="headerlink" title="二 C++进阶"></a>二 C++进阶</h1><p><img src="https://img-blog.csdn.net/20180710145044258?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5na2VfMTIyNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>C只读一本书《 The C Proguamming Language 》 读读C之父的著作，抛开老谭写的那本；</p><p>C++你可以读《C++ primer》，其实当你把这两本书读通后，我想对于C/C++语言的经验（除此之外要积累项目经验）来讲找工作是一定没问题的，可能还会比很多工作了的程序员在语言方面基础好。<br>如果想精通，结合我自己的体会，建议在C++方面阅读《effective c++》《more effective c++》这时至少语言的特性你会了解很多。之后可以把c++之父写的《C++ Programming Language》当做工具书来查看。<br>要想用好C++，有两个库不得不学，stl和boost。</p><hr><p>我刚找完工作，说下自己的看法吧。<br>首先，精通就算了，如果在简历中写“精通C/C++”，一般会死的灰常灰常灰常难看。<br>其次，如果以大公司为目标，如果你就读学校够好，其实把《程序员面试宝典》看熟了理解了，笔试就没啥问题了。笔试题，千篇一律啊~~<br>第三，选择一个小方向深入研究准备面试。比如说熟悉STL，就要把相关的内存分配机制、回收机制、vector漏洞什么的搞清楚，推荐侯捷那本STL源码剖析。<br>最后，光有语言基础是不够的，还需要学会经典的算法，能顺利写出快排的代码这个难度就可以了。Linux环境也稍微熟悉一下。其实大公司校招更看重你的学习能力、思考问题的方法。语言只是工具，人人都能用笔，但不见得人人都能作画。</p><p>参考博文：<a href="https://blog.csdn.net/qq_20996129/article/details/80218771" target="_blank" rel="noopener">https://blog.csdn.net/qq_20996129/article/details/80218771</a></p><h1 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">把数值作为 key，它的下标作为 value</span><br><span class="line">* 遍历数组，判断 map 是否含有这个目标值-当前数值，</span><br><span class="line">* 有直接返回，没有的话放到map里面</span><br><span class="line">*</span><br><span class="line">* 所以以后写代码，如果有双层 for 循环，首先考虑一下能否用 map 替换一层</span><br><span class="line"></span><br><span class="line">--&gt;   https://blog.csdn.net/yusiguyuan/article/details/12883727</span><br></pre></td></tr></table></figure><p><strong> 看一下hashmap和map和maptable等等的区别和联系</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispaly</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见的通信方式：</span><br><span class="line"><span class="number">1.</span> 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</span><br><span class="line"><span class="number">2.</span> 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</span><br><span class="line"><span class="number">4.</span> 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</span><br><span class="line"><span class="number">5.</span> 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</span><br><span class="line"><span class="number">6.</span> 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</span><br><span class="line"><span class="number">7.</span> 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</span><br><span class="line"><span class="number">8.</span> 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一动态规划&quot;&gt;&lt;a href=&quot;#一动态规划&quot; class=&quot;headerlink&quot; title=&quot;一动态规划&quot;&gt;&lt;/a&gt;一动态规划&lt;/h1&gt;&lt;h1 id=&quot;二-C-进阶&quot;&gt;&lt;a href=&quot;#二-C-进阶&quot; class=&quot;headerlink&quot; title=&quot;二
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何将好的技术产品化</title>
    <link href="http://yoursite.com/2019/01/15/%E5%A6%82%E4%BD%95%E5%B0%86%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BA%A7%E5%93%81%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/15/如何将好的技术产品化/</id>
    <published>2019-01-15T13:00:10.000Z</published>
    <updated>2019-01-15T13:01:38.079Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.linkedin.com/in/pauljacksonpivot" target="_blank" rel="noopener">Paul Jackson</a>是<a href="https://castle.co/" target="_blank" rel="noopener">Castle</a>公司的 SaaS 产品经理，他拥有超过 15 年的产品开发经验。在这篇文章里，他解释了什么是产品化、产品化的重要性、产品化的过程，并列举了很多实际的例子。文章内容来自作者在 TechCity 上的一次演讲，这里可以<a href="http://www.slideshare.net/kromagz/productised" target="_blank" rel="noopener">下载</a>到相应的 PPT。</p><h2 id="什么是产品化？"><a href="#什么是产品化？" class="headerlink" title="什么是产品化？"></a>什么是产品化？</h2><p>大部分初创公司都是从一个伟大的想法开始的，并且有一堆技术专家助阵。但伟大的技术和伟大的产品之间有着天壤之别。有些人希望做出对人们有实际使用价值的产品，这篇文章就是为这些人而写的。技术可以解决问题，但它无法规模化。我想用一个动词来描述这个过程——“产品化”。顾名思义，产品化就是把某些东西变成产品的过程。</p><p>我会先探讨产品化的原则，然后再举例深入说明。我要举的例子是 x.ai 公司的私人助理机器人<a href="https://x.ai/" target="_blank" rel="noopener">Amy</a>。在 2016 年，Amy 成为初创公司和风险投资领域十分流行的会议安排助手。</p><p>我以 Amy 为例，因为 Amy 是一项已经转化为消费级产品的 AI 技术。也就是说，这项技术已经被成功地“产品化”。</p><p>Amy 之所以值得我们关注，跟 x.ai（创造 Amy 的公司）宣称自己的“反精益”也有关系。作为产品人，我们对精益创业非常熟悉。精益在某种程度上已经成为非常流行的产品开发方法论。所以，如果有公司自豪地宣称自己是“反精益”的，这件事情就会变得很有趣。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>如果我们把“精益”想象成一条轴线，那么在轴线的一端会是 Airbnb 和 Dropbox 这样的独角兽公司。它们的精益都是从 Y Combinator 复刻出来的。而 Tesla 却是另一个极端。但没有人能够指责 Elon Musk 的反精益做法，他所做的每一件事件都是划时代的，都需要巨大的资本投入。</p><p>在 Tesla 往左一点是一些 AI 公司，比如 x.ai 和 Clarif.ai。这些公司宣称“精益不适合自己的发展”。x.ai 需要三年的研发投入才能让产品走向市场。反精益在前期需要更多的资本，而且只能允许少量的迭代和返工。反精益公司在起步的时候需要对它们的用户和用户的需求了如指掌。</p><h2 id="为什么产品化这么重要？"><a href="#为什么产品化这么重要？" class="headerlink" title="为什么产品化这么重要？"></a>为什么产品化这么重要？</h2><p>把一个愿景转化成一个有用且具有完全吸引力的产品才称得上是产品化。产品化的好处在于它可以帮助你跨过市场鸿沟。<a href="https://www.youtube.com/watch?v=887i04NjDjc" target="_blank" rel="noopener">Geoffrey Moore</a>有一个很著名的发现：在一小部分科技极客公司和主流市场之间存在着一个鸿沟。他在《<a href="https://www.amazon.com/Crossing-Chasm-Marketing-High-Tech-Mainstream/dp/0060517123" target="_blank" rel="noopener">Crossing the Chasm</a>》一书中探讨了影响初创公司跨越这个鸿沟的诸多因素，而产品化就是其中的一个方面。</p><p>产品化有助于绕开技术栈谬论的陷阱。<a href="https://techcrunch.com/2016/01/18/why-big-companies-keep-failing-the-stack-fallacy/" target="_blank" rel="noopener">Anshu Sharma</a>提出了技术栈谬论一说，他曾经是 Oracle 的产品经理，现在是 Storm Ventures 的合伙人。技术栈谬论的核心观点是说，在一个给定的技术栈里，每一个供应商都会高估自己的重要性，同时会低谷其它层，越是处在栈的上层，就越是如此。</p><p>技术栈谬论可以用来解释为什么“数据库公司会认为 SaaS 应用只不过是数据库应用而已，他们认为数据库最终会赢得市场”。</p><p>Anshu 认为，能够发展起来的公司是因为他们赢在了用户体验层，他们清楚地知道终端用户的方方面面。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>作为一个产品经理，我支持这种观点。根据我的经验，要赢得市场就要为客户的价值着想，产品化要聚焦产出而不是功能特性。</p><p>我们都非常熟悉“Job To Be Done”产品方法论。人们使用产品不是因为喜欢产品本身，他们是想通过使用产品来获得某些产出。Clay Christensen 的理论在这些年获得了很多<a href="http://www.forbes.com/sites/hbsworkingknowledge/2016/10/04/clayton-christensen-customers-dont-simply-buy-products-they-hire-them/#5a1412df5712" target="_blank" rel="noopener">支持</a>，我觉得这是有原因的。我坚信很多产品能够帮助人们获得他们想要的结果。只有情感方面的东西，比如品牌认知和美学体验，才超越了这个范畴。</p><p>产品化意味着要聚焦用户想要达成的结果，而不是底层的技术。因为竞争趋势的指数级增长，这个原则变得越来越关键。Mary Meeker 的 2016 年互联网报告里有两项统计数据引起了我的注意。第一个数据是说，美国人有 80% 的时间花在了 3 个应用程序上，至于是哪几个应用就没有必要提及了。2016 年底发布的 Nielsen 数据表明，<a href="https://medium.freecodecamp.com/all-of-2016s-top-mobile-apps-are-owned-by-either-google-or-facebook-a9c56d77a74b#.t3p8049k7" target="_blank" rel="noopener">Google 和 Facebook</a>这两家公司包揽了排名靠前的 8 个移动应用。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>第二个数据是说，50% 的美国人在一个月内不会下载新的应用。这个数字表明，新晋者面临的最大挑战是如何吸引用户的眼球。新应用的推广速度已经达到了饱和状态，因为市场上有太多的选择。对于初创公司来说，它们只有很短的时间来推销自己。如果无法把握住这个机会，就会面临失败。</p><h2 id="产品的三个阶段"><a href="#产品的三个阶段" class="headerlink" title="产品的三个阶段"></a>产品的三个阶段</h2><p>“产品”是什么？一个产品有三个阶段：<strong>产品着陆、完成核心任务和后期管理</strong>。你应该从这三个方面来考量你的产品。横跨这三者的是用户亲密度。在设计产品时，要时刻考虑用户的想法，就好像他们正在跟你的产品进行交互一样。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>用户对产品的认识开始于产品着陆之初。在这个阶段，他们对产品只有很少的了解。在产品着陆之后，他们开始使用产品来完成任务，那么他们就不可避免地对产品变得熟悉起来。如果他们继续使用产品，甚至把产品融入他们的生活，那么产品的后期管理就变得越来越重要。</p><p>除了上述的三个阶段，有必要再加入第四个，也就是初始的推广阶段。在这个阶段要让用户知道产品的存在。我不打算详细地讲解这个阶段，因为从根本上说它应该属于市场营销，超出了产品的范畴。不过，还是要记住产品与市场都是同一个共同体的组成部分。</p><p><a href="https://25iq.com/2016/04/02/a-dozen-things-ive-learned-from-chamath-palihapitiya-about-investing-and-business/" target="_blank" rel="noopener">Chamath Palihapitiya</a>对此做了很好的描述：</p><blockquote><p>“对于一个产品的用户来说，他们只有三种状态——他们从来没有听说过这个产品；他们试用过这个产品；他们使用了这个产品。你所要做的就是管理好这些状态”。</p></blockquote><p>理解用户的想法是让每个阶段都能成功的关键。在每个阶段，你需要倾听用户的声音。在推广阶段，用户对你一无所知。他们会说“你是谁？我为什么要使用你的产品？我有必要关心那么多吗？”在产品着陆阶段，他们会说“我会考虑的。我已经为此花了时间，我有在考虑，不过你还是要说服我”。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>一旦他们到达了核心任务阶段，就算跨过了一个里程碑。在这个阶段，他们会说“你是我的。我知道你是用来做什么的，我想看到你能够为我带来的价值”。管理阶段都是有关客户化服务的。用户会说“我得到了你所能够提供的价值，不过我想要根据我的需求来做一些定制”。</p><p>如果你对 Dave McClure 的“盗版度量指标”很熟悉，或许可以把它们与上述的四个阶段映射起来。最左边是推广指数，激励发生在产品着陆阶段，保留客户和收益是核心任务，移交一般发生在管理阶段。在这个阶段，你完全可以期待用户能够成为产品的拥护者。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><h2 id="产品价值"><a href="#产品价值" class="headerlink" title="产品价值"></a>产品价值</h2><p>产品赢在为客户价值着想。如果你想深入了解产品价值，可以看看 Jerry Chen（来自 Greylock Partners，也是 Reid Hoffman 和 Josh Elman 工作的地方）的“<a href="https://news.greylock.com/unit-of-value-a-framework-for-scaling-42c092fba887#.rscicw5ib" target="_blank" rel="noopener">价值单元</a>”。Jerry 对独角兽公司 Salesforce、Dropbox 和 Docker 的价值单元进行了评估，并演示了这些公司是如何在他们的服务里交付和使用这些价值的。</p><p>产品是“价值交付的搬运工”。如果你正在开发一个新产品，或者有了一个新想法，你需要问自己一个最基本的问题：它的价值单元是什么？你的回答将会贯穿产品的定价、规模化和销售的整个过程。推广阶段对产品价值许下承诺。在产品着陆时要把产品价值体现出来。价值的交付就是核心任务。管理阶段是对价值的延伸，它为客户带来更大的价值，也是促销更多产品的好时机。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>在理解了产品的价值单元之后，就可以对其进行演化。对于产品经理来说，最先要做的是列出一长串开发任务。我发现使用一个 2x2 的网格（<a href="https://blog.intercom.com/first-rule-prioritization-no-snacking/" target="_blank" rel="noopener">影响力和投入度网格模型</a>）来描述这些内容是一种很有效的方式。Hunter Walk（曾经是 YouTube 的产品主管）和 Intercom 的团队都是这个模型的知名倡导者。</p><p>为了确保能够获得良好的效果，所有项目都应该出现在网格的上半部分。对交付单元价值没有帮助的项目不应该出现在那里。战略相关的项目应该出现在右上角的象限里。在与相关人员评估网格时，产品经理和他的产品团队对应该和不应该做什么达成了共识。</p><p>以 Newsmart 为例，Newsmart 是我所工作过的一个项目，它是一个商务英语教学产品，它利用 Wall Street Journal 的内容进行教学，下面是它的 2017 年产品线路图。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>大多数产品的 1.0 版本都只包含了核心任务阶段，它们都不是从产品着陆阶段开始的。产品着陆阶段是进入产品核心的一个途径。产品化要从这个阶段开始，再逐步进入其它阶段。产品化要让用户知道你的产品，理解你的产品，使用你的产品，最后提出定制需求。</p><p>B2B 领域的产品可能会更复杂一些，因为用户和投资者不是同一批人。投资者的价值单元与用户的价值单元之间有很大差别。你可能会极力改进终端用户的体验，却忽视了投资者的需求，而投资者才是最终决定是否要投资你的产品的人。所以，产品需要同时照顾到两者的价值。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>对于客户产品来说，管理阶段一般不需要考虑太多，但在 B2B 领域，它却是非常重要的一环。投资者将如何对他们的投资回报进行评估？一般是通过报告，因为报告会告诉他们用户与产品之间的亲密度，以及这种亲密度将持续多久。在 Newsmart 这个产品上，在很长一段时间内我们一直忽视了这点。我们本该在管理阶段做得更好，让投资者看到价值，而不只是用户，但当我们意识到这点时已经太晚了。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>从个人用户市场起步的产品要进入到企业市场是一个很重大的转变，因为沟通方式和市场都变了。你不再需要去说服个人用户，你需要去说服的是一堆利益相关者。想要在企业市场取得成功，需要跨越很多障碍。Slack 最近<a href="https://techcrunch.com/2016/12/07/slack-and-google-announce-partnership-focused-on-better-integrating-their-services/" target="_blank" rel="noopener">宣布要跟 Google 的 G Suite 合</a>作。在我看来，Slack 也正面临着这个转折问题。Slack 有很好的个人用户市场，但在进入企业市场方面还处在挣扎阶段，并且它也意识到其实 Google 在这方面也没有任何优势。</p><h2 id="产品设计模式"><a href="#产品设计模式" class="headerlink" title="产品设计模式"></a>产品设计模式</h2><p>如果你仔细分析上述四个阶段，会发现人们已经对每个阶段都进行过充分的讨论了。它们已经形成了设计模式，可以直接在你的产品里灵活应用。没有必要重复发明轮子，也没有必要每次都要重新学习这些东西。</p><p>我们以产品着陆阶段为例。有个叫 Samuel Hulick 的人，他已经启动了一项叫作<a href="https://www.useronboard.com/" target="_blank" rel="noopener">User Onboard</a>的业务，他的业务特色是“产品分解”。产品分解过程会对不同产品进行评估，并分析它们的优点和缺点。产品经理可以到 User Onboard 去学习如何通过几个竖线就可以快速对不同产品进行分解。</p><p>产品着陆阶段的中间点是“Aha！”，如果达到了这一点，说明用户已经了解了产品的价值单元以及这些价值与自身的关系。要在产品着陆阶段成功，就要尽快让用户达到“Aha！”这个点。因为争夺用户的竞争日趋激烈，要尽量缩短达到“Aha！”的时间。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>Chamath Palihapitiya 是另一个很好的例子。在 2008 到 2012 年间，Chamath 是 Facebook Growth Team 的主管。他与他人沟通的方式很直接，甚至有点粗鲁。他在 YouTube 上做过一个很经典的<a href="https://www.youtube.com/watch?v=raIUQP71SBU" target="_blank" rel="noopener">谈话节目</a>，他在当中直言不讳地全面否定关于成长和“成长入侵”的伪科学。对于他来说，成长就是要理解产品的价值单元。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>如果有人怀疑产品着陆的重要性，我将以 Twitter 为例。对于 Twitter 来说，2016 年并不好过。业务饱和，增长呈断崖式下滑，股价也没有什么起色。</p><p>Twitter 的问题核心是它没有与用户做好价值单元的沟通。很多人仍然不是很了解 Twitter，不知道 Twitter 能够做些什么，而且说不出要使用它的理由。Twitter 在市场和产品着陆方面做得很失败。大部分用户只是注册了 Twitter，但并不会在上面发消息或者关注其他人。在这方面的失败意味着你将无法达到“Aha！”。如果你达不到“Aha！”，就不了解产品的价值是什么。如果你不了解产品的价值，那你就完蛋了。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>为了更进一步说明，我们举一个产品着陆做得很成功的例子。我之所以选择 x.ai 的 Amy 作为例子，是因为她本质上是一项技术，而不是产品。很多重要的资源被用来开发 AI 和决策引擎，当它们进入市场，会面临很多选择。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>从产品角度来看，x.ai 做了很多明智的选择。Amy 的产品着陆很简单，但很高效。当你在注册 Amy 时，她会给你发邮件说“你好，我是你的个人助理，欢迎登录”，然后她会指引你做一些操作。因为我们经常收发邮件，所以这种交互方式对我们来说很熟悉。</p><p>如果你仔细查看 Amy 发给你的第一封邮件，你会发现她对自己的价值主张做了清楚的阐述。她说“在 13 个会议之后你将会见证奇迹”。为了演示她的价值主张，她会为你安排第一个会议。她会发送一个邀请，并询问“可以为这个礼拜四添加一个会议提醒吗？”在接受了会议邀请之后，你会看到它被移动到日历里，到此，你也就理解了她的价值主张是什么。Amy 就此达到了“Aha！”。就在一瞬间，Amy 从一个陌生新奇的东西变成了你所熟悉的助理。这个设计模式大家应该都能理解。</p><p>Amy 的背后是一项能够支撑会议安排的技术。为了对它进行产品化，x.ai 对我们的脑力模型进行了评估，并利用了很多已知的东西，而不是引入一些陌生的事物。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>对于 Amy 来说，核心任务的完成体现在她与用户之间的邮件交互上面。在邮件交换过程中，她对用户日历进行协调，最后为会议作出安排。</p><p>在管理阶段，Amy 的每一个设置首选项都是关键所在。很多人不想把会议安排在星期天早上 9 点，而我尝试着把我的大部分面谈会议安排在这天早上，而把下午空闲出来，并做好了设置。当然，设置会发生变更。当设置发生变更时，Amy 会发邮件向你确认。</p><p>对我来说，Amy 简直太优秀了，她是这一时期产品化的典范。Amy 的价值单元是帮你节省时间。Amy 会根据你的使用情况进行统计，并把每个月为你省下的时间告诉你。一年下来，省下的时间还真不少。</p><h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><p>大部分产品会接受用户的支付，而这也是一个经常被忽视的环节。在支付方面，也有相应的设计模式。有很多研究是关于“<a href="http://white.net/blog/six-principles-good-choice-architecture/" target="_blank" rel="noopener">选择架构</a>”和支付计划的。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>对目标用户支付方式的评估也很重要。在 Newsmart，我们的产品主要面向亚洲市场，我们一开始支持 PayPal 和信用卡（通过 Stripe），后来我们从用户那里得到的反馈说“我想支付，但支付不了！”。原来我们忽视了中国、台湾和韩国的主要支付方式，这说明我们在支持支付方式方面做得不到位。</p><p>如果你是中国人，Alipay 会是首选的在线支付方式。在中国，UnionPay 也很流行，但 PayPal 没有人用。所以要对目标市场的信用卡使用率进行调查。在美国之外的很多国家，信用卡使用率很低——低于 50%。如果你不支持首选的本地支付方式，就等于放弃了很多赚钱的机会，因为就算用户愿意付钱，他们也没有办法支付。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><h2 id="钩子模型"><a href="#钩子模型" class="headerlink" title="钩子模型"></a>钩子模型</h2><p>用户心里学是有效产品化的基础，Nir Eyal 的“<a href="https://medium.com/behavior-design/how-to-manufacture-desire-3011c82a2b28#.72l79qwlk" target="_blank" rel="noopener">钩子模型</a>”就是一个很值得一学的设计范式。Nir 是 BJ Fogg 的学生，Nir 的“钩子模型”是基于 Fogg 的用户行为模型而提出的。这些模型把行为看成动机、能力和触发器的产出结果。Nir 对具有“超级用户黏性”产品的相似元素进行了研究，在他看来，Facebook、Snapchat、WhatsApp 和 LinkedIn 都创造了能够影响行为变更的因素。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><p>具有用户黏性的产品能够把动机和触发器紧紧地联系在一起。如果产品是一款 app，那么触发器有可能就是发送给用户的通知，比如“这里发生了一些事情，如果不来看你就会错过”。通知总是会把你拉向产品一边。如果你收到一封来自 Facebook 的邮件，接下来就会有后续的动作把你推向他们的产品。在 Nir 的模型里，最强大的动机是“各种各样的奖励”。从心理学角度说，奖励比破坏更容易让人上瘾。</p><p>可变性会在产品体验里注入未知的元素，它会让用户产生 FOMO（Fear of Missing Out，译为害怕错过），从而迫使他们采取行动。触发器和各种各样的奖励组合在一起，促使我们去使用 Snapchat 和 Facebook。FOMO 也是我们离不开这些平台的原因。你可能经常听到有人说他们已经中了 Facebook 的毒，并打算不再使用 Facebook，但没有人真的这么做过。</p><p><img src="/2019/01/15/如何将好的技术产品化/" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你要开发一个产品，不要只关注技术，而在一开始就要考虑价值问题。一旦你清楚你所能提供的价值，接下来就要想清楚如何把它展示出来，让用户知道，并把它们交付给用户。要时刻警觉用户对产品的熟悉程度，不要忽略了用户的诉求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.linkedin.com/in/pauljacksonpivot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Paul Jackson&lt;/a&gt;是&lt;a href=&quot;https://castle.co/&quot; targe
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>临时文件</title>
    <link href="http://yoursite.com/2018/10/29/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/10/29/临时文件/</id>
    <published>2018-10-29T12:13:48.000Z</published>
    <updated>2018-10-29T12:17:01.170Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxx,minn,total=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;table[i][j];</span><br><span class="line"> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  maxx=minn=total=table[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  total+=table[i][j];</span><br><span class="line">   <span class="keyword">if</span>(table[i][j]&gt;maxx)</span><br><span class="line">   &#123;</span><br><span class="line">   maxx=table[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(minn&gt;table[i][j])</span><br><span class="line">   &#123;</span><br><span class="line">   minn=table[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the max number is"</span>&lt;&lt;maxx&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the min number is"</span>&lt;&lt;minn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the total is"</span>&lt;&lt;total&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/29/临时文件/1.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="C++ 临时" scheme="http://yoursite.com/tags/C-%E4%B8%B4%E6%97%B6/"/>
    
  </entry>
  
</feed>
