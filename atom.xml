<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>muxin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/18d4fc6e466a8c32a8b91dfebad50ca5</icon>
  <subtitle>contact me by email:dreamcore@126.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-17T09:19:44.601Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>muxin</name>
    <email>dreamcore@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面经分析-20190916</title>
    <link href="http://yoursite.com/2019/09/16/%E9%9D%A2%E7%BB%8F%E5%88%86%E6%9E%90-20190916/"/>
    <id>http://yoursite.com/2019/09/16/面经分析-20190916/</id>
    <published>2019-09-16T01:39:18.000Z</published>
    <updated>2019-09-17T09:19:44.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网易互娱"><a href="#网易互娱" class="headerlink" title="网易互娱"></a>网易互娱</h2><p>原帖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">一面 共计时长<span class="number">1</span>h+</span><br><span class="line">牛客视频面试，两位面试官一起面，面试官们态度都特别好，面试体验极佳</span><br><span class="line"><span class="number">1.</span>自我介绍</span><br><span class="line">介绍了学校，项目（这一部分重点介绍），常用的编程语言，以及喜欢的游戏（划重点 阴阳师签到<span class="number">900</span>+天🤣）</span><br><span class="line"><span class="number">2.</span>Static关键字各种用法，Static声明的函数能否在其他文件中调用</span><br><span class="line"><span class="number">3.</span>Const关键字各种用法</span><br><span class="line"><span class="number">4.</span>虚函数的原理介绍一下，哪些函数不能是虚函数</span><br><span class="line"><span class="number">5.</span>虚函数指针在多继承下的情况</span><br><span class="line">比如类C继承了类A和类B。A，B中都有虚函数，那么C的虚表指针有多少个，</span><br><span class="line"><span class="number">6.</span>类C又定义了自己的虚函数，在虚表中的存储位置？</span><br><span class="line"><span class="comment">//问题5和6推荐看一下这篇博客 说的很详细 https://blog.csdn.net/li1914309758/article/details/79916414</span></span><br><span class="line"><span class="number">7.</span>C++<span class="number">11</span>的新特性了解哪些</span><br><span class="line"><span class="number">8.</span>右值引用和move()方法说一下</span><br><span class="line"><span class="number">9.</span>所有的智能指针说一下，全局变量和静态变量可以用智能指针吗</span><br><span class="line"><span class="number">10.</span><span class="built_in">shared_ptr</span>实现一下</span><br><span class="line"><span class="number">11.</span>weak_ptr如何解决<span class="built_in">shared_ptr</span>的循环引用问题，具体举一个例子说一下</span><br><span class="line"><span class="comment">//可以直接敲代码实现例子</span></span><br><span class="line"><span class="number">12.</span>stl平时用过哪些，大致把每一部分介绍一下</span><br><span class="line"><span class="number">13.</span><span class="built_in">map</span>和<span class="built_in">unordered_map</span>用过吗，底层如何实现的，它们的区别有哪些</span><br><span class="line"><span class="number">14.</span>红黑树和哈希表有什么关系，介绍一下红黑树的特性，插入，删除</span><br><span class="line"><span class="number">15.</span>哈希表处理冲突的几种方法说一下</span><br><span class="line"><span class="number">16.</span>使用再哈希法处理过冲突的哈希表，平均查找的时间复杂度是多少</span><br><span class="line"><span class="number">17.</span>再哈希法如何优化</span><br><span class="line"><span class="number">18.</span>线程同步的加锁方法有哪些</span><br><span class="line"><span class="number">19.</span>进程切换为什么比线程切换开销大，介绍TLB</span><br><span class="line"><span class="number">20.</span>死锁相关 包括死锁的必要条件，银行家算法等</span><br><span class="line"><span class="number">21.</span>平时有多线程开发经验吗</span><br><span class="line"><span class="number">22.</span>了解哪些排序方法，重点说了快排</span><br><span class="line"><span class="number">23.</span>了解过计算机图形学吗</span><br><span class="line"><span class="comment">//不怎么了解，这个是加分项，会的话加分，不会的话也没关系</span></span><br><span class="line"><span class="number">24.</span>笔试复盘 把笔试题目的思路和做法讲一遍</span><br><span class="line"><span class="number">25.</span>优化一下笔试第三题</span><br><span class="line"><span class="comment">//当时我是使用暴力法做的，面试官让思考一下能否使用dp来优化，我没想出来</span></span><br><span class="line"><span class="number">25.</span>嘉宾提问环节</span><br><span class="line"><span class="comment">//提问：如何强化出6号位爆伤16暴的破势🤣（误）</span></span><br><span class="line"></span><br><span class="line">二面 共计时长<span class="number">50</span>min</span><br><span class="line">牛客视频面试，这次是一位面试官单独面，面试官态度极好，我爱互娱🤣</span><br><span class="line"><span class="number">1.</span>自我介绍 重点介绍了项目，围绕项目主要说，包括项目的实现/创新点/难点/论文内容等等</span><br><span class="line"><span class="number">2.</span>平时玩过哪些游戏，在游戏中最难忘的经历有哪些</span><br><span class="line"><span class="comment">//开荒H古尔丹，为了部落</span></span><br><span class="line"><span class="number">3.</span>魔兽世界玩过哪些版本，最喜欢哪个版本</span><br><span class="line"><span class="number">4.</span>对行业内的游戏公司有哪些了解</span><br><span class="line"><span class="number">5.</span>用unity3D做过什么游戏，说一下使用过程中的技术难点</span><br><span class="line"><span class="number">6.</span>智力题</span><br><span class="line">有一张桌子，桌子上有很多砖头，现在我们要把砖头摞在桌子边缘又不能让砖头掉下去，同时要让砖头在桌子边沿之外的部分尽可能长，怎么摞</span><br><span class="line"><span class="comment">//这题我答的不好，基本就是一顿胡说面试官都笑了</span></span><br><span class="line"><span class="number">7.</span>场景题</span><br><span class="line">有一张表，表里存放了很多玩家信息和他们对应的IP地址，IP地址对应不同的位置</span><br><span class="line">需要实现的是玩家一登录，获取到玩家的IP地址，并且返回对应的地址，如果IP地址不在表中，则完成一个插入操作并判断</span><br><span class="line">用什么数据结构来实现</span><br><span class="line"><span class="comment">//个人的思路：使用多叉查找树来做，类似数据库索引</span></span><br><span class="line"><span class="number">8.</span>接上一题，如果还要同时快速查找一个区间的IP应该怎么做</span><br><span class="line"><span class="comment">//个人的思路：使用跳表来做</span></span><br><span class="line"><span class="number">9.</span>数据库的索引是用什么实现的</span><br><span class="line"><span class="number">10.B</span>树和B+树有什么区别，为什么不用红黑树或者普通二叉树来实现索引</span><br><span class="line"><span class="comment">//重点：减少IO次数</span></span><br><span class="line"><span class="number">11.</span>愉快的聊天环节，聊游戏，聊工作，聊人生</span><br><span class="line"><span class="number">12.</span>面试官给我讲段子之论做游戏有多快乐🤣</span><br></pre></td></tr></table></figure><p>解析</p><h3 id="Static关键字各种用法，Static声明的函数能否在其他文件中调用"><a href="#Static关键字各种用法，Static声明的函数能否在其他文件中调用" class="headerlink" title="Static关键字各种用法，Static声明的函数能否在其他文件中调用"></a>Static关键字各种用法，Static声明的函数能否在其他文件中调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 函数内<span class="keyword">static</span>局部变量：变量在程序初始化时被分配，直到程序退出前才被释放，也就是<span class="keyword">static</span>是按照程序的生命周期来分配释放变量的，而不是变量自己的生命周期。多次调用，仅需一次初始化。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> cpp内的<span class="keyword">static</span>全局变量：只在cpp内有效。在不同的cpp文件中定义同名变量，不必担心命名冲突。保持变量内容的持久。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 头文件内的<span class="keyword">static</span>全局变量：在每个包含该头文件的cpp文件中都是独立的。不推荐使用。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">static</span>函数：仅在当前文件内有效。在不同的cpp文件中定义同名函数，不必担心命名冲突。对其它源文件隐藏。在现代C++中被无名<span class="keyword">namespace</span>取代。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 类的<span class="keyword">static</span>数据成员：必须在<span class="class"><span class="keyword">class</span>的外部初始化。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">6. 类的<span class="title">static</span>函数：不能访问类的私有成员，只能访问类的<span class="title">static</span>成员，不需要类的实例即可调用。可以继承和覆盖，但无法是虚函数。属于整个类而非类的对象，没有<span class="title">this</span>指针。静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数。非静态成员函数可以任意地访问静态成员函数和静态数据成员。静态成员函数不能访问非静态成员函数和非静态数据成员。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">7. 单例模式(<span class="title">Singleton</span>)中使用<span class="title">static</span>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</span></span><br></pre></td></tr></table></figure><blockquote><p>1、为什么静态成员不能在类内初始化？<br>在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。</p><p>class A<br>{<br>private:<br>static int count ; // 类内声明<br>};</p><p>int A::count = 0 ; // 类外初始化，不必再加static关键字</p><p>为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><p>《c++primer》<strong>里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法</strong>。 但为什么static const int就可以在类里面初始化呢？<br>想起C中一个函数里定义一个static变量是为了保证只初始化一次。 那么，是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,这样编译器就不必考虑类的函数里面第一个对static变量的’=’操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。</p><p>2、什么东西能在类内初始化<br>能在类中初始化的成员只有一种，那就是静态常量成员。</p><p>这样不行<br>class A<br>{<br>private:<br>static int count = 0; // 静态成员不能在类内初始化<br>};</p><p>这样也不行<br>class A<br>{<br>private:<br>const int count = 0; // 常量成员也不能在类内初始化<br>};</p><p>但是这样可以<br>class A<br>{<br>private:<br>static const int count = 0; // 静态整型常量成员可以在类内初始化，但是 static const float count就不行了<br>}; </p></blockquote><h3 id="Const关键字各种用法"><a href="#Const关键字各种用法" class="headerlink" title="Const关键字各种用法"></a>Const关键字各种用法</h3><p>C++中使用const关键字来修饰常量，下面从两个方面总结：<strong>变量</strong>和<strong>成员函数</strong>。</p><p><strong>变量</strong>：const可以修饰普通变量、指针（数组）和结构体。</p><p>1.const修饰<strong>普通变量</strong>是最简单的情形。这样的用法多为在程序中创建一个只读变量，类似于C语言的#define宏定义，但const声明的变量可以指定类型，因此在C++中提倡使用const关键字声明只读变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Month = <span class="number">12</span>;　　<span class="comment">/* 示例代码 1 */</span></span><br></pre></td></tr></table></figure><p>示例代码1表示：定义了一个int型变量Month，程序可以使用该变量，但不可对Month变量重新赋值，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = Month + <span class="number">3</span>;　　　　<span class="comment">/* 正确 */</span></span><br><span class="line">Month = <span class="number">6</span>;　　　　　　　　　　<span class="comment">/* 错误 */</span></span><br></pre></td></tr></table></figure><p>2.下面是const修饰<strong>指针</strong>的情形。这样的情形多见于将指针/数组作为某个函数的参数，为了防止调用该函数时无意或错误修改了原指针数据，常在指针参数前添加const关键字，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strMsg)</span></span>;　　<span class="comment">/* 示例代码 2 */</span></span><br></pre></td></tr></table></figure><p>示例代码2声明了一个返回值为void的函数ShowMsg，假设该函数的作用是显示某个字符串的内容，我们在使用的时候不希望该函数修改原字符串的内容，因此可以将参数前添加const关键字，这样，如果函数代码中错误出现了修改strMsg字符串的代码，程序编译将会报错。</p><p>下面，分四种情况详细叙述const和指针的搭配：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 3 */</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pB = &amp;a;     　　　　<span class="comment">/* 1 */</span>   </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *pB = &amp;a;　　　　　　　<span class="comment">/* 2 */</span> </span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> pB = &amp;a;　　　　　　 <span class="comment">/* 3 */</span> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> pB = &amp;a;　　　<span class="comment">/* 4 */</span></span><br></pre></td></tr></table></figure><p>请看示例代码3中的四种情形，我们可以这样来记忆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const位于星号左侧表示指针指向的变量为常值，上述1、2两种情况的作用一样，指针变量指向的值为常值，不可使用指针变量pB来修改该值，换句话说，*pB的值为const不可修改，即不可执行*pB = 11;（但是a = 11是合法的，int b = 11;pB = &amp;b 也是合法的）。注意：可以将const变量的地址赋给const指针（如示例3），但不可将const变量的地址赋给非const指针。</span><br></pre></td></tr></table></figure><p>如以下代码是<strong>非法</strong>的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误代码示例 */</span><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const位于星号右侧表示是一个常量指针，该指针地址不可被修改。3表示pB只可指向&amp;a地址，但可以使用*pB = 11来改变a的值。4是以上两种情况的综合。</span><br></pre></td></tr></table></figure><p>3.使用const修饰函数一般出现在<strong>成员函数</strong>中，如下形式：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码4 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">　　　　......</span><br><span class="line">　　<span class="keyword">public</span>:</span><br><span class="line">　　　　...</span><br><span class="line">　　　　<span class="function"><span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span> <span class="keyword">const</span></span>;　　<span class="comment">/* 函数声明 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>像示例代码4中那样声明的函数称为const成员函数，该函数不会修改类对象，即不会对类的私有成员变量进行改动。</p><p><strong>const</strong> 表示该函数不会改变类中的数据。为什么最好要加 <strong>const</strong> 呢？</p><p>原因是假如我们在程序中这样定义了一个对象并且调用这两个函数，而这假设类中两个函数没有加 <strong>const</strong> ，那么编译器就会报错。 </p><h3 id="虚函数的原理介绍一下，哪些函数不能是虚函数"><a href="#虚函数的原理介绍一下，哪些函数不能是虚函数" class="headerlink" title="虚函数的原理介绍一下，哪些函数不能是虚函数"></a>虚函数的原理介绍一下，哪些函数不能是虚函数</h3><p><strong>虚函数的底层实现原理</strong></p><p><strong>实现原理：虚函数表+虚表指针</strong></p><p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，<strong>每个类使用一个虚函数表，每个类对象用一个虚表指针</strong>。</p><p>举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。<em>看下面两种情况：</em></p><ul><li><p>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。</p></li><li><p>如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">看到类P的三个实例p1,p2,p3他们的实例指针是不相同的，而虚函数表指针是同一个。</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">总结一下，如果C++类中定义过虚函数，不管是只定义了一个还是多个，那么这个类就会生出一个虚函数表，里面包含所有虚函数的地址指针列表，而类的每一个对象实例在内存的开头位置，都额外分配一个指针变量，指向类的虚函数表。</span><br><span class="line">当call一个虚函数的时候，首先从<span class="keyword">this</span>指针位置读出虚函数表，然后从虚函数表里面拿出虚函数的正确地址，在call到这个地址。</span><br><span class="line"></span><br><span class="line">把虚函数表指针放在对象内存的开始位置是linux环境下的结果，不同的编译运行环境可能会不同，比如windows系统下就把虚函数表指针放在对象内存的结尾部。</span><br><span class="line"> </span><br><span class="line">这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</span><br><span class="line"></span><br><span class="line">她是编译器在编译时期为我们创建好的, 只存在一份</span><br><span class="line">定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</span><br></pre></td></tr></table></figure><p><strong>虚函数调用过程</strong></p><p><img src="/2019/09/16/面经分析-20190916/064bb159a5a563699dbabaf8bb737e1.png" alt="064bb159a5a563699dbabaf8bb737e1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编译器只知道pb是B*类型的指针，并不知道它指向的具体对象类型 ：pb可能指向的是B的对象，也可能指向的是D的对象。  </span><br><span class="line">但对于“pb-&gt;bar()”，编译时能够确定的是：此处<span class="keyword">operator</span>-&gt;的另一个参数是B::bar（因为pb是B*类型的，编译器认为bar是B::bar），而B::bar和D::bar在各自虚函数表中的偏移位置是相等的。 </span><br><span class="line"></span><br><span class="line">无论pb指向哪种类型的对象，只要能够确定被调函数在虚函数中的偏移值，待运行时，能够确定具体类型，并能找到相应vptr了，就能找出真正应该调用的函数。 </span><br><span class="line"></span><br><span class="line">提示：本人曾在“C/C++杂记：深入理解数据成员指针、函数成员指针”一文中提到：虚函数指针中的ptr部分为虚函数表中的偏移值（以字节为单位）加<span class="number">1</span>。 </span><br><span class="line">B::bar是一个虚函数指针， 它的ptr部分内容为<span class="number">9</span>，它在B的虚函数表中的偏移值为<span class="number">8</span>（<span class="number">8</span>+<span class="number">1</span>=<span class="number">9</span>）。 </span><br><span class="line">当程序执行到“pb-&gt;bar()”时，已经能够判断pb指向的具体类型了： </span><br><span class="line"></span><br><span class="line">如果pb指向B的对象，可以获取到B对象的vptr，加上偏移值<span class="number">8</span>（(<span class="keyword">char</span>*)vptr + <span class="number">8</span>），可以找到B::bar。</span><br><span class="line">如果pb指向D的对象，可以获取到D对象的vptr，加上偏移值<span class="number">8</span>（(<span class="keyword">char</span>*)vptr + <span class="number">8</span>） ，可以找到D::bar。</span><br><span class="line">如果pb指向其它类型对象...同理...</span><br></pre></td></tr></table></figure><blockquote><p>1）虚函数按照其声明顺序放于表中。<br>2）父类的虚函数在子类的虚函数前面。</p></blockquote><p>多重继承**</p><p>当一个类继承多个类，且多个基类都有虚函数时，子类对象中将包含多个虚函数表的指针（即多个vptr），例：</p><p><img src="/2019/09/16/面经分析-20190916/5e197d1be3fbf69d630ba615426d137.png" alt="5e197d1be3fbf69d630ba615426d137"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其中：D自身的虚函数与B基类共用了同一个虚函数表，因此也称B为D的主基类（primary base <span class="class"><span class="keyword">class</span>）。</span></span><br><span class="line"><span class="class">虚函数替换过程与前面描述类似，只是多了一个虚函数表，多了一次拷贝和替换的过程。</span></span><br><span class="line"><span class="class">虚函数的调用过程，与前面描述基本类似，区别在于基类指针指向的位置可能不是派生类对象的起始位置，以如下面的程序为例：</span></span><br></pre></td></tr></table></figure><p><img src="/2019/09/16/面经分析-20190916/1dbbc48c03e86aceb701e8bbe8185cc.png" alt="1dbbc48c03e86aceb701e8bbe8185cc"></p><p><strong>哪些不能是虚函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.普通函数。</span><br><span class="line"></span><br><span class="line">2.友元函数。</span><br><span class="line"></span><br><span class="line">以上两个都不是类的成员函数</span><br><span class="line"></span><br><span class="line">4.静态成员函数；虚函数一定要通过对象来调，而静态成员函数不用（说明静态成员函数不在虚表之中）。</span><br><span class="line"></span><br><span class="line">5.构造函数；拷贝构造函数（构造函数还没有调就还没有对象，就没有指向虚表的指针，就不可以通过虚表去调用，这是一个先有鸡还是先有蛋的问题）</span><br><span class="line"></span><br><span class="line">6.但建议把析构函数给成虚函数（防止内存泄漏），如下代码可以说明这个问题</span><br><span class="line">5.内联函数；</span><br><span class="line"></span><br><span class="line">inline函数在编译时被展开，在调用处将整个函数替换为代码块，省去了函数跳转的时间，提高了SD，减少函数调用的开销，虚函数是为了继承后对象能够准确的调用自己的函数，执行相应的动作。</span><br><span class="line"></span><br><span class="line">主要的原因是：inline函数在编译时被展开，用函数体去替换函数，而virtual是在运行期间才能动态绑定的，这也决定了inline函数不可能为虚函数。（inline函数体现的是一种编译机制，而virtual体现的是一种动态运行机制</span><br><span class="line"></span><br><span class="line">注意：派生类里的析构函数最好给成虚函数。否则派生类中如有空间的开辟那么有可能造成内存泄露</span><br><span class="line"></span><br><span class="line">7.运算符重载可以写成虚函数但不建议用,如果硬要写成虚函数，可以看到写出的代码如下， </span><br><span class="line"></span><br><span class="line"> 可以看得因为参数列表的不同所以并不可以构成重写。也就是说写成虚函数是没有作用的（因为虚函数的作用是通过重写来实现的）。</span><br><span class="line"></span><br><span class="line">换句话说必须是类的成员函数</span><br></pre></td></tr></table></figure><blockquote><p><strong>virtual在函数中的使用限制</strong></p><ul><li><strong>普通函数不能是虚函数，也就是说这个函数必须是某一个类的成员函数，不可以是一个全局函数，否则会导致编译错误。</strong></li><li><strong>静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。</strong></li><li><strong>内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。</strong></li><li><strong>构造函数不能是虚函数，否则会出现编译错误。</strong></li></ul></blockquote><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><blockquote><p>一、内存分配方式</p><p>1.从静态存储区域分配。内存在程序编译的过程中就已经分配好，这块内存在程序的整个运行期间都存在。例如：全局变量和static变量。</p><p>2.在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数运行结束时，这些存储单元会被自动释放，栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存数量有限。</p><p>3.从堆上分配，又被称为动态内存分配。程序在运行过程中用malloc和new申请任意大小的内存，程序员自己负责在何时用free或者delete释放内存。内存的存在周期由我们自己决定，比较灵活，但同时出现的问题也比较多。</p><p>二、经常会出现的内存问题以及问题分析和解决方法</p><p>1.内存重复释放（一般在出现double free时基本上都是这个原因）</p><p>*关于double free会在下篇博客中讲解</p><p>2.内存泄漏。申请的内存忘了释放。</p><p>3.内存越界使用</p><p>4.内存未分配成功确使用了它</p><p>5.内存分配成功却没有初始化就使用了内存</p><p>6.使用了无效指针</p><p>（1）已经释放对象，却继续操作改指针所指的对象</p><pre><code>a.程序当中的对象调用关系过于复杂，是在难以搞清哪个对象是否已经释放了内存，从根本上解决对象管理混乱的情况。b.函数的return语句写错了，注意不要返回指向“栈内存”的指针或者引用。c.使用free或者delete释放之后，没有将其置空，导致产生野指针。</code></pre><p>（2）多线程中某一动态分配的对象同时被两个线程使用，一个线程释放了该对象，另一个线程却继续对该对象进行操作</p><p>三、使用规则</p><p>1.在malloc或者new之后应立即检查是否将其置为空，防止其使用指针值为NULL的空间。</p><p>2.不要忘记为指针和数组赋初始值，防止将未被初始化的内存作为右值使用</p><p>3.避免数组或者指针的下标越界，要特别注意多一，少一操作</p><p>4.动态内存的申请与释放必须配对使用，避免出现内存泄漏</p><p>5.用free或者delete之后要立即将其置为空，防止出现“野指针”</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">=======================================================================</span><br><span class="line">内存溢出（out of memory）</span><br><span class="line">是指程序在申请内存时，没有足够的内存空间供其使用。</span><br><span class="line">=======================================================================</span><br><span class="line">内存泄漏（memory leak）</span><br><span class="line">是指程序在申请内存后，无法释放已申请的内存空间，占用有用内存。</span><br><span class="line"></span><br><span class="line"> 注：内存泄漏最终会导致内存溢出</span><br><span class="line">简单理解，内存溢出就是要求分配的内存超出了系统所给的。内存泄漏是指向系统申请分配内存进行使用（<span class="keyword">new</span>），但是用完后不归还（<span class="keyword">delete</span>），导致占用有效内存。</span><br><span class="line"></span><br><span class="line">内存泄漏可分为<span class="number">4</span>类：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>常发性内存泄漏 </span><br><span class="line"></span><br><span class="line"> 引起内存泄漏的代码会被很多次执行，每次执行的时候都会导致内存泄漏</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>偶发性内存泄漏</span><br><span class="line"></span><br><span class="line">在某些特定的环境下执行引起内存泄漏的代码，才会引起内存泄漏</span><br><span class="line"></span><br><span class="line">从以上两种内存泄漏的方式来看，测试环境和测试方法在程序生命周期的重要性是不可或缺的。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>一次性内存泄漏</span><br><span class="line"></span><br><span class="line">代码只会执行一次，但总有一块内存发生泄漏，多见于构造类的时候，析构函数没有释放内存。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>隐式泄漏</span><br><span class="line"></span><br><span class="line">程序运行过程中不断的分配内存，直到结束时才释放内存，但一般服务器程序会运行较长的时间，不及时释放也会导致内存耗尽以至于内存泄漏。</span><br><span class="line"></span><br><span class="line">综上所述，一次性内存泄漏对用户的程序维护是没有什么实质性的伤害，但在实际生活中，我们还是尽可能要避免此类的事件发生。</span><br><span class="line">=======================================================================</span><br><span class="line">内存越界</span><br><span class="line">是指向系统申请一块内存后，使用时却超出申请范围。比如一些操作内存的函数：<span class="built_in">sprintf</span>、<span class="built_in">strcpy</span>、<span class="built_in">strcat</span>、<span class="built_in">vsprintf</span>、<span class="built_in">memcpy</span>、<span class="built_in">memset</span>、memmove。当造成内存泄漏的代码运行时，所带来的错误是无法避免的，通常会造成</span><br><span class="line"><span class="number">1.</span>破坏了堆中内存内存分配信息数据</span><br><span class="line"><span class="number">2.</span>破坏了程序其他对象的内存空间</span><br><span class="line"><span class="number">3.</span>破坏了空闲内存块</span><br><span class="line">附：如果在之前你的程序运行一切正常，但因为你新增了几个类的成员变量或者修改了一部分代码（前提是保证你的这些修改是完全正确的）而导致程序发生错误，则因考虑是否是内存被破坏的原因了，重点排查内存是否越界。</span><br><span class="line">=======================================================================</span><br><span class="line">缓冲区溢出（栈溢出）</span><br><span class="line">程序为了临时存取数据的需要，一般会分配一些内存空间称为缓冲区。如果向缓冲区中写入缓冲区无法容纳的数据，机会造成缓冲区以外的存储单元被改写，称为缓冲区溢出。而栈溢出是缓冲区溢出的一种，原理也是相同的。分为上溢出和下溢出。其中，上溢出是指栈满而又向其增加新的数据，导致数据溢出；下溢出是指空栈而又进行删除操作等，导致空间溢出。</span><br></pre></td></tr></table></figure><h3 id="数据结构之哈希表"><a href="#数据结构之哈希表" class="headerlink" title="数据结构之哈希表"></a>数据结构之哈希表</h3><blockquote><p>哈希算法就是将任意长度的二进制值映射为固定长度的二进制串，这个映射的规则就是哈希算法，原始数据映射之后得到的二进制哈希值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一般哈希算法的要求：</span><br><span class="line"></span><br><span class="line">不能通过哈希值反向推导出原始数据（哈希算法也叫单向哈希算法）</span><br><span class="line">对输入的数据非常敏感，哪怕原始数据只是修改了一个bit，最后得到的哈希值也大不形同</span><br><span class="line">对不同的原始数据，哈希值相同的概率要非常小，散列冲突的概率要很小。</span><br><span class="line">哈希算法的执行效率要尽量的高效，即使较长的文本也能很快的计算出哈希值</span><br></pre></td></tr></table></figure><p>哈希算法的应用非常多最常见的有安全加密，唯一标识，数据校验，散列函数，负载均衡，数据分片，分布式存储。</p><p><strong>哈希冲突解决办法</strong></p><p><strong>1.开发定址法</strong></p><p>　　如果遇到冲突的时候怎么办呢？就找hash表剩下空余的空间，找到空余的空间然后插入。就像你去商店买东西，发现东西卖光了，怎么办呢？找下一家有东西卖的商家买呗。</p><p><strong>2.链地址法</strong></p><p> 　　上面所说的开发定址法的原理是遇到冲突的时候查找顺着原来哈希地址查找下一个空闲地址然后插入，但是也有一个问题就是如果空间不足，那他无法处理冲突也无法插入数据，因此需要装填因子(插入数据/空间)&lt;=1。</p><p>　　那有没有一种方法可以解决这种问题呢？链地址法可以，链地址法的原理时如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。我感觉业界上用的最多的就是链地址法。下面从百度上截取来一张图片，可以很清晰明了反应下面的结构。比如说我有一堆数据{1,12,26,337,353…}，而我的哈希算法是H(key)=key mod 16，第一个数据1的哈希值f(1)=1，插入到1结点的后面，第二个数据12的哈希值f(12)=12，插入到12结点，第三个数据26的哈希值f(26)=10，插入到10结点后面，第4个数据337，计算得到哈希值是1，遇到冲突，但是依然只需要找到该1结点的最后链结点插入即可，同理353。</p><h3 id="Hash、Hash-map、map"><a href="#Hash、Hash-map、map" class="headerlink" title="Hash、Hash_map、map"></a>Hash、Hash_map、map</h3><blockquote><p> C++ STL 之所以得到广泛的赞誉，也被很多人使用，不只是提供了像vector, string, list等方便的容器，更重要的是STL封装了许多复杂的数据结构算法和大量常用数据结构操作。</p><p><strong>vector封装数组，list封装了链表，map和 set封装了二叉树</strong>等，在封装这些数据结构的时候，<strong>STL</strong>按照程序员的使用习惯，<strong>以成员函数方式提供的常用操作</strong>，如：插入、排序、删除、查找等。让用户在 STL使用过程中，并不会感到陌生。</p><p> C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  hash_map和<span class="built_in">map</span>的区别在哪里？</span><br><span class="line">构造函数。hash_map需要hash函数，等于函数；<span class="built_in">map</span>只需要比较函数(小于函数). </span><br><span class="line">存储结构。hash_map采用hash表存储，<span class="built_in">map</span>一般采用红黑树(RB Tree)实现。因此其memory数据结构是不一样的。 </span><br><span class="line">    什么时候需要用hash_map，什么时候需要用<span class="built_in">map</span>?</span><br><span class="line">总体来说，hash_map 查找速度会比<span class="built_in">map</span>快，而且查找速度基本和数据数据量大小，属于常数级别;而<span class="built_in">map</span>的查找速度是<span class="built_in">log</span>(n)级别。并不一定常数就比<span class="built_in">log</span>(n)小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且hash_map的构造速度较慢。</span><br><span class="line"></span><br><span class="line">现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用。</span><br></pre></td></tr></table></figure><p><strong>在C++11中，unordered_map作为一种关联容器，替代了hash_map，unordered_map的底层实现是hash表，所以被称为无序关联容器。</strong></p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p><strong>何时调用拷贝函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个对象以值传递的方式传入函数体</span><br><span class="line">一个对象以值传递的方式从函数返回（与返回值优化密切相关）</span><br><span class="line">一个对象需要通过另一个对象进行初始化</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/qianqiannian/p/8946769.html" target="_blank" rel="noopener">为什么需要拷贝构造函数</a></p><p>　　把参数传递给函数有三种方法，一种是传值，一种是传地址，一种是传引用。传值与其他两种方式不同的地方在于 当使用传值方式的时候，会在函数里面生成传递参数的一个副本，这个副本的内容是按位从原始参数那里复制过来的，两者的内容是相同的。</p><p>当原始参数是一个类的对象时，它也会产生一个对象的副本，此时需要注意：一般对象在创建时都会调用构造函数来进行初始化，但是</p><p>在产生对象的副本时如果再执行对象的构造函数，那么这个对象的属性又再恢复到原始状态，这就不是我们希望的了。所以在产生对象</p><p>副本的时候，构造函数不会被执行，被执行的是一个默认的默认的拷贝构造函数。</p><p>　　问题原因：</p><p>　　当函数执行完毕要返回的时候对象副本会执行析构函数，</p><p>如果你的析构函数是空的话，也不会发生什么问题，但一般的析构函数都是要完成一些清理工作，如释放指针所指向的内存空间，这时候</p><p>可能就会出问题。 譬如：我们在构造函数中为一个指针变量分配了内存，在析构函数中释放给这个指针所指向的内存空间，在把对象传递</p><p>给函数至函数结束返回 的这个过程中 首先有一个对象的副本产生了。这个副本也有一个指针，它和原始对象的指针是指向同块内存空间的，</p><p>函数返回时，副本对象的析构函数执行了，释放了副本对象中指针指向的内存空间，但是这个内存空间对于原始对象而言还是有效地，</p><p>这是第一个问题，后面当原始对象也被销毁的时候，原始对象的析构函数执行，还会对那块已经释放掉的内存空间再次释放，产生严重</p><p>错误，这是第二个问题。</p><p>　　解决方法：</p><p>　　既然传值有这样的问题，那是否可以使用传地址或者传引用的方式解决这种问题呢？</p><p>　　事实上传地址和传引用确实可以解决这种问题，但是这并不适用所有的情况，有时我们不希望在函数里面的一些操作会影响到函数外部的变量。</p><p>为了解决这种问题，此时就需要用到拷贝构造函数，拷贝构造函数就是在产生副本对象的时候执行的，在拷贝构造函数里面我们申请一个新的内存空间，</p><p>这样在副本对象执行析构函数时其释放的就是新的内存空间，从而解决这个问题。</p><p>　　适用范围：</p><p>\1. 一个对象以值传递的方式传入函数体</p><p>\2. 一个对象以值传递的方式从函数返回</p><p>\3. 一个对象需要通过另外一个对象进行初始化  </p><p>　　拷贝构造函数不可以改变它所引用的对象，如果可以改变，那么将导致无限循环，如果类中没有显示的声明一个拷贝构造函数，</p><p>那么编译器会为你隐式定义一个位拷贝的默认拷贝构造函数</p><p>　　如果不准备使用按值传递对象，那么其实是不需要拷贝构造函数，但是我们如果不写拷贝构造函数，编译器又可能为我们创建一个默认的。</p><p>那么如何保证一个对象将永远不会被通过按值传递方式传递呢？</p><p>　　声明一个私有的拷贝构造函数，甚至不必去定义它，除非成员函数或友元函数需要执行按值传递方式的传递。否则，如果用户试图用按值传递方式传递</p><p>或返回对象，编译器将会报错。这是因为拷贝构造函数是私有的。因为已经显示地声明我们接管了这项工作，所以编译器不再创建默认的拷贝构造函数</p></blockquote><h3 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h3><p>指针是一个存放地址的变量，而指针引用指的是这个变量的<strong>引用</strong>，众所周知C++中如果参数不是引用的话会调用参数对象的拷贝构造函数，所以如果有需求想改变指针所指的对象（换句话说，就是要改变指针里面存的地址），就要使用指针引用。</p><blockquote><p>C++中定义指针的引用有什么好处呢？</p><p>首先指针引用的定义方式（以char类型为例）： char*   &amp;ptr = xxx   </p><p>我们知道在C语言中如果想改变实参指针所指向的位置，就要定义重指针，如下面的例子</p><p>// 错误 实参指针不能被赋值<br>void changePtr( char<em> ptr )<br>{<br>    ptr = (char</em>)malloc(100*sizeof(char));<br>}<br>如果要想改变实参指针所指向的地址，则需要定义重指针</p><p>// 正确<br>void changePtr( char*<em> dbl_ptr )<br>{    </em>dbl_ptr = (char<em>)malloc(100</em>sizeof(char));<br>}<br>如果使用指针的引用</p><p>void changePtr( char<em>&amp;  ref_ptr )<br>{<br>    ref_ptr = (char</em>)malloc(100*sizeof(char));<br>}<br>就可以直接使用引用来修改实参指针所指向的位置，也就相当于用指针本身修改指针所指向的位置。</p><p>(当然前提不是指针常量） </p></blockquote><h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><p>C/S模式</p><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><p>B/S模式</p><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><p>优缺点： 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。 因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏英雄联盟。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。 C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。<br>B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。 B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。 因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。 </p><h3 id="程序编译的四个阶段"><a href="#程序编译的四个阶段" class="headerlink" title="程序编译的四个阶段"></a>程序编译的四个阶段</h3><p>1.编译过程的四个阶段</p><p>源程序到目标程序执行的四个阶段如图1所示，GCC编译C源代码有四个步骤：预处理—-&gt;编译—-&gt;汇编—-&gt;链接。 <img src="/2019/09/16/面经分析-20190916/E:/PersonalBlog\source\_posts\面经分析-20190916\a4e1812cccfc18f484cc5b34fc1f853.png" alt="a4e1812cccfc18f484cc5b34fc1f853"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">以源程序hello.c为例</span><br><span class="line"></span><br><span class="line">#include intmain()&#123;printf(&quot;happy new year!\n&quot;);return0;&#125;</span><br><span class="line"></span><br><span class="line">2.预处理阶段（.c—.i）</span><br><span class="line"></span><br><span class="line">编译器将C程序的头文件编译进来，还有宏的替换，可以用gcc的参数-E来参看。</span><br><span class="line"></span><br><span class="line">命令：unix&gt;gcc –o hello hello.c </span><br><span class="line"></span><br><span class="line">作用：将hello.c预处理输出hello.i</span><br><span class="line"></span><br><span class="line">3 编译（.i—.s）转换为汇编语言文件</span><br><span class="line"></span><br><span class="line">这个阶段编译器主要做词法分析、语法分析、语义分析等，在检查无错误后后，把代码翻译成汇编语言[2]。可用gcc的参数-S来参看。 </span><br><span class="line"></span><br><span class="line">编译器(ccl)将文本文件hello.i 翻译成文本文件hello.s, 它包含一个汇编语言程序。 </span><br><span class="line"></span><br><span class="line">一条低级机器语言指令。 </span><br><span class="line"></span><br><span class="line">命令：gcc -S hello.i -o hello.s </span><br><span class="line"></span><br><span class="line">作用：将预处理输出文件hello.i汇编成hello.s文件</span><br><span class="line"></span><br><span class="line">4.汇编阶段（.s—.o）得到机器语言</span><br><span class="line"></span><br><span class="line">汇编器as 将hello.s 翻译成机器语言保存在hello.o 中（二进制文本形式）。</span><br><span class="line"></span><br><span class="line">5.链接阶段</span><br><span class="line"></span><br><span class="line">printf函数存在于一个名为printf.o的单独预编译目标文件中。必须得将其并入到hello.o的程序中，链接器就是负责处理这两个的并入，结果得到hello文件，它就是一个可执行的目标文件。</span><br></pre></td></tr></table></figure><h3 id="浏览器多进程架构"><a href="#浏览器多进程架构" class="headerlink" title="浏览器多进程架构"></a>浏览器多进程架构</h3><p>跟现在的很多多线程浏览器不一样，Chrome浏览器使用多个进程来隔离不同的网页。因此在Chrome中打开一个网页相当于起了一个进程</p><h4 id="那么Chrome为什么要使用多进程架构"><a href="#那么Chrome为什么要使用多进程架构" class="headerlink" title="那么Chrome为什么要使用多进程架构?"></a>那么Chrome为什么要使用多进程架构?</h4><p>在浏览器刚被设计出来的时候，那时的网页非常的简单，每个网页的资源占有率是非常低的，因此一个进程处理多个网页时可行的。然后在今天，大量网页变得日益复杂。把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战。因为如果浏览器中的<code>一个tab网页崩溃的话，将会导致其他被打开的网页应用</code>。另外相对于线程，进程之间是不共享资源和地址空间的,所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源,所以会存在<code>线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。</code></p><p>在了解这个知识点线，我们需要先说明下什么是<code>浏览器内核</code>。</p><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。</p><h4 id="浏览器内核是多线程"><a href="#浏览器内核是多线程" class="headerlink" title="浏览器内核是多线程"></a>浏览器内核是多线程</h4><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><ul><li>GUI 渲染线程</li><li>JavaScript引擎线程</li><li>定时触发器线程</li><li>事件触发线程</li><li>异步http请求线程</li></ul><h3 id="select，poll，epoll"><a href="#select，poll，epoll" class="headerlink" title="select，poll，epoll"></a>select，poll，epoll</h3><blockquote><p>当有多个流时，可以考虑用轮训的方式<strong>逐一查看每个流目前是否有数据</strong>，若有，则进行处理。（非阻塞忙轮询－－一直主动查看流的状态）</p><p>缺点：cpu空耗在无用的流缓冲区检查上，浪费时间。</p><p>改进：引入一个代理人（select），<strong>当代理人感知到有一个或多个流的数据有变化时，再进行轮询检查</strong>。（非阻塞轮询－－有流的状态发生变化时，主动检查所有流的状态）</p><p>缺点：当只有一个或少数流有更新时，遍历检查所有的流非常浪费时间。（故，亦称为无差别轮询）</p><p>改进：当有流的状态改变时，仅处理该流相关的数据变化。（epoll－－event poll，事件轮询，精确到“什么流”发生了“什么事件”）</p><p>具体实现是引入了一个红黑树及一个就绪列表。</p><p>epoll的关键操作：</p><p>1、创建一个epoll对象</p><p>epollfd=epoll_create()</p><p>此时，会在内核中专属于epoll的高速cache区新建一棵红黑树以及一个就绪列表。</p><p>2、往epoll中添加或删除<strong>某个流</strong>的<strong>某个事件</strong></p><p>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN)</p><p>epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT)</p><p>“add”动作会将文件句柄（socket）加入到红黑树中，并向内核注册改句柄的回调函数，当内核检测到该句柄可读或可写时（由中断触发），就将该句柄对应的回调函数加入到就绪列表中。</p></blockquote><p>在讨论epoll的实现细节之前，先把epoll的相关操作列出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">epoll_create 创建一个epoll对象，一般epollfd = epoll_create()</span><br><span class="line"></span><br><span class="line">epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line"></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);<span class="comment">//注册缓冲区非空事件，即有数据流入</span></span><br><span class="line"></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);<span class="comment">//注册缓冲区非满事件，即流可以被写入</span></span><br><span class="line"></span><br><span class="line">epoll_wait(epollfd,...)等待直到注册的事件发生</span><br><span class="line"></span><br><span class="line">（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回<span class="number">-1</span>，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。</span><br><span class="line"></span><br><span class="line">一个epoll模式的代码大概的样子是：</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">    active_stream[] = epoll_wait(epollfd)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in active_stream[] &#123;</span><br><span class="line"></span><br><span class="line">         read <span class="keyword">or</span> write till</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次读懂 Select、Poll、Epoll IO复用技术</p><p><a href="https://baijiahao.baidu.com/s?id=1611547498841608701&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1611547498841608701&amp;wfr=spider&amp;for=pc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网易互娱&quot;&gt;&lt;a href=&quot;#网易互娱&quot; class=&quot;headerlink&quot; title=&quot;网易互娱&quot;&gt;&lt;/a&gt;网易互娱&lt;/h2&gt;&lt;p&gt;原帖&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面经分析-20190915</title>
    <link href="http://yoursite.com/2019/09/15/%E9%9D%A2%E7%BB%8F%E5%88%86%E6%9E%90-20190915/"/>
    <id>http://yoursite.com/2019/09/15/面经分析-20190915/</id>
    <published>2019-09-15T02:22:34.000Z</published>
    <updated>2019-09-15T03:45:04.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-语言基础"><a href="#C-C-语言基础" class="headerlink" title="C/C++语言基础"></a>C/C++语言基础</h2><p><strong>C++相对于C语言的优点：</strong></p><ul><li>面向对象，把数据和操作绑定在一起，函数调用的时候看起来比较清晰</li><li>运算符重载</li><li>内存管理相比C好一些，比如可以用std：string</li><li>库相比C多一些（比如stl）</li><li>可以写工具类在多个项目中使用（比如计算程序运行时间的类，比如读写某个位置的文件）</li></ul><p><strong>面向对象的三大特征：</strong></p><ul><li><p>封装</p></li><li><p>多态</p><blockquote><ul><li>静态多态： 编译期间就可以确定调用那个函数，比如函数重载</li><li>动态多态：在运行时确定调用那个函数，比如虚函数</li></ul></blockquote></li><li><p>继承</p></li></ul><p><strong>extern关键字作用：</strong></p><ul><li>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义</li><li>extern C 表示按C语言的规则编译</li></ul><p><strong>static关键字作用：</strong></p><p> static修饰局部变量</p><blockquote><ul><li>静态局部变量存储在静态区</li><li>生存期为整个程序生命周期，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</li><li>静态局部变量若在声明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。</li></ul></blockquote><p>static修饰全局变量</p><blockquote><ul><li>非静态全局变量的作用域是整个源程序，也即在各个源文件中都是有效的。</li><li>而静态全局变量则只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它</li></ul></blockquote><p>static 函数</p><blockquote><ul><li>static的含义是指对函数的作用域仅局限于本文件</li><li>使用静态函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系</li><li>函数中使用static修饰变量：变量存储在全局区，函数退出时变量仍然存在，但是在函数外不能访问。</li></ul></blockquote><p>类中的static关键字</p><blockquote><h3 id="static-数据成员："><a href="#static-数据成员：" class="headerlink" title="static 数据成员："></a>static 数据成员：</h3><ul><li>静态数据成员</li><li>无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问</li><li>在没有产生类的实例时，我们就可以操作它</li><li>静态数据成员存储在全局数据区</li><li>静态数据成员定义时才分配空间，不能在类声明中定义（在全局区定义）</li><li>同全局变量相比，使用静态数据成员有两个优势：<ol><li>静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性</li><li>可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能</li></ol></li></ul><h3 id="static-成员函数："><a href="#static-成员函数：" class="headerlink" title="static 成员函数："></a>static 成员函数：</h3><ul><li>静态成员函数</li><li>无法访问属于类对象的非静态数据成员和非静态成员函数</li></ul></blockquote><p><strong>const的作用：</strong></p><ul><li><p>const修饰变量：变量的值不能改变</p></li><li><p>const修饰指针：</p><blockquote><ul><li>如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量</li><li>如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量</li></ul></blockquote></li><li><p>函数中使用const</p><blockquote><ul><li>const修饰函数参数：表示参数不可变，若参数为引用，可以增加效率，const引用传递和函数按值传递的效果是一样的，但按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效</li><li>const 修饰函数返回值：含义和const修饰变量和指针的含义相同</li></ul></blockquote></li><li><p>类中使用const</p><blockquote><ul><li>const修饰成员变量：表示成员变量不能被修改，同时只能在初始化列表中赋值</li><li>const修饰成员函数：该函数不能改变对象的成员变量；不能调用非const成员函数，因为任何非const成员函数会有修改成员变量的企图；const的成员函数才能被一个const类对象调用；const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。</li><li>const修饰类对象： 对象的任何成员都不能被修改；只能调用const成员函数</li></ul></blockquote></li></ul><p><strong>volatile：</strong></p><ol><li>访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为volatile，告诉CPU每次都从内存去读取数据。</li><li>防止编译器对变量的优化</li><li>一个参数可以即是const又是volatile的吗？ 可以</li></ol><p><strong>new与malloc区别：</strong></p><ol><li><p>new分配内存按照数据类型进行分配，malloc分配内存按照大小分配</p></li><li><p>new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。</p></li><li><p>new的实现原理：先通过malloc申请内存空间，然后再调用构造函数</p></li><li><p>new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化；</p></li><li><p>new是一个操作符可以重载，malloc是一个库函数；</p></li><li><p>new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会；</p></li><li><p>malloc分配的内存不够的时候，可以用realloc扩容。new没用这样操作；realloc扩容的原理：如果当前连续内存块足够扩容的话就直接扩容，如果当前内存块不够长就再找一个足够长的地方，分配一块新的内存，将原来的内容复制过来，将原来的内存空间释放。</p></li><li><p>new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</p></li><li><p>new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。</p></li><li><p>隐藏</p><blockquote><ul><li>隐藏指的是子类隐藏了父类的函数</li><li>如果是虚函数则叫覆盖</li></ul></blockquote></li></ol><p><strong>C++多态性与虚函数表：</strong></p><ul><li><p>一个基类指针指向派生类对象，在调用对象虚函数时，就会去查找该对象的虚函数表，虚函数表的地址存放在每个对象的头部位置，在虚函数表中找到对应的虚函数指针，然后进行调用</p></li><li><p>没有虚函数的类里面不会有虚函数表，对于有虚函数表的类，一个类对应一个虚函数表，这个类的所有对象共用这个虚函数表，虚函数表的地址保存在每个对象的头部位置</p></li><li><p>派生类的虚函数表从基类继承过来，如果覆盖了其中的某个虚函数，则虚函数表里面该函数对应的指针被替换</p></li><li><p>虚函数不能是静态成员函数？？，其访问权限可以是protected或public</p></li><li><p>虚函数的作用：实现多态</p></li><li><p><a href="https://www.cnblogs.com/hustdc/p/6485913.html" target="_blank" rel="noopener">动态绑定是如何实现</a></p></li><li><p>纯虚函数</p><blockquote><ul><li>定义的例子：virtual int fun()=0;</li><li>在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化</li><li>这个方法必须在派生类中被实现</li></ul></blockquote></li></ul><p><strong>友元函数：</strong></p><ul><li>类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。</li><li>一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。</li><li>友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。</li><li>友元函数在调用上同一般函数一样，不必通过对对象进行引用。</li><li>友元类：友元类的所有成员函数都是另一个类的友元函数</li></ul><p><strong>为什么对于存在虚函数的类中析构函数要定义成虚函数？</strong></p><p>因为将派生类对象绑定到基类指针上，销毁对象时，如果析构函数没有定义为虚函数，则会调用基类的析构函数，只能销毁基类部分的数据，若要调用派生类的析构函数，则应该将析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数</p><p><strong>析构函数能抛出异常吗？</strong></p><p>不能，如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p><p><strong>构造函数和析构函数中调用虚函数吗？</strong></p><p>不能，构造函数或者析构函数中调用虚函数并不会发挥虚函数动态绑定的特性，即使在构造函数或者析构函数中成功调用了虚函数，程序的运行结果也是不可控的（在基类中调用了派生类的函数）</p><p><strong>指针和引用的区别：</strong></p><ul><li>指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问；</li><li>指针可以改变地址，从而改变所指的对象，而引用必须从一而终；</li><li>引用在定义的时候必须初始化，而指针则不需要；</li><li>指针可以为空，引用不能为空</li><li>可以有const指针，没有const引用</li></ul><p><strong>智能指针：</strong></p><ul><li>智能指针是一个类，原理是RAII(构造时获取资源，析构时释放资源）</li><li>使用智能指针需要include<memory></memory></li><li>使用智能指针是为了解决内存泄漏和野指针这两个问题：</li></ul><p>野指针：未初始化或未清零的指针</p><p> 形成野指针的原因：</p><blockquote><ul><li>指针变量没有被初始化 </li><li>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针(浅拷贝）</li></ul></blockquote><p>内存泄漏：动态开辟的空间，在使用完毕后未释放，内存泄漏是资源泄漏中的一种，资源泄漏的另外一种是句柄泄漏</p><p>句柄泄漏：</p><blockquote><p>举个例子，socket句柄泄漏：B多次尝试连接A，每一次重连使用一个socket id ,当C连接B的时候，B没有了可用的socket id，所以B拒绝服务，解决问题的方法是：在B每次重连A的时候，调用系统提供的close()函数，把已经断开连接的socket的socket id释放</p></blockquote><ul><li><p>auto_ptr</p><blockquote><ul><li>解决了内存泄漏问题和浅拷贝导致的野指针问题</li><li>get()得到原始指针</li><li>reset(参数)重新绑定指向对象，原来的对象被释放(如果不带参数，则释放资源）</li><li>release()把智能指针赋值为空，但是它原来指向的内存并没有被释放</li><li>auto_ptr的成员函数时用的是“.”，访问指向对象的成员时用的是“-&gt;”</li><li>存在的问题：所有权转移（赋值或复制）；对智能指针进行赋值时，如ptest2 = ptest，ptest2会接管ptest原来的内存管理权，ptest会变为空指针，如果ptest2原来不为空，则它会释放原来的资源；多个auto_ptr不能同时拥有同一个对象；Test *t1 = new Test(3); auto_ptr<test> ptr1(t1); auto_ptr<test> ptr2(t1);这里ptr1与ptr2都认为指针t1是归它管的，在析构时都试图删除t1，这样就造成了重复释放问题；不能用auto_ptr管理数组指针，auto_ptr的析构函数中删除指针用的是delete,而不是delete []；不能在stl中使用，p1=p2,使p2为空，这样会使得stl容器里很多元素为空</test></test></li></ul></blockquote></li></ul><p><strong>C++ 11标准中出现的新智能指针：</strong></p><ul><li>unique_ptr</li></ul><blockquote><ul><li>auto_ptr中的函数仍可用</li><li>move()可以将所有权由一个unique_ptr对象转移到另一个unique_ptr对象</li><li>禁止赋值和复制：同一时刻只能有一个unique_ptr实例指向给定对象。拷贝构造函数以及等号（“=”）是无法使用的</li><li>可以管理数组指针：因为unique_ptr有unique_ptr&lt; X[ ] &gt;重载版本，销毁动态对象时调用delete[]，所以可以用unique_ptr来管理数组指针</li><li>可以在stl容器中使用：因为禁止了赋值和复制</li></ul></blockquote><ul><li><p>shared_ptr</p><blockquote><ul><li>shared_ptr是共享所有权的，其内部有一个计数机制</li><li>默认使用delete实现资源释放，也可以定义自己的函数来释放，自定义释放的方法有两种：<ul><li>lambda表达式（匿名的局部函数）</li><li>括号操作符的重载 </li></ul></li><li>shared_ptr对象的引用是强引用<ul><li>强引用：对象被创建时，计数为1；每创建一个变量引用该对象时，该对象的计数就增加1；当上述变量销毁时，对象的计数减1，当计数为0时，这个对象也就被析构了</li><li>弱引用：弱引用不修改对象的引用计数，它只是检测所管理的对象是否已经被释放</li></ul></li><li>存在的问题<ul><li>多个独立的shared_ptr实例不能共享一个对象（不能将一个对象绑定到多个智能指针，可以共享所有权，通过=实现），因为可能会重复释放</li><li>循环引用问题：会造成内存泄漏</li><li>this指针的问题：类的一个成员函数需要传递其this指针到一个普通函数，类的对象在主函数里会绑定到一个智能指针，在传递this的时候又绑定了一个智能指针，这样会造成重复释放。</li></ul></li></ul></blockquote></li><li><p>weak_ptr</p><blockquote><ul><li>解决shared_ptr的循环引用和this指针的问题：<ul><li>循环引用类里面的shared_ptr改成weak_ptr</li><li>this指针用weak_ptr绑定后通过weak_ptr的lock()来获取shared_ptr</li></ul></li><li>不具有普通指针的行为，它的作用在于协助shared_ptr工作，被设计为与shared_ptr共同工作</li><li>weak_ptr对象的引用是弱引用</li><li>weak_ptr观测资源，但没有共享资源，不会修改引用计数</li><li>use_count()：观测资源的引用计数 </li><li>expired()：等价于use_count()==0，但更快 </li><li>lock()：获取shared_ptr，当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr </li></ul></blockquote></li></ul><p><strong>private protected public区别：</strong></p><ul><li>private：只能由本类中的函数，友元函数访问</li><li>protected：可以被本类中的函数，子类的函数，友元函数访问</li><li>public ： 可以被本类函数，子类的函数，类对象，友元函数访问</li><li>private属性不能被继承</li><li>使用private继承，父类中protected , public属性变成private</li><li>使用protected继承，父类中的protected，public属性变成protected</li><li>使用public继承，父类中的属性在子类中不变</li></ul><p><strong>CPP内存空间：</strong></p><ul><li>栈：由编译器分配和释放，存放函数的参数值，局部变量的值。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用</li><li>堆：由程序员分配和释放，若程序员不释放，则程序结束时被OS回收。存放由new，malloc分配的内存，可动态扩展和收缩</li><li>全局区（静态区）：全局变量和静态变量的存储是放在一起的，初始化的全局变量和初始化的静态变量在一块区域；未初始化的全局变量和未初始化的静态变量在相邻的另一块区域</li><li>文字常量区：常量字符串放在这里，程序结束后由系统释放</li><li>程序代码区：存放函数的二进制代码</li></ul><p><strong>堆和栈的区别：</strong></p><ol><li>栈由编译器管理，堆由程序员控制</li><li>堆会产生碎片，栈不会产生碎片</li><li>堆是向上（内存增加的方向）生长的，栈是向下生长的</li><li>左值和右值：左值既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)；左值是指表达式结束后依然存在的持久对象，而右值是指表达式结束时就不再存在的临时对象</li></ol><p><strong>动态链接库和静态链接库：</strong></p><ul><li>静态链接：在编译链接的时候将引用库文件和自己的文件一起打包成可执行文件，windows下是文件名后缀是.lib,linux下是.a</li><li>动态链接：是在程序运行时才被载入，windows文件名后缀是下是.dll,linux下是 .so</li></ul><p><strong>explicit：</strong></p><p>声明为explicit的构造函数不能在隐式转换中使用</p><p><a href="https://blog.csdn.net/breaksoftware/article/details/54894444" target="_blank" rel="noopener">隐式转换</a></p><p><strong>C++四种类型转换</strong></p><p><strong>内存对齐的原则</strong></p><p><strong>数组和指针</strong></p><p><strong>内联函数有什么优点？内联函数与宏定义的区别？</strong></p><ol><li>宏定义在预编译的时候就会进行宏替换；</li><li>内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。</li><li>内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。</li><li>使用宏定义函数要特别注意给所有单元都加上括号，#define MUL(a, b) a b，这很危险，正确写法：#define MUL(a, b) ((a) (b))</li></ol><p><strong>C++内存管理：</strong></p><p><strong>检查内存泄漏：</strong></p><p>Windows下在debug模式下用CRT库</p><blockquote><p>内存分配要通过CRT在运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏，通过包括 crtdbg.h，将malloc和 free函数映射到它们的调试版本，即 _malloc_dbg和 _free_dbg，这两个函数将跟踪内存分配和释放。 此映射只在调试版本（在其中定义了_DEBUG）中发生。 发布版本使用普通的 malloc和 free函数。</p></blockquote><p>Linux下用valgrind工具    </p><p><strong>lambda表达式</strong></p><p>匿名函数：<a href="int b">int a</a>{} :a是在函数内可以访问的外部变量，b是函数参数，可以通过在函数后面用()传入参数如:<a href="int a"></a>{cout&lt;&lt;a&lt;&lt;endl;}(123)</p><p><strong>STL：</strong></p><ul><li><a href="https://blog.csdn.net/liar771/article/details/54379624" target="_blank" rel="noopener">容器及迭代器使用</a></li><li><a href="https://blog.csdn.net/xgf415/article/details/52947454" target="_blank" rel="noopener">算法使用</a></li><li><a href="https://blog.csdn.net/Dawn_sf/article/details/77929225" target="_blank" rel="noopener">迭代器原理</a></li><li>hash_map比map查找速度快，但是比map需要的内存多，是一种用空间换时间的做法</li><li><a href="https://blog.csdn.net/ls1627550352/article/details/52760693" target="_blank" rel="noopener">hash_map使用</a></li></ul><p><strong>必须在构造函数初始化列表里进行初始化的数据成员有哪些：</strong></p><ol><li>const成员</li><li>引用类型</li><li>没有默认构造函数的</li></ol><p><strong>构造函数中赋值和初始化列表赋值的区别：</strong></p><ol><li>构造函数中赋值，先调用默认构造函数，再调用拷贝构造函数</li><li>初始化列表只调用一次拷贝构造函数赋值</li></ol><p><strong>手写strcpy：</strong></p><blockquote><p>char <em> strcpy( char </em>strDest, const char <em>strSrc )<br>{<br> assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) );<br>if(strlen(strDest)&lt;strlen(strSrc))<br>return NULL; //​​标准的strcpy函数没有此判断<br> char </em>address = strDest;  ​<br> while( (<em>strDest++ = </em> strSrc++) != ‘\0’ );<br>​*strDest=’\0’; //标准的strcpy函数没有此操作<br> return address;<br>}</p></blockquote><p><strong>i++和++i</strong></p><blockquote><ul><li>i++是先把i的值拿来用,然后在自增1</li><li>++i是想把i自增1然后拿来用</li></ul></blockquote><p><strong>跨平台技术有哪些：</strong></p><ul><li>代码转换：将某个语言转成另一种语言（比如将java转成c）</li><li>编译流：将某个语言编译为二进制文件，生成动态库或打包成 apk/ipa/xap 文件</li><li>虚拟机：通过将某个语言的虚拟机移植到不同平台上来运行</li></ul><p><strong>链式操作：</strong></p><p>利用运算符进行的连续操作，如连续的赋值，连续的相加</p><p><strong>运算符优先级</strong></p><p><a href="https://blog.csdn.net/caimouse/article/details/78833505" target="_blank" rel="noopener">to_string()</a></p><p><strong>将引用作为函数返回值要注意的地方：</strong></p><blockquote><ul><li>不能返回局部变量，因为局部变量在栈里面创建，函数调用完就会被释放，所引用的地址就没有了</li><li>不能返回new分配的内存的引用，因为new了以后没有delete会造成内存泄漏</li></ul></blockquote><p><strong>返回引用的好处：</strong>可以实现连续的输入输出赋值等操作（链式操作）</p><p>include&lt;&gt;和include“”</p><blockquote><p>include&lt;&gt;去编译器的类库路径里面找头文件，include””先在项目的当前路径里面找头文件，如果没找到再去编译器的类库路径里面找。</p></blockquote><p>struct和class的区别</p><blockquote><ul><li>struct默认是public的，class默认是private的</li><li>struct 能包含成员函数吗，能继承吗，能多态吗？都能</li></ul></blockquote><p>ifndef/define/endif作用</p><blockquote><p>防止重复包含头文件和重复定义宏</p></blockquote><p><strong>C++11新特性</strong></p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p>这部分内容很多一定要多刷牛客</p><p><a href="https://blog.csdn.net/u011240877/article/details/52940469" target="_blank" rel="noopener">Hash表</a></p><p><a href="https://blog.csdn.net/u014465639/article/details/71076092" target="_blank" rel="noopener">二叉树遍历(递归和非递归）</a></p><p><a href="https://blog.csdn.net/u011240877/article/details/53242179" target="_blank" rel="noopener">二叉查找树</a></p><p><a href="https://blog.csdn.net/skyroben/article/details/72824146" target="_blank" rel="noopener">平衡树</a></p><blockquote><ul><li>高度平衡的二叉搜索树</li><li>左子树和右子树的高度差不超过1</li><li>左子树和右子树都是平衡树</li></ul></blockquote><p><a href="https://blog.csdn.net/yangyutong0506/article/details/78204953" target="_blank" rel="noopener">红黑树</a></p><blockquote><ul><li><a href="https://blog.csdn.net/gao1440156051/article/details/51581394" target="_blank" rel="noopener">常见问题</a></li><li>结点要么是红色要么是黑色</li><li>根结点永远是黑色</li><li>所有叶子结点都是红色</li><li>红色结点的两个孩子结点都是黑色</li><li>任意一个结点到其子树的任意一个叶子结点所经过的黑结点数目是一样的</li></ul></blockquote><p><a href="https://blog.csdn.net/wsyw126/article/details/61416055" target="_blank" rel="noopener">Trie树（字典树）</a></p><p><a href="https://blog.csdn.net/lili0710432/article/details/48142791" target="_blank" rel="noopener">海量数据问题</a></p><p><a href="https://blog.csdn.net/lili0710432/article/details/48142791" target="_blank" rel="noopener">top(k)</a></p><p><a href="https://blog.csdn.net/ywcpig/article/details/52495553" target="_blank" rel="noopener">排序算法</a></p><ul><li></li><li><img src="http://www.pianshen.com/images/167/5293bb4e17fce95b82850f2a1a39218f.png" alt="img"></li></ul><p><strong>位运算：</strong></p><blockquote><ul><li>按位取反~  翻转操作数的每一位 每个 1 被设置为 0 而每个 0 被设置为 1。~y=-y-1</li><li>^异或（模2加）</li><li>左移操作符 &lt;&lt; :从右边开始用 0 补空位 </li><li>右移操作符 &gt;&gt; :从左边开始,或者插入符号位的拷贝 或者插入 0</li><li>按位与&amp;</li><li>按位异或^</li><li>按位或 |</li><li>优先级：移位符高于逻辑符</li></ul></blockquote><p>最大子串问题</p><blockquote><p>#include<iostream><br>#include<string><br>#include<map><br>#include<algorithm><br>using namespace std;<br>int longstr(string s){<br>      int len=s.size();<br> int pre=0;<br> int max=0;<br> map&lt;char,int&gt; m;<br>    int i;<br>for(i=0;i&lt;len;i++){<br>if(m.find(s[i])!=m.end()){<br>               pre=m[s[i]]+1;<br>}<br>m[s[i]]=i;<br>if(max&lt;(i-pre+1))<br>max=i-pre+1;<br>}<br>return max;<br>}<br>int main(){<br>    string s;<br>cin&gt;&gt;s;<br>cout&lt;&lt;longstr(s)&lt;&lt;endl;<br>return 0;<br>}</algorithm></map></string></iostream></p></blockquote><p><a href="https://blog.csdn.net/u010352111/article/details/53980062" target="_blank" rel="noopener">最大公共子序列</a></p><p><a href="https://blog.csdn.net/pp634077956/article/details/48270089" target="_blank" rel="noopener">各个点之间最短路</a></p><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组逆序对，归并排序解决</a></p><p><a href="https://blog.csdn.net/yanerhao/article/details/72848524" target="_blank" rel="noopener">Bit-map</a></p><p><a href="http://www.cppblog.com/ylfeng/archive/2010/03/26/110592.html" target="_blank" rel="noopener">stl里面的bitset用法</a></p><p>位图，是实现海量数据处理的常用的方法，用一位表示一个数据（1出现，0没出现）</p><p>兔子繁殖</p><blockquote><ul><li>斐波那契数列</li><li>这个月的兔子等于上个月兔子的数量加上上个月可繁殖的兔子（即上上个月的兔子）数量。</li><li>f(n)=f(n-1)+f(n-2)</li></ul></blockquote><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="网络与TCP-IP"><a href="#网络与TCP-IP" class="headerlink" title="网络与TCP/IP"></a>网络与TCP/IP</h2><p><a href="https://blog.csdn.net/shanghairuoxiao/article/details/68927070" target="_blank" rel="noopener">TCP与UDP之间的区别</a></p><p><a href="https://blog.csdn.net/wbj217/article/details/73903116" target="_blank" rel="noopener">TCP</a></p><p>为什么是三次握手不是两次？</p><blockquote><p>服务端验证客户端能收到自己的信息</p></blockquote><p><a href="https://blog.csdn.net/china_jeffery/article/details/78923428" target="_blank" rel="noopener">UDP</a></p><p><a href="https://blog.csdn.net/qq_33301113/article/details/73368659" target="_blank" rel="noopener">HTTP</a></p><p><a href="https://blog.csdn.net/jeffasd/article/details/60140344" target="_blank" rel="noopener">http头部信息</a></p><p><a href="https://blog.csdn.net/u014044812/article/details/79571927" target="_blank" rel="noopener">https</a></p><p>cookie和session</p><blockquote><ul><li>cookie存放在客户端，session存放在服务器端，都是用于会话跟踪<ul><li>浏览器第一次访问服务器，服务器创建一个session，并将session id返回给浏览器，浏览器将其保存在cookie里面</li><li>cookie用来保存用户信息（如账号密码）及实现session（保存session id，每次访问服务器的时候都带上这个session id），要是浏览器禁用了cookie则通过url重写技术来跟踪会话（url后面被附加上一个诸如 sid=xxxxx 这样的参数）</li><li>session用来识别用户</li><li>Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session理论上没有大小限制（服务器端保存session的方法很多：比如内存，数据库，文件）</li><li>Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。session保存在服务器安全一点</li><li>Session保存在服务器端一段时间后会消失，如果session过多会增加服务器的压力，cookie有效期为正数则为持久化cookie，写入对应的cookie文件无论用户关闭了浏览器还是电脑，只要在有效期之前cookie都是有效的，若cookie有效期为负数则为临时cookie，只在本窗口及本窗口子窗口有效，关闭浏览器cookie就消失，默认cookie有效期是-1</li></ul></li></ul></blockquote><p>OSI模型中ARP协议属于链路层；TCP/IP模型中，ARP协议属于网络层</p><p><strong>浏览器中输入一个URL发生什么：</strong></p><blockquote><ul><li>首先在应用层进行DNS解析，先从本地DNS缓存找，如果没有找到就访问DNS服务器（递归和迭代两种方式）</li><li>用DNS解析出ip以后在应用层发送http请求</li><li>然后在传输层tcp三次握手建立连接，然后传输数据</li><li>在网络层使用IP协议来传输分割好的tcp数据包数据，使用ARP协议根据ip得到mac地址</li><li>找到mac地址后把数据发送到数据链路层进行传输</li><li>接受方在数据链路层收到数据后把数据一层一层的往上传，一直传到应用层</li><li>然后服务器响应请求，返回html文件</li><li>浏览器收到服务器返回的文件以后进行页面渲染</li></ul></blockquote><p><a href="https://blog.csdn.net/qq_26360877/article/details/70665820" target="_blank" rel="noopener">get和post的区别</a></p><p>状态码</p><blockquote><ul><li>1xx表示请求被接受，需要进一步操作</li><li>2xx表示请求成功</li><li>3xx表示需要更多的操作来完成这个请求</li><li>4xx表示请求失败</li><li>5xx表示服务器内部错误</li></ul></blockquote><p>流量控制和拥塞避免的区别</p><blockquote><ul><li>流量控制是控制发送方的发送速度从而使得接收方能正常接收</li><li>拥塞避免是避免过多的流量进入网络造成网络拥堵</li></ul></blockquote><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>SQL语句<ul><li>看MySQL必知必会<ul><li>and 的优先级比 or 要高，其实用的时候加上括号就好了</li><li>使用通配符必须使用like，通配符（%0个或多个字符，_一个字符）</li><li>正则表达式regexp</li><li>\(匹配）</li><li>几乎所有类型的 WHERE 子句都可以用 HAVING 来替代。唯一的差别是WHERE 过滤行，而 HAVING 过滤分组</li><li>外键是另一个表中的主键</li><li>join<ul><li><a href="https://blog.csdn.net/huatian5/article/details/80854455" target="_blank" rel="noopener">https://blog.csdn.net/huatian5/article/details/80854455</a></li><li>inner join 内连接，inner可以省略，两表取交集</li><li>left join 左连接，以左表为基础，返回右表中匹配的行，若右表中没有匹配的行则返回NULL</li><li>right join 右连接，以右表为基础，返回左表中匹配的行，若左表中没有匹配的行则返回NULL</li></ul></li><li>游标是一种从包括多条数据记录的结果集中每次提取一条记录的机制</li></ul></li></ul></li></ul><p><a href="https://blog.csdn.net/zhoushunyu/article/details/77015899" target="_blank" rel="noopener">常用语句</a></p><p><a href="https://blog.csdn.net/znyyjk/article/details/52717336" target="_blank" rel="noopener">语句大全</a></p><p><a href="https://blog.csdn.net/hundan_520520/article/details/54881208" target="_blank" rel="noopener">50道例题</a></p><p>MySQL索引结构</p><blockquote><ul><li>B+树索引</li><li>Hash索引</li><li>B+树索引和Hash索引的区别？<ul><li>Hash索引等值查询效率更高，但是Hash索引不支持范围查询</li></ul></li></ul></blockquote><p>索引</p><blockquote><ul><li>索引可以增加检索性能，同时会降低修改性能</li><li>索引的作用<ol><li>可以大大加快数据的检索速度</li><li>创建唯一性索引，可以保证表中的每一行数据的唯一性</li><li>加速表和表之间的连接</li><li>可以减少查询中分组和排序的时间</li></ol></li><li>索引并不是越多越好<ol><li>创建索引和维护索引要耗费时间，数据量越大耗费的时间越多</li><li>索引需要占用物理空间</li><li>对数据进行维护的时候（增加，删除，修改），索引也要动态维护，这样就降低了数据的维护速度</li></ol></li><li>索引是建立在数据库表的某些列上面的，一般在需要经常搜素的列上创建索引，很少查询的列不创建索引（因为不能明显提高查询的速度，反而还会因为增加了索引降低了维护的速度和增加了空间的需求），需要经常增加，删除，修改操作的列也不适合增加索引</li><li>创建索引 create index</li><li>唯一性索引：索引列中的数据是唯一的</li><li>复合索引：索引创建在两个列或者多个列上</li><li>聚集索引：表记录的排列顺序和与索引的排列顺序一致</li><li>非聚集索引：表记录的排列顺序和与索引的排列顺序不一致</li><li>聚集索引在数据库中开辟一个物理空间存放，非聚集索引看成是一个含有聚集索引的表</li></ul></blockquote><p><strong>InnoDB与MyISAM区别：</strong></p><ol><li>myisam提高了查和增加的效率</li><li>innodb的功能更全面，但相对来说效率低一些</li><li>innodb支持事务支持主键不支持全文索引，myisam不支持事务不支持主键支持全文索引</li><li>myisam使用的是表锁（直接锁定整张表），innodb使用的是行锁（也支持表锁）</li><li>myisam在磁盘上存储成三个文件（.frm文件存储表定义，.MYD是数据文件，.MYI是索引文件；innodb则由.frm文件，表空间和日志文件组成。</li><li>myisam内置了一个计算器存储了表的总行数，innod则没有。</li><li>myisam只把索引load到内存，innodb把索引和数据都load到内存</li></ol><p>什么时候需要用到事务</p><blockquote><ul><li>事务，它是一个操作序列，这些操作要么都执行，要么都不执行</li><li>例如，银行转账工作：从一个账号扣款并使另一个账号增款，这两个操作要么都执行，要么都不执行</li></ul></blockquote><p><strong>事务的基本要素（ACID）</strong>：</p><ul><li>原子性：一个事务中的所有操作要么全都提交成功，要么全都失败回滚</li><li>一致性：从一个一致的状态转到另一个一致的状态</li><li>隔离性：一个事务的做的修改，在提交前对其它事务是不可见的</li><li>持久性：一旦事务提交，所做的修改就会永久保存在数据库中</li></ul><p><strong>事务的四个隔离级别 ：</strong></p><ul><li>未授权读取：一个事务写数据，不允许其他事务写，但允许其他事务读（解决了更新丢失，存在脏读的问题）</li><li>授权读取：一个事务读数据，允许其他事务访问数据，但是未提交的写事务禁止其他事务对该行的访问（解决了脏读的问题，可能出现不可重复读）</li><li>可重复读：事务读的时候禁止其他事务写（但是允许其他事务读），事务写的时候禁止其他事务读写。解决了不可重复读，但是可能出现幻读。幻读：事务在操作的时候进行了两次查询，第二次查询出现了第一次没有的数据或者缺少了第一次出现的数据（其他事务插入或删除数据造成的）。序列化：事务只能一个接一个的执行（问题都解决了，但是性能低）。更新丢失：两个事物对一行数据更新，一个事务对数据的更新把另一个数据对事务的更新给覆盖了。脏读：一个事务读取到了另一个事务未提交的数据</li><li>不可重复读：一个事务对同一行数据读取两次得到不一样的结果</li></ul><p><strong>锁：</strong></p><blockquote><ul><li>共享锁（读锁）：加了读锁，可以读不能写，其他事务还可以对数据对象加读锁但是不能加写锁</li><li>排他锁（写锁）：加了写锁，事务对数据可读可写，但是其他事务不能再加任何锁</li><li>悲观锁：顾名思义，就是很悲观，每次去拿数据都认为别人会修改，所以每次拿数据都会上锁</li><li>乐观锁：顾名思义，就是很乐观，每次去拿数据都认为别人不会修改，所以每次拿数据都不上锁，但是在更新的时候会看一下在这期间有没有人更新过这个数据，如果发现有人修改就会返回错误信息，让用户决定如何处理。</li></ul></blockquote><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="Linux及操作系统知识"><a href="#Linux及操作系统知识" class="headerlink" title="Linux及操作系统知识"></a>Linux及操作系统知识</h2><p>进程：是程序关于某个数据集合上的一次运行</p><p>线程：是进程的一个实体，是进程的一个执行单位</p><p><strong>进程与线程区别：</strong></p><ol><li>进程有自己独立的地址空间和资源，而线程没有，线程必须依赖于进程而存在</li><li>进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源</li><li>进程是系统资源分配的单位，线程是CPU调度的单位</li><li>线程是进程的执行单元</li><li>一个程序至少有一个进程，一个进程至少有一个线程</li><li>一个线程只属于一个进程，一个进程可以拥有多个线程</li><li>进程切换的开销较大。线程相对较小</li><li>线程间栈和寄存器不能共享，堆和全局变量以及局部变量都可以共享</li></ol><p><strong>线程比进程具有哪些优势？</strong></p><p><strong>什么时候用多进程？什么时候用多线程？</strong></p><p> <strong>Linux中进程和线程使用的函数？</strong></p><p><strong>线程同步方法</strong></p><blockquote><ul><li>临界区：保证每次只能有一个线程进入临界区，在几种同步处理中，临界区速度最快，但它只能实现同进程中的多个线程同步。c++11并没有为我们提供临界区类</li><li>互斥量：mutex支持多进程。c++11标准库中提供了mutex类</li><li>信号量（pv操作）：p操作（申请资源）v操作（释放资源）</li><li>事件（windows里面）<ul><li>创建事件</li><li>等待事件被触发</li><li>WaitForSingleObject(aEvent ,3000);意思就是当代码执行到这的时候，就会在此处阻塞着，直到另外一个线程里触发这个事件后或者等待超时后，才会继续往下执行</li></ul></li></ul></blockquote><p><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278" target="_blank" rel="noopener">进程间通讯方式</a></p><p>共享文件映射</p><p>常见的信号有哪些</p><p>内存管理</p><p> 虚拟内存</p><p>操作系统层面对内存的管理</p><p>内存池的作用</p><p>STL里内存池如何实现</p><p>进程空间和内核空间对内存的管理不同</p><p> Linux的slab层,VAM</p><p>伙伴算法</p><p>高端内存</p><p>进程调度</p><p>死锁：多个线程因竞争资源而造成的一种僵局</p><blockquote><p>发生的原因：</p><ul><li>系统资源不足</li><li>资源分配不当</li><li>线程间推进的顺序不当</li></ul><p>死锁发生的条件</p><ul><li>资源独占：一段时间内资源只能被一个进程占有</li><li>保持申请：进程在占有资源的情况下还能继续申请其它资源</li><li>不可剥夺：申请者不能强行从占有者手里剥夺资源</li><li>循环等待：p1等p2，p2等p3………………..pn等p1</li></ul></blockquote><p><a href="https://blog.csdn.net/qq_38663729/article/details/80058980" target="_blank" rel="noopener">死锁的避免</a></p><p>死锁检测？</p><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><ul><li><p>IO模型</p></li><li><p>线程池</p></li><li><p>fork与vfork区别</p></li><li><p>exit()与_exit()区别</p></li><li><p>孤儿进程与僵尸进程</p></li><li><p>Linux是如何避免内存碎片的</p></li><li><p>共享内存的实现原理</p></li><li><p>同步方法有哪些</p></li><li><p>++i是否是原子操作</p><blockquote><p>明显不是，++i主要有三个步骤，把数据从内存放在寄存器上，在寄存器上进行自增，把数据从寄存器拷贝会内存，每个步骤都可能被中断。 </p></blockquote></li><li><p>判断大小端</p></li><li><p><a href="https://blog.csdn.net/xiaofei0859/article/details/53202273" target="_blank" rel="noopener">epoll和select，poll</a></p></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>单例模式</p><blockquote><p>class A{<br>private:<br>A(){a};<br>static A<em> a;<br>public:<br>static A</em> getA(){<br>if(a==NULL)<br>a=new A();<br>return a;​​<br>​​}​<br>​​}</p></blockquote><p>一个类只有一个实例（比如windows的任务管理器，无论你打开多少次，始终显示一个窗口）</p><p>工厂模式</p><p>STL里的迭代器使用了迭代器模式 </p><p>MVC的理解</p><p>分布式系统</p><blockquote><ul><li>map_reduce原理</li><li>负载均衡</li><li>CDN </li></ul></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h2 id="收集的帖子"><a href="#收集的帖子" class="headerlink" title="收集的帖子"></a>收集的帖子</h2><ul><li><a href="https://blog.csdn.net/notOnlyRush/article/details/80045025" target="_blank" rel="noopener">常见算法</a></li><li><a href="https://www.jianshu.com/p/3427b2bee081" target="_blank" rel="noopener">Linux后台C++学习之路</a></li><li><a href="https://www.nowcoder.com/discuss/59394?type=0&amp;order=0&amp;pos=25&amp;page=1" target="_blank" rel="noopener">C++后台常见知识点</a></li><li><a href="https://www.nowcoder.com/discuss/66985" target="_blank" rel="noopener">知识点总结（包括剑指offer和LeetCode题解）</a></li><li><a href="https://www.nowcoder.com/discuss/97181" target="_blank" rel="noopener">知识点总结</a></li></ul><h1 id="-3"><a href="#-3" class="headerlink" title="======================="></a>=======================</h1><h1 id="-4"><a href="#-4" class="headerlink" title="======================="></a>=======================</h1><h1 id="C-后台开发面试常见问题汇"><a href="#C-后台开发面试常见问题汇" class="headerlink" title="C++后台开发面试常见问题汇"></a>C++后台开发面试常见问题汇</h1><h1 id="C和C-语言基础"><a href="#C和C-语言基础" class="headerlink" title="C和C++语言基础"></a>C和C++语言基础</h1><ul><li><p><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html" target="_blank" rel="noopener"><strong>extern关键字作用</strong></a></p><ol><li>extern声明变量在在外部定义？ </li><li>extern修饰函数？ </li><li>extern C的作用？用法？ </li></ol></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/72904292" target="_blank" rel="noopener"><strong>static关键字作用</strong></a></p><ol><li>static修饰局部变量？ </li><li>static全局变量？(限定变量在一个编译单元内，一个编译单元就是指一个cpp和它包含的头文件，这个回答可以结合编译需要经历的几个过程来答) </li><li>static修饰普通函数？ </li><li>static修饰成员变量? </li><li>static修饰成员函数？ </li></ol></li><li><p><strong>volatile是干啥的</strong></p><ol><li>访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为volatile，告诉CPU每次都从内存去读取数据。 </li><li>一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他。 </li></ol></li><li><p><strong>说说const的作用，越多越好</strong></p><ol><li>const修饰全局变量； </li><li>const修饰局部变量； </li><li>const修饰指针，const int *； </li><li>const修饰指针指向的对象, int * const； </li><li>const修饰引用做形参； </li><li>const修饰成员变量，必须在构造函数列表中初始化； </li><li>const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变 </li></ol></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/70337890" target="_blank" rel="noopener"><strong>new与malloc区别</strong></a></p><ol><li>new分配内存按照数据类型进行分配，malloc分配内存按照大小分配； </li><li>new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。new的实现原理？但是还需要注意的是，之前看到过一个题说int <em>p = new int与int</em> p = new int()的区别，因为int属于C++内置对象，不会默认初始化，必须显示调用默认构造函数，但是对于自定义对象都会默认调用构造函数初始化。翻阅资料后，在C++11中两者没有区别了，自己测试的结构也都是为0； </li><li>new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化； </li><li>new是一个操作符可以重载，malloc是一个库函数； </li><li>new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会； </li><li>malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作； </li><li>new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try…catch语法，而malloc则应该判断指针的返回值。为了兼容很多c程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL； </li><li>new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n； </li><li>如果不够可以继续谈new和malloc的实现，空闲链表，分配方法(首次适配原则，最佳适配原则，最差适配原则，快速适配原则)。delete和free的实现原理，free为什么直到销毁多大的空间？ </li></ol></li><li><p><a href="http://blog.csdn.net/hackbuteer1/article/details/7475622" target="_blank" rel="noopener"><strong>C++多态性与虚函数表</strong></a></p><ol><li>C++多态的实现？<br>多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。<br>动态多态实现有几个条件：<br>(1) 虚函数；<br>(2) 一个基类的指针或引用指向派生类的对象；<br>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。<br>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。<br>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。 </li><li>虚函数的作用？<ol><li>虚函数用于实现多态，这点大家都能答上来 </li><li>但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。 </li></ol></li><li>动态绑定是如何实现的？<br>第一个问题中基本回答了，主要都是结合虚函数表来答就行。</li><li><a href="http://blog.csdn.net/u013630349/article/details/48009815" target="_blank" rel="noopener">静态多态和动态多态</a>。静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译器确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。</li><li><a href="http://blog.csdn.net/haoel/article/details/1948051/" target="_blank" rel="noopener"><strong>虚函数表</strong></a></li><li>虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？</li><li>编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。 </li></ol></li><li><p><strong>纯虚函数如何定义，为什么对于存在虚函数的类中析构函数要定义成虚函数</strong><br>为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，对象销毁时，如果析构函数没有定义为析构函数，则会调用基类的析构函数，显然只能销毁部分数据。如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。</p></li></ul><ul><li><p><strong>析构函数能抛出异常吗</strong><br>答案肯定是不能。</p><blockquote><p>C++标准指明析构函数不能、也不应该抛出异常。C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。</p></blockquote></li></ul><blockquote><p>(1) 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</p><p>(2) 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p></blockquote><ul><li><strong>构造函数和析构函数中调用虚函数吗？</strong></li><li><strong>指针和引用的区别</strong><ol><li>指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问； </li><li>指针可以改变地址，从而改变所指的对象，而引用必须从一而终； </li><li>引用在定义的时候必须初始化，而指针则不需要； </li><li>指针有指向常量的指针和指针常量，而引用没有常量引用； </li><li>指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全多了，但是比较死板。 </li></ol></li><li><strong>指针与数组千丝万缕的联系</strong><ol><li>一个一维int数组的数组名实际上是一个int* const 类型； </li><li>一个二维int数组的数组名实际上是一个int (*const p)[n]; </li><li>数组名做参数会退化为指针，除了sizeof </li></ol></li><li><strong>智能指针是怎么实现的？什么时候改变引用计数？</strong><ol><li>构造函数中计数初始化为1； </li><li>拷贝构造函数中计数值加1； </li><li>赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一； </li><li>析构函数中引用计数减一； </li><li>在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。 </li><li>share_prt与weak_ptr的区别？ </li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">//share_ptr可能出现循环引用，从而导致内存泄露``class` `A``&#123;``public``:``    ``share_ptr p;``&#125;;``class` `B``&#123;``public``:``    ``share_ptr p;``&#125;``int` `main()``&#123;``    ``while``(``true``)``    ``&#123;``        ``share_prt pa(``new` `A()); ``//pa的引用计数初始化为1``        ``share_prt pb(``new` `B()); ``//pb的引用计数初始化为1``        ``pa-&gt;p = pb; ``//pb的引用计数变为2``        ``pb-&gt;p = pa; ``//pa的引用计数变为2``    ``&#125;``    ``//假设pa先离开，引用计数减一变为1，不为0因此不会调用class A的析构函数，因此其成员p也不会被析构，pb的引用计数仍然为2；``    ``//同理pb离开的时候，引用计数也不能减到0``    ``return` `0``;``&#125;``/*``** weak_ptr是一种弱引用指针，其存在不会影响引用计数，从而解决循环引用的问题``*/`</span></span><br></pre></td></tr></table></figure><ul><li><a href="http://www.jellythink.com/archives/205" target="_blank" rel="noopener"><strong>C++四种类型转换</strong></a>：<strong>static_cast, dynamic_cast, const_cast, reinterpret_cast</strong><ol><li>const_cast用于将const变量转为非const </li><li>static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知； </li><li>dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。 </li><li>reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； </li><li>为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 </li></ol></li><li><strong>内存对齐的原则</strong><ol><li>从0位置开始存储； </li><li>变量存储的起始位置是该变量大小的整数倍； </li><li>结构体总的大小是其最大元素的整数倍，不足的后面要补齐； </li><li>结构体中包含结构体，从结构体中最大元素的整数倍开始存； </li><li>如果加入pragma pack(n) ，取n和变量自身大小较小的一个。 </li></ol></li><li><strong>内联函数有什么优点？内联函数与宏定义的区别？</strong><ol><li>宏定义在预编译的时候就会进行宏替换； </li><li>内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。 </li><li>内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。 </li><li>使用宏定义函数要特别注意给所有单元都加上括号，#define MUL(a, b) a <em>b，这很危险，正确写法：#define MUL(a, b) ((a)</em> (b)) </li></ol></li><li><strong>C++内存管理</strong><ol><li>C++内存分为那几块？（堆区，栈区，常量区，静态和全局区） </li><li>每块存储哪些变量？ </li><li>学会迁移，可以说到malloc，从malloc说到操作系统的内存管理，说道内核态和用户态，然后就什么高端内存，slab层，伙伴算法，VMA可以巴拉巴拉了，接着可以迁移到fork()。 </li></ol></li><li><strong>STL里的内存池实现</strong><br>STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池。 </li></ul><p>二级分配器设计的非常巧妙，分别给8k，16k,…, 128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块10K的内存，那么就找到最小的大于等于10k的块，也就是16K，从16K的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。<br>如果要分配的内存大于128K则直接调用一级分配器。<br>为了节省维持链表的开销，采用了一个union结构体，分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示该节点的地址。</p><ul><li><p><strong>STL里set和map是基于什么实现的。红黑树的特点？</strong></p><ol><li>set和map都是基于红黑树实现的。 </li><li>红黑树是一种平衡二叉查找树，与AVL树的区别是什么？AVL树是完全平衡的，红黑树基本上是平衡的。 </li><li>为什么选用红黑数呢？因为红黑数是平衡二叉树，其插入和删除的效率都是N(logN)，与AVL相比红黑数插入和删除最多只需要3次旋转，而AVL树为了维持其完全平衡性，在坏的情况下要旋转的次数太多。<br>红黑树的定义：<br>(1) 节点是红色或者黑色；<br>(2) 父节点是红色的话，子节点就不能为红色；<br>(3) 从根节点到每个页子节点路径上黑色节点的数量相同；<br>(4) 根是黑色的，NULL节点被认为是黑色的。 </li></ol></li><li><p><strong>STL里的其他数据结构和算法实现也要清楚</strong><br>这个问题，把STL源码剖析好好看看，不仅面试不慌，自己对STL的使用也会上升一个层次。</p></li><li><p><strong>必须在构造函数初始化式里进行初始化的数据成员有哪些</strong><br>(1) 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面<br>(2) 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面<br>(3) 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化</p></li><li><p><a href="http://blog.csdn.net/thefutureisour/article/details/7964682/" target="_blank" rel="noopener"><strong>模板特化</strong></a><br>(1) 模板特化分为全特化和偏特化，模板特化的目的就是对于某一种变量类型具有不同的实现，因此需要特化版本。例如，在STL里迭代器为了适应原生指针就将原生指针进行特化。</p></li><li><p><a href="http://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" target="_blank" rel="noopener"><strong>定位内存泄露</strong></a><br>(1)在windows平台下通过CRT中的库函数进行检测；<br>(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置<br>(3)Linux下通过工具valgrind检测</p></li><li><p><strong>手写strcpy</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- <span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>&#123;assert(dst);assert(src);<span class="keyword">char</span>* ret = dst;</span><br><span class="line">  <span class="keyword">while</span>((*dst++ =* src++) != <span class="string">'\0'</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//该函数是没有考虑重叠的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>&#123;assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));<span class="keyword">char</span>* ret = dst;</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">strlen</span>(src) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dst &gt; src || dst &lt; src + len)</span><br><span class="line">&#123;</span><br><span class="line">dst = dst + size - <span class="number">1</span>;</span><br><span class="line">src = src + size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(size--)</span><br><span class="line">&#123;</span><br><span class="line">*dst-- =* src--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(size--)</span><br><span class="line">&#123;</span><br><span class="line">*dst++ =* src++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>手写memcpy函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">if</span>``(pdst &gt; psrc &amp;&amp; pdst &lt; psrc + size) ``<span class="comment">//重叠``&#123;``    ``pdst = pdst + size - ``1``;``    ``psrc = pdst + size - ``1``;``    ``while``(size--)``    ``&#123;``        ``*pdst-- = *psrc--;``    ``&#125;``&#125;``else` `//无重叠``&#123;``    ``while``(size--)``    ``&#123;``        ``*dst++ = *src++;``    ``&#125;``&#125;``return` `ret;`</span></span><br></pre></td></tr></table></figure><ul><li><strong>手写strcat函数</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`- **手写strcat函数**`</span><br></pre></td></tr></table></figure><p><strong>手写strcmp函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`- **手写strcmp函数**`</span><br></pre></td></tr></table></figure><h1 id="数据结构与算法-1"><a href="#数据结构与算法-1" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>这一块考察范围太广，主要靠多刷题吧，牛客网，剑指OFFER，LeetCode等。</p><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/73693458" target="_blank" rel="noopener"><strong>Hash表</strong></a></h3><ul><li><p>Hash表实现（拉链和分散地址） </p></li><li><p>Hash策略常见的有哪些？ </p></li><li><p>STL中hash_map扩容发生什么？</p><p>(1) 创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到$sqrt(n)$范围内的数) ；</p><p>(2) 将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换)</p><p>(3) 通过swap函数将新桶和旧桶交换，销毁新桶。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/73752446" target="_blank" rel="noopener"><strong>树</strong></a></h3></li><li><p>二叉树结构，二叉查找树实现； </p></li><li><p>二叉树的六种遍历； </p></li><li><p>二叉树的按层遍历； </p></li><li><p>递归是解决二叉树相关问题的神级方法； </p></li><li><p>树的各种常见算法题(<a href="http://blog.csdn.net/xiajun07061225/article/details/12760493)；" target="_blank" rel="noopener">http://blog.csdn.net/xiajun07061225/article/details/12760493)；</a> </p></li><li><p>什么是红黑树？</p><ul><li>节点为红色或者黑色； </li><li>根节点为黑色； </li><li>从根节点到每个叶子节点经过的黑色节点个数的和相同； </li><li>如果父节点为红色，那么其子节点就不能为红色。 </li></ul></li><li><p>红黑树与AVL树的区别</p><ul><li>红黑树与AVL树都是平衡树，但是AVL是完全平衡的(平衡就是值树中任意节点的左子树和右子树高度差不超过1)； </li><li>红黑树效率更高，因为AVL为了保证其完全平衡，插入和删除的时候在最坏的情况下要旋转logN次，而红黑树插入和删除的旋转次数要比AVL少。 </li></ul></li><li><p><a href="http://blog.csdn.net/hackbuteer1/article/details/7964147" target="_blank" rel="noopener">Trie树(字典树)</a></p><ul><li><p>每个节点保存一个字符 </p></li><li><p>根节点不保存字符 </p></li><li><p>每个节点最多有n个子节点(n是所有可能出现字符的个数) </p></li><li><p>查询的复杂父为O(k)，k为查询字符串长度</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h3></li></ul></li><li><p>链表和插入和删除，单向和双向链表都要会 </p></li><li><p>链表的问题考虑多个指针和递归</p><p>(1) 反向打印链表(递归)</p><p>(2) 打印倒数第K个节点(前后指针)</p><p>(3) 链表是否有环(快慢指针)等等。b ggg</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a><strong>栈和队列</strong></h3></li><li><p><strong>队列和栈的区别</strong>？(从实现，应用，自身特点多个方面来阐述，不要只说一个先入先出，先入后出，这个你会别人也会，要展现出你比别人掌握的更深) </p></li><li><p>典型的应用场景</p><h3 id="海量数据问题"><a href="#海量数据问题" class="headerlink" title="海量数据问题"></a><strong>海量数据问题</strong></h3></li><li><p>十亿整数（随机生成，可重复）中前K最大的数<br>类似问题的解决方法思路：首先哈希将数据分成N个文件，然后对每个文件建立K个元素最小/大堆（根据要求来选择）。最后将文件中剩余的数插入堆中，并维持K个元素的堆。最后将N个堆中的元素合起来分析。可以采用归并的方式来合并。在归并的时候为了提高效率还需要建一个N个元素构成的最大堆，先用N个堆中的最大值填充这个堆，然后就是弹出最大值，指针后移的操作了。当然这种问题在现在的互联网技术中，一般就用map-reduce框架来做了。<br>大数据排序相同的思路：先哈希（哈希是好处是分布均匀，相同的数在同一个文件中），然后小文件装入内存快排，排序结果输出到文件。最后建堆归并。 </p></li><li><p>十亿整数（随机生成，可重复）中出现频率最高的一千个</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/74063684" target="_blank" rel="noopener"><strong>排序算法</strong></a></h3></li><li><p>排序算法当然是基础内容了，必须至少能快速写出，快排，建堆，和归并 </p></li><li><p>每种算法的时间空间复杂度，最好最差平均情况</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/75386508" target="_blank" rel="noopener"><strong>位运算</strong></a></h3><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p> 几十亿个数经常要查找某一个数在不在里面，使用布隆过滤器，布隆过滤器的原理。布隆过滤器可能出现误判，怎么保证无误差？</p><h1 id="网络与TCP-IP-1"><a href="#网络与TCP-IP-1" class="headerlink" title="网络与TCP/IP"></a>网络与TCP/IP</h1></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/68927070" target="_blank" rel="noopener">TCP与UDP之间的区别</a><br>(1) IP首部，TCP首部，UDP首部<br>(2) TCP和UDP区别<br>(3) TCP和UDP应用场景<br>(4) 如何实现可靠的UDP </p></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/68927100" target="_blank" rel="noopener">TCP三次握手与四次挥手</a> </p></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/68927100" target="_blank" rel="noopener">详细说明TCP状态迁移过程</a><br>(1) 三次握手和四次挥手状态变化；<br>(2) 2MSL是什么状态？作用是什么？ </p></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/68927100" target="_blank" rel="noopener">TCP相关技术</a><br>\1. TCP重发机制，Nagle算法<br>\2. TCP的拥塞控制使用的算法和具体过程<br>\3. TCP的窗口滑动 </p></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/69803044" target="_blank" rel="noopener">TCP客户与服务器模型，用到哪些函数</a> </p></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/69951345" target="_blank" rel="noopener">UDP客户与服务器模型，用到哪些函数</a> </p></li><li><p><a href="http://blog.csdn.net/shanghairuoxiao/article/details/68926923" target="_blank" rel="noopener">域名解析过程，ARP的机制，RARP的实现</a><br>\1. RARP用于无盘服务器，开机后通过发送RARP包给RARP服务器，通过mac地址得到IP地址 </p></li><li><p>Ping和TraceRoute实现原理<br>(1) Ping是通过发送ICMP报文回显请求实现。<br>(2) TraceRoute通过发送UDP报文，设置目的端口为一个不可能的值，将IP首部中的TTL分别设置从1到N，每次逐个增加，如果收到端口不可达，说明到达目的主机，如果是因为TTL跳数超过，路由器会发送主机不可达的ICMP报文。 </p></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><a href="https://github.com/semlinker/awesome-http#bs-结构定义" target="_blank" rel="noopener">HTTP</a></h2><h4 id="http-https-1-0、1-1、2-0"><a href="#http-https-1-0、1-1、2-0" class="headerlink" title="http/https 1.0、1.1、2.0"></a><strong>http/https 1.0、1.1、2.0</strong></h4><p>\1. http的主要特点:<br><strong>简单快速：</strong>当客户端向服务器端发送请求时，只是简单的填写请求路径和请求方法即可，然后就可以通过浏览器或其他方式将该请求发送就行了<br><strong>灵活：</strong> HTTP 协议允许客户端和服务器端传输任意类型任意格式的数据对象<br><strong>无连接：</strong>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。(当今多数服务器支持Keep-Alive功能，使用服务器支持长连接，解决无连接的问题)<br><strong>无状态：</strong>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即客户端发送HTTP请求后，服务器根据请求，会给我们发送数据，发送完后，不会记录信息。(使用 cookie 机制可以保持 session，解决无状态的问题)<br>\2. http1.1的特点<br>a、默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求<br>b、管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应<br>c、断点续传ftghh<br>\3. <a href="http://www.cnblogs.com/frankyou/p/6145485.html" target="_blank" rel="noopener">http2.0的特点</a><br>a、HTTP/2采用二进制格式而非文本格式<br>b、HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个HTTP连接就可以实现多个请求响应<br>c、使用报头压缩，HTTP/2降低了开销<br>d、HTTP/2让服务器可以将响应主动“推送”到客户端缓存中</p><h4 id="get-post-区别"><a href="#get-post-区别" class="headerlink" title="get/post 区别"></a><strong>get/post 区别</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`区别一：``get重点在从服务器上获取资源，post重点在向服务器发送数据；``区别二：``get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用``&quot;?&quot;``连接，多个请求数据间用``&quot;&amp;&quot;``连接，如http:``//127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；``post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；``区别三：``Get传输的数据量小，因为受URL长度限制，但效率较高；``Post可以传输大量数据，所以上传文件时只能用Post方式；``区别四：``get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；``post较get安全性较高；`</span><br></pre></td></tr></table></figure><h4 id="返回状态码"><a href="#返回状态码" class="headerlink" title="返回状态码"></a><strong>返回状态码</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`200``：请求被正常处理``204``：请求被受理但没有资源可以返回``206``：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。``301``：永久性重定向``302``：临时重定向``303``：与``302``状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上``304``：发送附带条件的请求时，条件不满足时返回，与重定向无关``307``：临时重定向，与``302``类似，只是强制要求使用POST方法``400``：请求报文语法有误，服务器无法识别``401``：请求需要认证``403``：请求的对应资源禁止被访问``404``：服务器无法找到对应资源``500``：服务器内部错误``503``：服务器正忙`</span><br></pre></td></tr></table></figure><h4 id="http-协议头相关"><a href="#http-协议头相关" class="headerlink" title="http 协议头相关"></a><strong>http 协议头相关</strong></h4><p>http数据由请求行，首部字段，空行，报文主体四个部分组成<br>首部字段分为：通用首部字段，请求首部字段，响应首部字段，实体首部字段</p><h4 id="https与http的区别？如何实现加密传输？"><a href="#https与http的区别？如何实现加密传输？" class="headerlink" title="https与http的区别？如何实现加密传输？"></a><strong>https与http的区别？如何实现加密传输？</strong></h4><ul><li><p>https就是在http与传输层之间加上了一个SSL </p></li><li><p>对称加密与非对称加密</p><h4 id="浏览器中输入一个URL发生什么，用到哪些协议？"><a href="#浏览器中输入一个URL发生什么，用到哪些协议？" class="headerlink" title="浏览器中输入一个URL发生什么，用到哪些协议？"></a><strong>浏览器中输入一个URL发生什么，用到哪些协议？</strong></h4><p> 浏览器中输入URL，首先浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p><p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理。如果采用https还会先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a><strong>安全相关</strong></h4></li><li><p>SQL注入 </p></li><li><p>XSS </p></li><li><p>RCFS </p></li><li><p>APR欺骗</p><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/76888423" target="_blank" rel="noopener">数据库</a></h2></li><li><p>SQL语言(内外连接，子查询，分组，聚集，嵌套，逻辑) </p></li><li><p>MySQL索引方法？索引的优化？ </p></li><li><p>InnoDB与MyISAM区别？ </p></li><li><p>事务的ACID </p></li><li><p>事务的四个隔离级别 </p></li><li><p>查询优化(从索引上优化，从SQL语言上优化) </p></li><li><p>B-与B+树区别？ </p></li><li><p>MySQL的联合索引(又称多列索引)是什么？生效的条件？ </p></li><li><p>分库分表</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/74012512" target="_blank" rel="noopener"><strong>进程与线程</strong></a></h3><p> (1) 进程与线程区别？</p><p>(2) 线程比进程具有哪些优势？</p><p>(3) 什么时候用多进程？什么时候用多线程？</p><p>(4) LINUX中进程和线程使用的几个函数？</p><p>(5) 线程同步？</p><p>在Windows下线程同步的方式有：互斥量，信号量，事件，关键代码段</p><p>在Linux下线程同步的方式有：互斥锁，自旋锁，读写锁，屏障(并发完成同一项任务时，屏障的作用特别好使)</p><p>知道这些锁之间的区别，使用场景？</p><h3 id="进程间通讯方式"><a href="#进程间通讯方式" class="headerlink" title="进程间通讯方式"></a><a href="http://www.cnblogs.com/CheeseZH/p/5264465.html" target="_blank" rel="noopener"><strong>进程间通讯方式</strong></a></h3><blockquote><p><strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p><strong>命名管道 (FIFO)</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p><strong>信号量</strong>：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据，有XSI信号量和POSIX信号量，POSIX信号量更加完善。</p><p><strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p><strong>共享内存( shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。(原理一定要清楚，常考)</p><p><strong>信号 ( sinal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。</p><p><strong>套接字( socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p></blockquote></li><li><p><strong>匿名管道与命名管道的区别</strong>：匿名管道只能在具有公共祖先的两个进程间使用。 </p></li><li><p><strong>共享文件映射mmap</strong><br>mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。 </p></li><li><p>常见的信号有哪些？</p><p>：SIGINT，SIGKILL(不能被捕获)，SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/70256247" target="_blank" rel="noopener"><strong>内存管理</strong></a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 虚拟内存的作用？</span><br><span class="line">2. 虚拟内存的实现？</span><br><span class="line">3. 操作系统层面对内存的管理？</span><br><span class="line">4. 内存池的作用？STL里内存池如何实现？</span><br><span class="line">5. 进程空间和内核空间对内存的管理不同？</span><br><span class="line">6. Linux的slab层，VAM？</span><br><span class="line">7. 伙伴算法</span><br><span class="line">8. 高端内存</span><br></pre></td></tr></table></figure><p>STL里<a href="https://github.com/oscarwin/MemoryPool" target="_blank" rel="noopener">内存池如何实现</a>？</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p> \1. Linux进程分为两种，实时进程和非实时进程；</p><p>\2. 优先级分为静态优先级和动态优先级，优先级的范围；</p><p>\3. 调度策略，FIFO，LRU，时间片轮转</p><p>\4. 交互进程通过平均睡眠时间而被奖励；</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><a href="http://blog.csdn.net/shanghairuoxiao/article/details/70444940" target="_blank" rel="noopener"><strong>死锁</strong></a></h3><p> (1) 死锁产生的条件；</p><p>(2) 死锁的避免；</p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3></li><li><p>Linux命令 在一个文件中，倒序打印第二行前100个大写字母<br>\<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cat filename | head -n 2 | tail -n 1 | grep &apos;[[:upper:]]&apos; -o | tr -d &apos;\n&apos;| cut -c 1-100 | rev</span><br><span class="line"></span><br><span class="line">- 与CPU，内存，磁盘相关的命令(top，free, df, fdisk) </span><br><span class="line"></span><br><span class="line">- 网络相关的命令netstat，tcpdump等 </span><br><span class="line"></span><br><span class="line">- sed, awk, grep三个超强大的命名，分别用与格式化修改，统计，和正则查找 </span><br><span class="line"></span><br><span class="line">- ipcs和ipcrm命令 </span><br><span class="line"></span><br><span class="line">- 查找当前目录以及字母下以.c结尾的文件，且文件中包含&quot;hello world&quot;的文件的路径 </span><br><span class="line"></span><br><span class="line">- 创建定时任务</span><br><span class="line"></span><br><span class="line">  ### IO模型</span><br><span class="line"></span><br><span class="line">- **五种IO模型：**阻塞IO，非阻塞IO，IO复用，信号驱动式IO，异步IO </span><br><span class="line"></span><br><span class="line">- **select，poll，epoll的区别**</span><br><span class="line">  **select：**是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理，如果没有返回**存在的问题：1. 内置数组的形式使得select的最大文件数受限与FD_SIZE；2. 每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；3. 轮寻排查当文件描述符个数很多时，效率很低；** poll：**通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。**</span><br><span class="line">  **epoll：**轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。 </span><br><span class="line"></span><br><span class="line">- 为什么使用IO多路复用，最主要的原因是什么？ </span><br><span class="line"></span><br><span class="line">- epoll有两种触发模式？这两种触发模式有什么区别？编程的时候有什么区别？ </span><br><span class="line"></span><br><span class="line">- 上一题中编程的时候有什么区别，是在边缘触发的时候要把套接字中的数据读干净，那么当有多个套接字时，在读的套接字一直不停的有数据到达，如何保证其他套接字不被饿死(面试网易游戏的时候问的一个问题，答不上来，印象贼深刻)。 </span><br><span class="line"></span><br><span class="line">  1. [select/poll/epoll区别](https://segmentfault.com/a/1190000003063859)</span><br><span class="line">  2. [几种网络服务器模型的介绍与比较](https://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-)</span><br><span class="line">  3. [epoll为什么这么快](http://www.jianshu.com/p/b5bc204da984)(搞懂这篇文章，关于IO复用的问题就信手拈来了)</span><br><span class="line"></span><br><span class="line">  ### 线程池</span><br><span class="line"></span><br><span class="line">  ### Linux的API</span><br><span class="line"></span><br><span class="line">- **fork与vfork区别**</span><br><span class="line">  fork和vfork都用于创建子进程。但是vfork创建子进程后，父进程阻塞，直到子进程调用exit()或者excle()。</span><br><span class="line">  对于内核中过程fork通过调用clone函数，然后clone函数调用do_fork()。do_fork()中调用copy_process()函数先复制task_struct结构体，然后复制其他关于内存，文件，寄存器等信息。fork采用写时拷贝技术，因此子进程和父进程的页表指向相同的页框。但是vfork不需要拷贝页表，因为父进程会一直阻塞，直接使用父进程页表。 </span><br><span class="line"></span><br><span class="line">- **exit()与_exit()区别**</span><br><span class="line">  exit()清理后进入内核，_exit()直接陷入内核。 </span><br><span class="line"></span><br><span class="line">- 孤儿进程与僵死进程</span><br><span class="line">  \1. 孤儿进程是怎么产生的？</span><br><span class="line">  \2. 僵死进程是怎么产生的？</span><br><span class="line">  \3. 僵死进程的危害？</span><br><span class="line">  \4. 如何避免僵死进程的产生？ </span><br><span class="line"></span><br><span class="line">- **Linux是如何避免内存碎片的**</span><br><span class="line">  \1. 伙伴算法，用于管理物理内存，避免内存碎片;</span><br><span class="line">  \2. 高速缓存Slab层用于管理内核分配内存，避免碎片。 </span><br><span class="line"></span><br><span class="line">- 共享内存的实现原理？</span><br><span class="line"></span><br><span class="line">  共享内存实现分为两种方式一种是采用mmap，另一种是采用XSI机制中的共享内存方法。mmap是内存文件映射，将一个文件映射到进程的地址空间，用户进程的地址空间的管理是通过vm_area_struct结构体进行管理的。mmap通过映射一个相同的文件到两个不同的进程，就能实现这两个进程的通信，采用该方法可以实现任意进程之间的通信。mmap也可以采用匿名映射，不指定映射的文件，但是只能在父子进程间通信。XSI的内存共享实际上也是通过映射文件实现，只是其映射的是一种特殊文件系统下的文件，该文件是不能通过read和write访问的。</span><br><span class="line"></span><br><span class="line">  二者区别：</span><br><span class="line"></span><br><span class="line">  &gt; 1、 系统V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。注：前面讲到，系统V共享内存机制实际是通过映射特殊文件系统shm中的文件实现的，文件系统shm的安装点在交换分区上，系统重新引导后，所有的内容都丢失。</span><br><span class="line">  &gt; 2、 系统V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。</span><br><span class="line">  &gt; 3、 通过调用mmap()映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统V共享内存实现通信的进程则不然。注：这里没有给出shmctl的使用范例，原理与消息队列大同小异。</span><br><span class="line"></span><br><span class="line">- 系统调用与库函数(open, close, create, lseek, write, read) </span><br><span class="line"></span><br><span class="line">- 同步方法有哪些？</span><br><span class="line"></span><br><span class="line">  1. 互斥锁，自旋锁，信号量，读写锁，屏障</span><br><span class="line"></span><br><span class="line">  2. 互斥锁与自旋锁的区别：互斥锁得不到资源的时候阻塞，不占用cpu资源。自旋锁得不到资源的时候，不停的查询，而然占用cpu资源。 </span><br><span class="line"></span><br><span class="line">  3. [死锁](http://blog.csdn.net/shanghairuoxiao/article/details/70444940)</span><br><span class="line"></span><br><span class="line">  ### 其他</span><br><span class="line"></span><br><span class="line">- ++i是否是原子操作</span><br><span class="line">  明显不是，++i主要有三个步骤，把数据从内存放在寄存器上，在寄存器上进行自增，把数据从寄存器拷贝会内存，每个步骤都可能被中断。 </span><br><span class="line"></span><br><span class="line">- 判断大小端</span><br><span class="line">  \``` </span><br><span class="line"></span><br><span class="line">union un</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">char ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">union un test;</span><br><span class="line">test.i = 1;</span><br><span class="line">if(ch == 1)</span><br><span class="line">cout &lt;&lt; &quot;小端&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;大端&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">\</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><a href="http://www.jellythink.com/archives/82" target="_blank" rel="noopener">单例模式线程安全的写法</a> </li><li>STL里的迭代器使用了迭代器模式 </li><li>MVC的理解 </li></ul><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><ul><li><a href="http://blog.jobbole.com/80619/" target="_blank" rel="noopener">map_reduce原理</a> （这篇文章讲的很通俗易懂） </li><li>负载均衡 </li></ul><p>=======================================================</p><p>面经集锦</p><p><a href="https://www.nowcoder.com/discuss/97181" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/97181</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-C-语言基础&quot;&gt;&lt;a href=&quot;#C-C-语言基础&quot; class=&quot;headerlink&quot; title=&quot;C/C++语言基础&quot;&gt;&lt;/a&gt;C/C++语言基础&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;C++相对于C语言的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库总结</title>
    <link href="http://yoursite.com/2019/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/09/15/数据库总结/</id>
    <published>2019-09-15T02:12:26.000Z</published>
    <updated>2019-09-15T03:09:53.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据库事务的四个特性"><a href="#1-数据库事务的四个特性" class="headerlink" title="1.数据库事务的四个特性"></a>1.数据库事务的四个特性</h2><p><strong>1.原子性、一致性、隔离性、持久性</strong></p><ul><li><strong>事务的ACID特性：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持续性(Durability)。</strong></li></ul><p>事务是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，他是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事物结束时，都能保持数据一致性。<br>1）<strong>原子性</strong>：事务是数据库的逻辑工作单位，它数据库的修改要么全部执行，要么全部不执行。<br>2）<strong>一致性</strong>：事务前后，数据库的转台都满足所有的完整性约束。<br>3）<strong>隔离性</strong>：并发执行的事务是隔离的，一个不影响一个。如果有两个事务，运行在相同的时间内，执行相同的任务，同一时间仅有一个请求用于同一数据。设置数据库的隔离级别，可以达到不同的隔离的效果。<br>4）<strong>持久性</strong>：在事务完成以后，该事务所对数据库所做的更改便持久的保存在数据库之中，并不会被回滚。</p><h2 id="2-数据库之存储过程"><a href="#2-数据库之存储过程" class="headerlink" title="2.数据库之存储过程"></a>2.数据库之存储过程</h2><p>什么是存储过程：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码块像Java语言里的方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。<br>存储过程的好处：<br>1）由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。<br>2）一个存储过程在程序在网络交互时可以替代大堆的T-SQL语句，所以能降低网络的通信量，提高通信速率。<br>3）通过存储过程能够使没有权限的用户早控制之下间接的存储数据库，从而确保数据的安全。<br>为什么使用存储过程：<br>1、增加性能 本地存储发送的内容少、调用快、预编译、高速缓存<br>一般语句的执行：检查权限、检查语法，建立执行计划处理语句的要求<br>存储过程：创建时已经检查了语法；第一次执行的时候执行计划被创建，被编译；<br>再次执行时不需要重检查语法、不需要重编译、根据已经缓存的计划来决定是否需要重创建执行计划。</p><h2 id="3-数据库建表的三种范式"><a href="#3-数据库建表的三种范式" class="headerlink" title="3.数据库建表的三种范式"></a>3.数据库建表的三种范式</h2><p><strong>第一范式</strong>：(确保每列保持原子性)。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br><strong>第二范式</strong>：（确保表中的每列都和主键相关）。第二范式在第一范式的基础上更进一步。第二范式需要确保数据库表中的每列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br><strong>第三范式</strong>：（确保每列都和主键直接相关，而不是间接相关）。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&gt; 数据库中范式相关知识点：</span><br><span class="line">&gt; </span><br><span class="line">&gt; A.   有关“键”的概念</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1)   超键：在关系中能唯一标识元组的属性或属性集称为关键模式的超键。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 2)   候选键：不含有多余属性的超键称为候选键。也就是在候选键中在删除属性就不是键了。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 3)   主键：用户选作元组标识的候选键称为主键。一般不加说明，键就是指主键。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 4)   外键：如果模式R中属性K是其他模式的主键，那么K在模式R中称为外键。</span><br><span class="line">&gt; </span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; B.   关系数据库中的“依赖”定义</span><br><span class="line">&gt; </span><br><span class="line">&gt; 若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 例如在学生表中，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作 学号 → 姓名。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1)   部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 举个例子：学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</span><br><span class="line">&gt; </span><br><span class="line">&gt; 2)   完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 例子：学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</span><br><span class="line">&gt; </span><br><span class="line">&gt; 3)   传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 例子：在关系R(学号 ,宿舍, 费用)中，(学号)-&gt;(宿舍),宿舍！=学号，(宿舍)-&gt;(费用),费用!=宿舍，所以符合传递函数的要求；</span><br><span class="line">&gt; </span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; C.   几个范式的定义</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1)   第一范式（1NF）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 主属性（主键）不为空且不重复，字段不可再分。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 2)   第二范式（2NF）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 在第一范式的基础上，要求非主属性完全依赖主属性。（不存在非主属性对主键的部分依赖）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 3)   第三范式（3NF）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 3NF在2NF的基础之上，消除了非主属性对于码的传递依赖。(不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。)</span><br><span class="line">&gt; </span><br><span class="line">&gt; 4)   BC范式（BCNF）</span><br><span class="line">&gt; </span><br><span class="line">&gt; BC范式在 3NF 的基础上，消除主属性对于码的部分与传递函数依赖。</span><br><span class="line">&gt; </span><br><span class="line">&gt; （1）所有非主属性对每一个码都是完全函数依赖；</span><br><span class="line">&gt; </span><br><span class="line">&gt; （2）所有的主属性对于每一个不包含它的码，也是完全函数依赖；</span><br><span class="line">&gt; </span><br><span class="line">&gt; （3）没有任何属性完全函数依赖于非码的任意一个组合。</span><br><span class="line">&gt; </span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; D.   几个范式的定义</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1)   第一范式</span><br><span class="line">&gt; </span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 改为</span><br><span class="line">&gt; </span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 2)   第二范式</span><br><span class="line">&gt; </span><br><span class="line">&gt; 当数据表中是联合主键，但是有的列只依赖联合主键中的一个或一部分属性组成的联合主键，此时需要拆表才能复合第二范式。</span><br><span class="line">&gt; </span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 两个主属性：学号 和 课程。“学号“和”课程“就组成了联合主键。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码（学号，课名）的部分依赖。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码（学号，课名）的部依赖。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 系主任  对码（学号，课名）的部分依赖</span><br><span class="line">&gt; </span><br><span class="line">&gt; 3)   第三范式</span><br><span class="line">&gt; </span><br><span class="line">&gt; Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)，当员工表中emp_id能够唯一确定员工员工信息，但是dept_name可由dept_id唯一确定，此时，该表不符合第三范式，此时可以删除除了dept_id之外的其他部门信息，把所有部门信息单独建立一张部门表。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 4)   BC范式</span><br><span class="line">&gt; </span><br><span class="line">&gt; 某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作； 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</span><br><span class="line">&gt; </span><br><span class="line">&gt; 答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量</span><br><span class="line">&gt; </span><br><span class="line">&gt; 码：（管理员，物品名），（仓库名，物品名）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 主属性：仓库名、管理员、物品名 ；非主属性：数量</span><br><span class="line">&gt; </span><br><span class="line">&gt; ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此属于3NF。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 但是存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性 仓库名 对于码（管理员，物品名）的部分函数依赖：仓库名 → 管理员。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 仓库（仓库名，管理员） 库存（仓库名，物品名，数量）。这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</span><br><span class="line">&gt; </span><br><span class="line">&gt;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-数据库隔离级别，每个级别会引发什么问题"><a href="#4-数据库隔离级别，每个级别会引发什么问题" class="headerlink" title="4.数据库隔离级别，每个级别会引发什么问题"></a>4.数据库隔离级别，每个级别会引发什么问题</h2><p>  1 .未提交读：事务中的修改。即使没有提交，对其他事物也是可见的。这样会提高性能，但是会导致脏读问题。</p><ol><li>提交读：一个事务只能读取已经提交的的事务所做的修改，换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。该级别可以解决脏读问题，但不能避免不可重复读。</li><li>可重复读： 保证在同一个事务中多次读取同样数据的结果是一样的。可以解决不可重复读的问题，但还是不能避免幻读的问题。</li><li>可串行化：强制事务串行执行。可以解决所有的问题。最高级别的隔离<br>MySQL默认的隔离级别是可重复读 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">并发一致性问题：</span><br><span class="line">丢失修改：T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。</span><br><span class="line">脏读数据：T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。</span><br><span class="line">不可重复读：T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。</span><br><span class="line">幻读：T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。</span><br></pre></td></tr></table></figure><blockquote><p><strong>数据库中并发操作的相关知识点：</strong></p><p><strong>A.</strong>   <strong>并发与并行的区分：</strong></p><p>1)   <strong>并发</strong>(Concurrent)<strong>：</strong>当有多个线程在操作时,如果系统只有一个CPU,则它不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。</p><p>2)   <strong>并行</strong>(Parallel)：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行。</p><p><strong>3)</strong>   <strong>区别：</strong>并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。</p><p><strong>B.</strong>   <strong>数据库事务并发带来的**</strong>数据不一致<strong>**问题有：更新丢失、脏读、不可重复读、幻象读。</strong></p><p>1)   <strong>丢失修改：一个事务的更新覆盖了另一个事务的更新。</strong>两个事务读入同一数据并修改，后提交的结果破坏先提交的结果，导致先提交的事务修改被丢失；</p><p>2)   <strong>不可重复读：一个事务两次读取同一个数据，两次读取的数据不一致。</strong>先提交的事务读取数据后，后提交的事务执行更新操作，使得前面的事务不能读取前一次结果。</p><p>3)   <strong>读脏数据：一个事务读取了另一个事务未提交的数据。</strong>某事务修改某一数据，并将它写回磁盘，后来的事务读取同一数据后，前一事务由于某种原因回滚（rollback），这时前面已经修改的数据已经恢复原值，后读到的数据就与数据库的数据不一致。</p><p>4)   <strong>幻象读：一个事务两次读取一个范围的记录，两次读取的记录数不一致。</strong></p><p>a)   事务T1按一定条件从数据库中读取了某些数据记录后,事务T2删除了其中部分记录,当T1再次按照相同条件读取数据时,发现某些记录神秘的消失了.</p><p>b)   事务T1按一定条件从数据库中读取了某些数据记录后,事务T2插入了一些记录,当T1再次按照相同条件读取数据时,发现多了一些记录.</p><p>事务A：张三妻子两次查询张三有几张银行卡。事务B：张三新办一张银行卡。事务A第一次查询银行卡数的时候，张三还没有新办银行卡，第二次查询银行卡数的时候，张三已经新办了一张银行卡，导致两次读取的银行卡数不一样。幻象读本质上是读写操作的冲突，解决办法是读完再写。</p><p>以上三种现象的原因是并发操作破坏了事务的隔离性。为了应对这些数据不一致性，主要技术主要有：<strong>封锁</strong>，时间戳，乐观控制法。</p></blockquote><blockquote><p>数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括（日志文件，数据库后备副本）</p></blockquote><h2 id="5-锁的分类"><a href="#5-锁的分类" class="headerlink" title="5.锁的分类"></a>5.锁的分类</h2><p>一般可以分为两种锁，一个是悲观锁，一个是乐观锁，悲观锁就是数据库锁机制，乐观锁一般是指用户自己实现的一种锁机制。<br>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。<br>悲观锁按使用性质划分：<br>1）共享锁（Share locks简记为S锁）：也称读锁，事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以同时读，但不能有写操作，直到A释放S锁。<br>2）排它锁（Exclusivelocks简记为X锁）：也称写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。<br>3）更新锁（简记为U锁）：用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。<br>悲观锁按照作用划分：<br>1）行锁：锁的作用范围是行级别，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。<br>2）表锁：锁的作用范围是整张表。<br><strong>乐观锁：</strong>顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改。<br>两种锁使用场景：从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><blockquote><p> <strong>数据库中的封锁机制相关知识点</strong></p><p><strong>A.</strong>   <strong>封锁机制的概念</strong></p><p><strong>封锁</strong>就是事务T在对某个数据对象操作之前，先向系统发出请求对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。基本的锁类型有两种：<strong>排他锁</strong>（又称<strong>写锁</strong>，X锁）和<strong>共享锁</strong>（又称<strong>读锁</strong>，S锁），此处再加一个<strong>更新锁</strong>和<strong>意向锁</strong></p><p>1)   <strong>共享锁（读锁S锁），</strong>是读取操作创建的锁。事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p><p>2)   <strong>排他锁（写锁X锁）</strong>，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务T既能读数据，又能修改数据。</p><p>3)   <strong>更新锁（U锁）：更新锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。</strong>因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。<strong>如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。</strong></p><p>4)   <strong>意向锁：</strong>对多粒度树中的结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。</p><p>意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><p>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</p><p>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE</p><p><strong>B.</strong>   <strong>封锁协议</strong></p><p>在运用X锁和S锁这两种基本封锁对数据对象加锁时，还需要约定一些规则。例如，何时申请X锁或S锁、持锁时间、何时释放等。这些规则称为封锁协议。通常使用三级封锁协议来在不同程度上解决并发操作的不正确调度带来的丢失修改、不可重复读和读“脏”数据等不一致性问题。</p><p><strong>1)</strong>   <strong>一级封锁协议</strong></p><p>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。一级封锁协议可以<strong>防止丢失修改</strong>，并保证事务T是可恢复的。</p><p><strong>2)</strong>   <strong>二级封锁协议</strong></p><p>在一级封锁协议基础上增加事务T在读数据R之前必须先对其加S锁，读完后释放S锁。二级封锁协议防止<strong>丢失修改</strong>，<strong>读脏数据</strong>。</p><p><strong>3)</strong>   <strong>三级封锁协议</strong></p><p>在一级封锁协议的基础上增加事务T在读数据R之前必须先对其加S锁，直到事务结束才释放。三级封锁协议出防止了丢失修改和读“脏”数据外，还可以进一步防止了不可重复读。</p><p><strong>C.</strong>   <strong>Mysql**</strong>中锁的粒度划分**</p><p>MySQL各存储引擎使用了三种级别的锁定机制：表级锁定，行级锁定和页级锁定</p><p><strong>1)</strong>   <strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</p><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p><p><strong>2)</strong>   <strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p><p><strong>3)</strong>   <strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p><strong>4)</strong>   <strong>适用范围：</strong>从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><p><strong>例题;</strong></p><p>若事务 T 对数据 R 已加 X 锁，则其他事务对数据 R（D）</p><p>A 可以加 S 锁不能加 X 锁 ；B 不能加 S 锁可以加 X 锁</p><p>C 可以加 S 锁也可以加 X 锁 ; D 不能加任何锁</p></blockquote><h2 id="6-drop、delete与truncate的区别："><a href="#6-drop、delete与truncate的区别：" class="headerlink" title="6.drop、delete与truncate的区别："></a>6.drop、delete与truncate的区别：</h2><p>1）delete和truncate只删除标的数据不删除的结构<br>2）速度，一般来说：drop&gt;truncate&gt; delete<br>3)delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.<br>4)不在需要一张表的时候，用drop（删除标的结构）<br>5）想删除部分数据行的时候。用delete，并且带上where字句（删除部分数据）<br>6）保留表而删除所有数据的时候用turncate（删除全部数据）</p><h2 id="7-超键，候选键、主键、外键分别是什么："><a href="#7-超键，候选键、主键、外键分别是什么：" class="headerlink" title="7.超键，候选键、主键、外键分别是什么："></a>7.超键，候选键、主键、外键分别是什么：</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。<br>候选键：是最小超键，即没有冗余元素的超键。<br>主键：数据库表中对存储数据对象予以唯一和完整标示的数据列和属性组合。一个数据列只能有一个主键，且主键的取值不能为空（Null）。<br>外键：在一个表中存在另一个表的主键称为此表的外键。</p><h2 id="8-什么是视图，以及视图的使用场景："><a href="#8-什么是视图，以及视图的使用场景：" class="headerlink" title="8.什么是视图，以及视图的使用场景："></a>8.什么是视图，以及视图的使用场景：</h2><p>视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增、改、查操作，视图通常是由一个表或者多个表的行或列的子集，对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。<br>1）只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>2）查询的数据来源于不同的表，而查询者希望一统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接在视图中获取数据，不必考虑数据来源于不同的表所带来的差异。</p><blockquote><p> <strong>数据库中的视图（子查询）相关知识点：</strong></p><p>视图（子查询）：是从一个或多个表导出的虚拟的表，其内容由查询定义。具有普通表的结构，但是不实现数据存储。对视图的修改：单表视图一般用于查询和修改，会改变基本表的数据，多表视图一般用于查询，不会改变基本表的数据。</p><p><strong>1)</strong>   <strong>定义和概念</strong></p><p>①　从一个或几个基本表中根据用户需要而做成一个虚表</p><p>②　视图是虚表,它在存储时只存储视图的定义,而没有存储对应的数据 </p><p>③　视图只在刚刚打开的一瞬间,通过定义从基表中搜集数据,并展现给用户</p><p><strong>2)</strong>   <strong>视图的优点</strong></p><p>①　能分割数据,简化观点。可以通过select和where来定义视图,从而可以分割数据基表中某些对于用户不关心的数据,使用户把注意力集中到所关心的数据列.进一步简化浏览数据工作 </p><p>②　为数据提供一定的逻辑独立性。 如果为某一个基表定义一个视图,即使以后基本表的内容的发生改变了也不会影响“视图定义”所得到的数据 </p><p>③　提供自动的安全保护功能。 视图能像基本表一样授予或撤消访问许可权，给用户是表的一部分访问权限而不是全部。</p><p>④　视图可以间接对表进行更新,因此视图的更新就是表的更新 </p><p>3)   使用视图的一些限制和规则</p><p>①　视图必须唯一命名，不能和表或者其他视图重名</p><p>②　视图可以嵌套，可以从其他视图中构造视图</p><p>③　order by可以用在视图定义中，但是如果select语句从视图中检索数据时候，在视图中order by将被覆盖。</p><p><strong>4)</strong>   <strong>视图和基本表的区别</strong></p><p>a)   视图是已经编译好的sql语句。而表不是  </p><p>b)   视图没有实际的物理记录。而表有。</p><p>c)   表是内容，视图是窗口</p><p>d)   表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改</p><p>e)   表是内模式，视图是外模式</p><p>f)   视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。</p><p>g)   表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。 </p><p>h)   视图的建立和删除只影响视图本身，不影响对应的基本表。</p></blockquote><h2 id="9-char和varchar的区别："><a href="#9-char和varchar的区别：" class="headerlink" title="9.char和varchar的区别："></a>9.char和varchar的区别：</h2><p>Char的长度是固定的，而varchar的长度是可以变化的，比如，存储字符串“abc”对于char(20)，表示你存储的字符将占20个字节，包含17个空，而同样的varchar（20）只占了3个字节，20只是最大值，当你存储的字符小于20时，按实际长度存储。 char的效率要被varchar2的效率高。</p><h2 id="10-order-by与group-by的区别："><a href="#10-order-by与group-by的区别：" class="headerlink" title="10.order by与group by的区别："></a>10.order by与group by的区别：</h2><p>order by排序查询、asc升序、desc降序。group by分组查询，having 只能用于group by子句、作用于组内，having条件子句可以直接跟函数表达式。使用group by 子句的查询语句需要使用聚合函数。</p><h2 id="11-列举几种表的连接方式及区别："><a href="#11-列举几种表的连接方式及区别：" class="headerlink" title="11.列举几种表的连接方式及区别："></a>11.列举几种表的连接方式及区别：</h2><p>内连接、子连接、外连接、（左、右、全）、交叉连接<br>内连接：只有两个元素表相匹配的才能在结果集中显示。<br>外连接：左外连接:左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接的表中不匹配的数据全部会显示出来。<br>交叉连接：笛卡尔效应，显示的结果是连接表数的乘积。</p><h2 id="12-在数据库中查询语句速度很慢，如何优化？"><a href="#12-在数据库中查询语句速度很慢，如何优化？" class="headerlink" title="12.在数据库中查询语句速度很慢，如何优化？"></a>12.在数据库中查询语句速度很慢，如何优化？</h2><p>1.建索引 2.减少表之间的关联 3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 5.尽量用PreparedStatement来查询，不要用Statement。</p><h2 id="13-什么是索引？索引有那几种"><a href="#13-什么是索引？索引有那几种" class="headerlink" title="13.什么是索引？索引有那几种?"></a>13.什么是索引？索引有那几种?</h2><p>索引是用来快速的寻找那些具有特定值的记录，所有的MySQL索引都以B+树的形式保存。如果没有索引，执行查询的时候MySQl必须从第一个记录开始扫面整个表中的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。虽然索引大大提高查询速度，同时会降低更新表的速度，如对表进行insert、update、delete。因为更新表时，不仅要保存数据，还要保存索引文件。建立索引会占用磁盘空间的索引文件，一般情况这个问题不太严重，但如果在一个大表上建立多种组合，索引文件会增长很快。索引只是提高效率的一种因素，如果有大数据量的表，就要花时间建立最优秀的索引，或优化查询语句。</p><p>索引的类型：<br>1）<strong>普通索引</strong>：这是最基本的索引类型，而且它没有唯一性之类的限制，即允许该列有重复的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_name)</span><br></pre></td></tr></table></figure><p>2）<strong>唯一性索引</strong>： 这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">ON table_name (column_name)</span><br></pre></td></tr></table></figure><p>3）<strong>主键索引</strong>：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值，一般是在建表的时候同时自动创建主键索引。<br>4）<strong>组合索引</strong>：指多个自字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用，使用组合索引时遵循最左前缀集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);</span><br></pre></td></tr></table></figure><p>5）<strong>全文索引</strong>：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p><h2 id="14-索引原理："><a href="#14-索引原理：" class="headerlink" title="14.索引原理："></a>14.索引原理：</h2><p>想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是b tree或者 b+ tree，重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。<br>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。 </p><p><img src="/2019/09/15/数据库总结/sql.png" alt="sql"></p><p>索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。</p><p>非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。<br>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。<br>聚集索引:表记录的排列顺序和与数据的存储顺序一致(主键)，一个表只能有一个,但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。数据行的物理顺序与列值的顺序相同<br>–&gt;聚集索引规定了数据文件的存储顺序<br>非聚集索引：表记录的排列顺序和与数据的存储顺序不一致(唯一)，一个表可以有多个<br>–&gt;是一个单独存放的指针表,用来快速找到对应点的地址<br>不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。</p><blockquote><p><strong>有关数据库中索引的相关知识点：</strong></p><p><strong>A.</strong>   <strong>索引的概念</strong></p><p><strong>数据库索引，是数据库管理系统中一个排序的数据结构</strong>，<strong>以协助快速查询、更新数据库表中数据。</strong>索引的实现通常使用B树及其变种B+树 。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。为表设置索引要付出代价的：一是增加了数据库的存储空间 ，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动) 。</p><p><strong>B.</strong>   <strong>创建索引的优点：</strong></p><p>1)   通过创建唯一性索引，可以<strong>保证数据库表中每一行数据的唯一性</strong>。</p><p>2)   <strong>大大加快数据的检索速度</strong>，这也是创建索引的最主要的原因。</p><p>3)   <strong>加速表和表之间的连接</strong>，特别是在实现数据的参考完整性方面特别有意义。</p><p>4)   使用分组和排序子句进行检索，<strong>减少查询中分组和排序的时间</strong>。</p><p>5)   通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </p><p><strong>C.</strong>   <strong>增加索引的弊端：</strong></p><p>1)   对表中的数据进行增删改时，<strong>索引也要动态维护</strong>，降低了数据库的维护性。</p><p>2)   <strong>索引需要占物理空间，</strong>除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3)   <strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加。  </p><p><strong>D.</strong>   <strong>需要创建索引的列：</strong></p><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在以下这些列上创建索引：</p><p>1)   在<strong>经常需要搜索的列</strong>，可以加快搜索的速度；</p><p>2)   在<strong>作为主键的列</strong>，强制该列的唯一性和组织表中数据的排列结构；</p><p>3)   在<strong>经常用在连接的列</strong>，这些列主要是一些外键，可以加快连接的速度；</p><p>4)   在<strong>经常需要根据范围进行搜索的列</strong>，因为索引已经排序，其指定的范围是连续的；</p><p>5)   在<strong>经常需要排序的列上创建索引，</strong>这样查询可以利用索引的排序，加快排序查询时间；</p><p>6)   <strong>在经常使用在WHERE子句中的列上面创建索引</strong>，加快条件的判断速度。</p><p><strong>E.</strong>   <strong>不适合创建索引的列：</strong></p><p>不应该创建索引的的这些列具有下列特点：</p><p>1)   在<strong>查询中很少使用或者参考的列</strong>不应该创建索引。既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>2)   对于那些只<strong>有很少数据值的列</strong>也不应该增加索引。由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>3)   对于<strong>那些定义为text, image和bit数据类型的列</strong>不应该增加索引。这些列的数据量要么相当大，要么取值很少。</p><p>4)   <strong>当修改性能远远大于检索性能时，</strong>不应该创建索引。修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p><p><strong>F.</strong>   <strong>索引的分类：</strong></p><p>三种索引： <strong>唯一索引、主键索引和聚集索引</strong>。</p><p><strong>1)</strong>   <strong>普通索引：</strong>最基本的索引，而且<strong>没有唯一性之类的限制</strong>。</p><p>创建：create <strong>index</strong> [indexName] on [TableName] ([column],…)</p><p>删除：drop <strong>index</strong> [tableName].[indexName]</p><p><strong>唯一索引</strong>：<strong>不允许其中任何两行具有相同索引值的索引</strong>。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还防止添加，将在表中创建重复键值的新数据。</p><p>例如，如果在 employee 表中职员的姓 (lname) 上创建了唯一索引，则任何两个员工都不能同姓。</p><p>创建： create <strong>Unique index</strong> [indexName] on [TableName] ([column],…)</p><p>删除：drop index [TableName].[IndexName]</p><p><strong>2)</strong>   <strong>主键索引</strong></p><p>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，<strong>主键索引是唯一索引的特定类型</strong>。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。建议建立唯一索引时，直接创建主键索引就好了。</p><p><strong>3)</strong>   <strong>聚集索引</strong></p><p>该索引中键值的<strong>逻辑顺序决定了表中相应行的物理顺序</strong>。聚集索引类似于电话簿，按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p><p><strong>创建：CREATE cluster index [IndexName] ON <a href="[ColumnName],[ColumnName],...">TableName</a></strong></p><p><strong>聚集索引使用注意事项：</strong></p><p>(1) 定义聚集索引键时使用的<strong>列越少越好</strong>；</p><p>(2) 使用下列运算符返回一个范围值的查询：BETWEEN、&gt;、&gt;=、&lt; 和 &lt;=,可以按物理顺序更快的返回一个范围;</p><p>(3) 被连续访问的列;</p><p>(4) 返回大型结果集的查询；</p><p>(5) 经常被使用表联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能;</p><p>(6) OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。应在主键上创建聚集索引;</p><p><strong>4)</strong>   <strong>非聚集索引</strong></p><p><strong>数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。非聚集索引中的项目按索引键值的顺序存储</strong>，<strong>而表中的信息按另一种顺序存储</strong>（这可以由聚集索引规定）。对于非聚集索引，可以为在表非聚集索引中查找数据时常用的每个列创建一个非聚集索引。有些书籍包含多个索引。例如，一本介绍园艺的书可能会包含一个植物通俗名称索引，和一个植物学名索引，因为这是读者查找信息的两种最常用的方法。</p><p>创建CREATE <strong>noclustered index</strong> [IndexName] ON <a href="[ColumnName],[ColumnName]...">TableName</a></p><p><strong>7.</strong>   数据表建立复合索引tab_index(“name”,”age”)，下面哪些语句能用上索引？（A）</p><p>A select*from table where age=18 and name=’test’;</p><p>B select*from table where name=’test’and age=18;</p><p>C select*from table where name like”%test%”and age=18;</p><p>D select*from table where name like”%test”and age=18;</p><p>1)   什么是复合索引？</p><p>索引可以包含一个、两个或更多个列。两个或更多个列上的索引被称作 复合索引。</p><p>2)   复合索引作用</p><p>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</p><p>3)   例子</p><p> CREATE INDEX name ON employee (emp_lname, emp_fname)</p><p>复合索引的结构与电话簿类似，它首先按姓氏对雇员进行排序，然后按名字对所有姓氏相同的雇员进行排序。如果您知道姓氏，电话簿将非常有用，如果您知道名字和姓氏，电话簿则更为有用，但如果您只知道名字而不知道姓氏，电话簿将没有用处。所以复合索引，字段的先后顺序是很重要的。 <strong>列的顺序：</strong>在创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</p><p>解析：</p><p>A，没有注意复合索引顺序</p><p>B 正确</p><p>C 凡是对索引列，使用了‘%XXX’，都不走索引。如果改为where name = ‘test%’则可以走索引。</p></blockquote><h2 id="15-MySQL的两种存储引擎区别，各自的使用场景"><a href="#15-MySQL的两种存储引擎区别，各自的使用场景" class="headerlink" title="15.MySQL的两种存储引擎区别，各自的使用场景"></a>15.MySQL的两种存储引擎区别，各自的使用场景</h2><p>1）事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。<br>2）并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。<br>3）外键：InnoDB 支持外键。<br>4）备份：InnoDB 支持在线热备份。<br>5）崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。<br>6）其它特性：MyISAM 支持压缩表和空间数据索引。<br>应用场景：<br>MyISAM管理非事务表。他提供高速存储和检索，依旧全文搜素能力。如果应用需要执行大量的SELECT查询，那么MyISAM是更好的选择。<br>InnoDB用于事务处理用于程序，具有众多特性，包括ACID事务支持，如果应用中需要执行大量的INSERT或ＵＰＤＡＴＥ操作，则应使用InnoDB，这样可以提高用户并发操作的性能。 </p><h2 id="16-数据库中的三级模式："><a href="#16-数据库中的三级模式：" class="headerlink" title="16.数据库中的三级模式："></a><strong>16.数据库中的三级模式：</strong></h2><p><strong>外模式，（概念）模式，内模式。</strong></p><p>1)   <strong>模式</strong>：模式又称<strong>概念模式</strong>或<strong>逻辑模式</strong>，对应于<strong>概念级</strong>。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。由<strong>DDL</strong>来描述、定义的，体现、反映了数据库系统的整体观。</p><p>2)   <strong>外模式</strong>：外模式又称<strong>子模式</strong>或<strong>用户模式</strong>，对应于<strong>用户级</strong>。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。利用数据操纵语言<strong>DML</strong>对这些数据记录进行</p><p>3)   <strong>内模式</strong>：内模式又称<strong>存储模式</strong>，对应于<strong>物理级</strong>，它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义，它是数据库的存储观。</p><p><strong>外模式和模式建立逻辑独立性</strong>数据的逻辑独立性是指(用户的应用程序与数据库的逻辑结构是相互独立的)；<strong>模式和内模式建立物理独立性</strong></p><h2 id="17-数据库中的几种故障"><a href="#17-数据库中的几种故障" class="headerlink" title="17.  数据库中的几种故障"></a><strong>17.</strong>  <strong>数据库中的几种故障</strong></h2><p>1)   <strong>事务故障：</strong>由非预期的、不正常的程序结束所造成的故障。如<strong>输入数据错误</strong>、运算溢出、违反存储保护、并行事务发生死锁；</p><p>2)   <strong>系统故障：</strong>系统的运行过程中，由于某种原因造成系统停止运转，致所有正在运行的事务都以非正常的方式终止，要求系统重新启动。如<strong>CPU错误、DBMS代码错误</strong>；</p><p>3)   <strong>介质故障：</strong>系统在运行过程中，辅助<strong>存储器介质受到破坏</strong>，使存储在外存中的数据部分或全部丢失。</p><h2 id="18-防止SQL注入的五种方法"><a href="#18-防止SQL注入的五种方法" class="headerlink" title="18.防止SQL注入的五种方法"></a><strong>18.</strong>防止SQL注入的五种方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">一、SQL注入简介</span><br><span class="line"></span><br><span class="line">    SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编程时的疏忽，通过SQL语句，实现无帐号登录，甚至篡改数据库。</span><br><span class="line"></span><br><span class="line">二、SQL注入攻击的总体思路</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.寻找到SQL注入的位置</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.判断服务器类型和后台数据库类型</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.针对不通的服务器和数据库特点进行SQL注入攻击</span><br><span class="line"></span><br><span class="line">三、SQL注入攻击实例</span><br><span class="line"></span><br><span class="line">比如在一个登录界面，要求输入用户名和密码：</span><br><span class="line"></span><br><span class="line">可以这样输入实现免帐号登录：</span><br><span class="line"></span><br><span class="line">用户名： ‘or <span class="number">1</span> = <span class="number">1</span> –</span><br><span class="line"></span><br><span class="line">密 码：</span><br><span class="line"></span><br><span class="line">点登陆,如若没有做特殊处理,那么这个非法用户就很得意的登陆进去了.(当然现在的有些语言的数据库API已经处理了这些问题)</span><br><span class="line"></span><br><span class="line">这是为什么呢? 下面我们分析一下：</span><br><span class="line"></span><br><span class="line">从理论上说，后台认证程序中会有如下的SQL语句：</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select * from user_table where username=</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">' "</span>+userName+<span class="string">" ' and password=' "</span>+password+<span class="string">" '"</span>;</span><br><span class="line"></span><br><span class="line">当输入了上面的用户名和密码，上面的SQL语句变成：</span><br><span class="line"></span><br><span class="line">SELECT * FROM user_table WHERE username=</span><br><span class="line"></span><br><span class="line"><span class="string">'’or 1 = 1 -- and password='</span>’</span><br><span class="line"></span><br><span class="line">分析SQL语句：</span><br><span class="line"></span><br><span class="line">条件后面username=”or <span class="number">1</span>=<span class="number">1</span> 用户名等于 ” 或<span class="number">1</span>=<span class="number">1</span> 那么这个条件一定会成功；</span><br><span class="line"></span><br><span class="line">然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用，这样语句永远都能正确执行，用户轻易骗过系统，获取合法身份。</span><br><span class="line"></span><br><span class="line">这还是比较温柔的，如果是执行</span><br><span class="line"></span><br><span class="line">SELECT * FROM user_table WHERE</span><br><span class="line"></span><br><span class="line">username=<span class="string">''</span> ;<span class="function">DROP <span class="title">DATABASE</span> <span class="params">(DB Name)</span> --' and password</span>=<span class="string">''</span></span><br><span class="line"></span><br><span class="line">….其后果可想而知… </span><br><span class="line"></span><br><span class="line">四、应对方法</span><br><span class="line"></span><br><span class="line">下面我针对JSP，说一下应对方法：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.（简单又有效的方法）PreparedStatement</span><br><span class="line"></span><br><span class="line">采用预编译语句集，它内置了处理SQL注入的能力，只要使用它的setXXX方法传值即可。</span><br><span class="line"></span><br><span class="line">使用好处：</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>).代码的可读性和可维护性.</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>).PreparedStatement尽最大可能提高性能.</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>).最重要的一点是极大地提高了安全性.</span><br><span class="line"></span><br><span class="line">原理：</span><br><span class="line"></span><br><span class="line">sql注入只对sql语句的准备(编译)过程有破坏作用</span><br><span class="line"></span><br><span class="line">而PreparedStatement已经准备好了,执行阶段只是把输入串作为数据处理,</span><br><span class="line"></span><br><span class="line">而不再对sql语句进行解析,准备,因此也就避免了sql注入问题. </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.使用正则表达式过滤传入的参数</span><br><span class="line"></span><br><span class="line">要引入的包：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line">正则表达式：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String CHECKSQL = “^(.+)\\sand\\s(.+)|(.+)\\sor(.+)\\s$”;</span><br><span class="line"></span><br><span class="line">判断是否匹配：</span><br><span class="line"></span><br><span class="line">Pattern.matches(CHECKSQL,targerStr);</span><br><span class="line"></span><br><span class="line">下面是具体的正则表达式：</span><br><span class="line"></span><br><span class="line">检测SQL meta-characters的正则表达式 ：</span><br><span class="line"></span><br><span class="line">/(\%27)|(\’)|(\-\-)|(\%23)|(#)/ix</span><br><span class="line"></span><br><span class="line">修正检测SQL meta-characters的正则表达式 ：/((\%<span class="number">3</span>D)|(=))[^\n]*((\%<span class="number">27</span>)|(\’)|(\-\-)|(\%<span class="number">3</span>B)|(:))/i</span><br><span class="line"></span><br><span class="line">典型的SQL 注入攻击的正则表达式 ：/\w*((\%<span class="number">27</span>)|(\’))((\%<span class="number">6F</span>)|o|(\%<span class="number">4F</span>))((\%<span class="number">72</span>)|r|(\%<span class="number">52</span>))/ix</span><br><span class="line"></span><br><span class="line">检测SQL注入，UNION查询关键字的正则表达式 ：/((\%<span class="number">27</span>)|(\’))union/ix(\%<span class="number">27</span>)|(\’)</span><br><span class="line"></span><br><span class="line">检测MS SQL Server SQL注入攻击的正则表达式：</span><br><span class="line"></span><br><span class="line">/exec(\s|\+)+(s|x)p\w+/ix</span><br><span class="line"></span><br><span class="line">等等…..</span><br><span class="line"><span class="number">3</span>.字符串过滤</span><br><span class="line"></span><br><span class="line">比较通用的一个方法：</span><br><span class="line"></span><br><span class="line">（||之间的参数可以根据自己程序的需要添加）</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sql_inj</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String inj_str = <span class="string">"'|and|exec|insert|select|delete|update|</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">count|*|%|chr|mid|master|truncate|char|declare|;|or|-|+|,"</span>;</span><br><span class="line"></span><br><span class="line">String inj_stra[] = split(inj_str,<span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &amp;lt; inj_stra.length ; i++ )&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str.indexOf(inj_stra[i])&amp;gt;=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>.jsp中调用该函数检查是否包函非法字符</span><br><span class="line"></span><br><span class="line">防止SQL从URL注入：</span><br><span class="line"></span><br><span class="line">sql_inj.java代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> sql_inj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.String;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sql_inj</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sql_inj</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String inj_str = <span class="string">"'|and|exec|insert|select|delete|update|</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">count|*|%|chr|mid|master|truncate|char|declare|;|or|-|+|,"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的东西还可以自己添加</span></span><br><span class="line"></span><br><span class="line">String[] inj_stra=inj_str.split(<span class="string">"\\|"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &amp;lt; inj_stra.length ; i++ )&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str.indexOf(inj_stra[i])&amp;gt;=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.JSP页面判断代码：</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">使用javascript在客户端进行不安全字符屏蔽</span><br><span class="line"></span><br><span class="line">功能介绍：检查是否含有”‘”,”\\”,”/”</span><br><span class="line"></span><br><span class="line">参数说明：要检查的字符串</span><br><span class="line"></span><br><span class="line">返回值：<span class="number">0</span>：是<span class="number">1</span>：不是</span><br><span class="line"></span><br><span class="line">函数名是</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">check</span><span class="params">(a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">fibdn = <span class="keyword">new</span> Array (”‘” ,”\\”,”/”);</span><br><span class="line"></span><br><span class="line">i=fibdn.length;</span><br><span class="line"></span><br><span class="line">j=a.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ii=<span class="number">0</span>; ii＜i; ii++)</span><br><span class="line"></span><br><span class="line">&#123; <span class="keyword">for</span> (jj=<span class="number">0</span>; jj＜j; jj++)</span><br><span class="line"></span><br><span class="line">&#123; temp1=a.charAt(jj);</span><br><span class="line"></span><br><span class="line">temp2=fibdn[ii];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tem’; p1==temp2)</span><br><span class="line"></span><br><span class="line">&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">总的说来，防范一般的SQL注入只要在代码规范上下点功夫就可以了。</span><br><span class="line"></span><br><span class="line">凡涉及到执行的SQL中有变量时，用JDBC（或者其他数据持久层）提供的如：PreparedStatement就可以 ，切记不要用拼接字符串的方法就可以了。</span><br></pre></td></tr></table></figure><h2 id="19-模糊查询语句"><a href="#19-模糊查询语句" class="headerlink" title="19.模糊查询语句"></a><strong>19.模糊查询语句</strong></h2><p><strong>数据库中的模糊查询关键字为like，并提供了四种模糊匹配条件：</strong></p><p>1)   %：表示0~n个任意个字符</p><p>把flow_user这张表里面，列名username中含有“王”的记录全部查询出来</p><p>select * from flow_user where username like ‘%王%’；</p><p>2)   _:表示一个字符</p><p>只能找到“王英琨”这样username为三个字且中间一个字是“英”的内容。</p><p>select * from flow_user where username like ‘_英_’;</p><p>3)   []：表示括号内所列字符中的一个</p><p>将找出“王飞”“李飞”“张飞”（而不是“张王李飞”）。</p><p>select * from flow_user where username LIKE’[王李张]飞’;</p><p>4)   [^]：表示不在括号所列之内的单个字符。</p><p>将找出不是“王飞”“李飞”“张飞“的”赵飞“、”吴飞“等。</p><p>select * from flow_user where username LIKE’[^王李张]飞’;</p><h2 id="20-数据库中的”空值”-和”NULL”的概念："><a href="#20-数据库中的”空值”-和”NULL”的概念：" class="headerlink" title="20.  数据库中的”空值” 和”NULL”的概念："></a><strong>20.</strong>  <strong>数据库中的”空值” 和”NULL”的概念：</strong></h2><p>1)   空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;</p><p>2)   NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.</p><p>3)   在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p><h2 id="21-数据库中的触发器"><a href="#21-数据库中的触发器" class="headerlink" title="21.数据库中的触发器"></a>21.<strong>数据库中的触发器</strong></h2><p><strong>1)</strong>   <strong>触发器的概念</strong></p><p>触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。</p><p>不会触发触发器的包括 SELECT、TRUNCATE、WRITETEXT、UPDATETEXT。</p><p><strong>2)</strong>   <strong>触发器的语法</strong></p><p><strong>Create trigger</strong> trigger_name <strong>ON</strong> {table_name | view_name}</p><p>{FOR | After | Instead of } [ insert, update,delete ]</p><p><strong>AS</strong>  sql_statement</p><p>删除触发器：drop trigger 触发器名</p><p><strong>3)</strong>   <strong>触发器的分类</strong></p><p>a)   After触发器，After触发器要求只有执行某一操作insert、update、delete之后触发器才被触发，且只能定义在表上。</p><p>b)   Instead of 触发器，Instead of 触发器表示并不执行其定义的操作（insert、update、delete）而仅是执行触发器本身。既可以在表上定义instead of触发器，也可以在视图上定义。</p><p>c)   后触发型触发器</p><p>使用for或after选项定义的触发器，执行过程如下：1. 执行到引发触发器执行的语句。2. 执行该语句 。3. 执行触发器</p><p><strong>4)</strong>   <strong>触发器的作用</strong></p><p>a)   完成比约束更复杂的数据约束</p><p>b)   检查所做的sql是否允许</p><p>c)   调用更多的存储过程</p><p>d)   防止数据表结构更改或数据表被删除</p><p>e)   修改其他数据表的数据</p><p>f)   发送sql mail</p><p>g)   返回自定义的错误信息</p><p><strong>5)</strong>   <strong>注意事项</strong></p><p>a)   一个表可以有多个触发器，但一个触发器只能对应一个表，但可以引用数据库以外的对象</p><p>b)   同一个数据表中，对每个操作而言，可以建立多个after触发器，但instead of 触发器只能创建一个</p><p>c)   对某个操作，既建了after触发器，又设置了instead of触发器，instead of触发器一定会激活，after触发器不一定会被激活</p><h2 id="22-数据库中关于删除的几个关键词"><a href="#22-数据库中关于删除的几个关键词" class="headerlink" title="22.  数据库中关于删除的几个关键词"></a><strong>22.</strong>  数据库中关于删除的几个关键词</h2><p>当你不再需要该表时， 用 drop;</p><p>当你仍要保留该表，但要删除所有记录时， 用 truncate;</p><p>当你要删除部分记录时（always with a WHERE clause), 用 delete.</p><h2 id="23-多表查询（重要）"><a href="#23-多表查询（重要）" class="headerlink" title="23.多表查询（重要）"></a>23.<strong>多表查询（重要）</strong></h2><h2 id=""><a href="#" class="headerlink" title=""></a><strong><img src="/2019/09/15/数据库总结/1568516479834.png" alt="1568516479834"></strong></h2><p><strong>内连接</strong></p><p>内连接就是表间的主键与外键相连，只取得键值一致的，可以获取双方表中的数据连接方式。语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1,列名2... FROM 表1 INNER JOIN 表2 ON 表1.外键=表2.主键 WhERE 条件语句;</span><br></pre></td></tr></table></figure><p>外连接<br>与取得双方表中数据的内连接相比，外连接只能取得其中一方存在的数据，外连接又分为左连接和右连接两种情况。接下来，我们将介绍这两种连接方式。</p><p><strong>左外连接</strong><br>左连接是以左表为标准，只查询在左边表中存在的数据，当然需要两个表中的键值一致。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>外键=表<span class="number">2.</span>主键 <span class="keyword">WhERE</span> 条件语句;</span><br></pre></td></tr></table></figure><blockquote><p>他会以左连接中的左表的<strong>全部数据</strong>作为基准进行查询。</p></blockquote><p> <strong>右外连接</strong></p><p>同理，右连接将会以右边作为基准，进行检索。语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1 FROM 表1 RIGHT OUTER JOIN 表2 ON 表1.外键=表2.主键 WhERE 条件语句;</span><br></pre></td></tr></table></figure><blockquote><p>这里就是以右边的表为基准进行了检索</p></blockquote><blockquote><p>内连接是抽取两表间键值一致的数据，而外连接（左连接，右连接）时，是以其中一个表的全部记录作为基准进行检索。<br>左连接和右连接只有数据基准的区别，本质上是一样的，具体使用哪一种连接，根据实际的需求所决定<br>无论是内连接还是外连接，在查询的时候最好使用【表名.列名】的方式指定需要查询的列名，否则一旦两个表中出现了列名一致的数据时，可能会报错，养成良好的习惯很重要。<br>表的别名：其实我们在查询的过程中，如果遇到了特别复杂的数据表名，我们可以通过取别名的方式来实现，使用的是我们以前使用过的【AS】语句，例如，我们的内连接就可以化简为下面的语句：<br>SELECT s.name,c.collegeName FROM student AS s INNER JOIN college AS c ON s.collegeId = c.collegeId;查询结果一致，是不是瞬间觉得语句简洁很多呢？ </p></blockquote><p><strong>自连接</strong></p><p>自连接顾名思义就是自己跟自己连接，有人或许会问，这样的连接有意义吗？答案是肯定的。<br>例如，我们将【student】的数据改为下图： </p><blockquote><p>自连接的使用情况还是很多的，比如当我们找某个站点所经过的所有公交等，都可以采用自连接的方式进行检索；</p></blockquote><p><strong>子查询</strong><br>通常我们在查询的SQL中嵌套查询，称为子查询。子查询通常会使复杂的查询变得简单，但是相关的子查询要对基础表的每一条数据都进行子查询的动作，所以当表单中数据过大时，一定要慎重选择。基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span> ...FROM 表名 <span class="keyword">WHERE</span> 列名 比较运算符 （<span class="keyword">SELECT</span> 命令）;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据库事务的四个特性&quot;&gt;&lt;a href=&quot;#1-数据库事务的四个特性&quot; class=&quot;headerlink&quot; title=&quot;1.数据库事务的四个特性&quot;&gt;&lt;/a&gt;1.数据库事务的四个特性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.原子性、一致性、隔离性、持久性&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数编程之美-Continually updated</title>
    <link href="http://yoursite.com/2019/09/13/%E6%95%B0%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E-Continually-updated/"/>
    <id>http://yoursite.com/2019/09/13/数编程之美-Continually-updated/</id>
    <published>2019-09-13T06:34:17.000Z</published>
    <updated>2019-09-13T08:24:53.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-单调栈算法"><a href="#1-单调栈算法" class="headerlink" title="1.单调栈算法"></a>1.单调栈算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-单调栈算法&quot;&gt;&lt;a href=&quot;#1-单调栈算法&quot; class=&quot;headerlink&quot; title=&quot;1.单调栈算法&quot;&gt;&lt;/a&gt;1.单调栈算法&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构——图专题总结</title>
    <link href="http://yoursite.com/2019/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/09/10/数据结构——图专题总结/</id>
    <published>2019-09-10T08:45:14.000Z</published>
    <updated>2019-09-11T05:42:23.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的基本定义"><a href="#图的基本定义" class="headerlink" title="图的基本定义"></a>图的基本定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　定义：图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</span><br><span class="line"></span><br><span class="line">　　在图中需要注意的是：</span><br><span class="line">　　（1）线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点（Vertex）。</span><br><span class="line">　　（2）线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点（有穷非空性）。</span><br><span class="line">　　（3）线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示（边集可以为空）。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果图中任意两个顶点之间的边都是无向边（简而言之就是没有方向的边），则称该图为无向图（Undirected graphs）。</span><br><span class="line">如果图中任意两个顶点之间的边都是有向边（简而言之就是有方向的边），则称该图为有向图（Directed graphs）。</span><br><span class="line">完全图：</span><br><span class="line">①无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。（含有n个顶点的无向完全图有(n×(n-1))/2条边）如下图所示：</span><br><span class="line">　②有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。（含有n个顶点的有向完全图有n×(n-1)条边）如下图所示：</span><br></pre></td></tr></table></figure><blockquote><p>PS：当一个图接近完全图时，则称它为<strong>稠密图</strong>（Dense Graph），而当一个图含有较少的边时，则称它为<strong>稀疏图</strong>（Spare Graph）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　（4）顶点的度</span><br><span class="line"></span><br><span class="line">　　顶点Vi的度（Degree）是指在图中与Vi相关联的边的条数。对于有向图来说，有入度（In-degree）和出度（Out-degree）之分，有向图顶点的度等于该顶点的入度和出度之和。</span><br><span class="line"></span><br><span class="line">　　（5）邻接</span><br><span class="line"></span><br><span class="line">　　①若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接（Adjacent）；</span><br><span class="line"></span><br><span class="line">　　②若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</span><br></pre></td></tr></table></figure><blockquote><p>无向图中的边使用小括号“()”表示，而有向图中的边使用尖括号“&lt;&gt;”表示。</p></blockquote><h2 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式"></a>图的存储方式</h2><p>邻接矩阵</p><p>邻接表</p><h2 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现在假设有一个很实际的问题：我们要在n个城市中建立一个通信网络，则连通这n个城市需要布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？ </span><br><span class="line">于是我们就可以引入连通图来解决我们遇到的问题，n个城市就是图上的n个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有n个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。</span><br></pre></td></tr></table></figure><h3 id="普里姆算法—Prim算法"><a href="#普里姆算法—Prim算法" class="headerlink" title="普里姆算法—Prim算法"></a>普里姆算法—Prim算法</h3><p>算法思路：<br>首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度的分析： </span><br><span class="line">其中我们建立邻接矩阵需要的时间复杂度为：O(n*n),然后，我们Prim函数中生成最小生成树的时间复杂度为：O(n*n).</span><br></pre></td></tr></table></figure><h3 id="克鲁斯卡算法"><a href="#克鲁斯卡算法" class="headerlink" title="克鲁斯卡算法"></a>克鲁斯卡算法</h3><p>算法思路：<br>（1）将图中的所有边都去掉。<br>（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环<br>（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。</p><p>这里同样我们给出一个和Prim算法讲解中同样的例子，模拟克鲁斯卡算法生成最小生成树的 </p><h2 id="单源最短路径问题"><a href="#单源最短路径问题" class="headerlink" title="单源最短路径问题"></a><strong>单源最短路径问题</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra最短路算法（单源最短路）</span><br><span class="line">Bellman–Ford算法（解决负权边问题）</span><br><span class="line">SPFA算法（Bellman-Ford算法改进版本）</span><br><span class="line">Floyd最短路算法（全局/多源最短路）</span><br></pre></td></tr></table></figure><h3 id="迪杰斯特拉-Dijkstra）"><a href="#迪杰斯特拉-Dijkstra）" class="headerlink" title="迪杰斯特拉(Dijkstra）"></a>迪杰斯特拉(Dijkstra）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2. 初始状态：</span><br><span class="line"></span><br><span class="line">2.1.  若从源点 v0 到顶点 vi有边：dist[i]为该边上的权值；</span><br><span class="line"></span><br><span class="line">2.2.  若从源点 v0 到顶点 vi无边：dist[i]为∞。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根据以上描述，可以得到如下描述的算法：</span><br><span class="line"></span><br><span class="line"> （<span class="number">1</span>）初始化时，S只含有源节点；</span><br><span class="line">    （<span class="number">2</span>）从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度）；</span><br><span class="line">    （<span class="number">3</span>）以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离；</span><br><span class="line">    （<span class="number">4</span>）重复步骤（<span class="number">2</span>）和（<span class="number">3</span>），直到所有顶点都包含在S中。</span><br><span class="line">    具体图例与算法执行步骤：（就从A开始，到各节点的最短路径）。</span><br></pre></td></tr></table></figure><p><img src="/2019/09/10/数据结构——图专题总结/1.jpg" alt=""></p><p><img src="/2019/09/10/数据结构——图专题总结/2.jpg" alt="2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个人认为，Dijkstra算法的原理其实就是广度优先搜索，即逐步查找整张图，不管输入节点的位置情况，最后得到的也是所有点到源点的最小路径情况。</span><br><span class="line">    Dijkstra算法从用户输入的某个节点编号（a）开始，然后查找出与a相连通且权值最小的点，将其加入已确定路径点的集合 （T）中。之后每次循环，查找出从源点出发，经过T中新加入的点，再到当前点，路径权值是否有变化。若有变化，则更新路径信息。之后再重复循环，找出未确定路径点集合中（没有加入集合T的点即为未确定路径点），权值最小的那个，重复上述循环直至所有点都加入集合 T 中。</span><br></pre></td></tr></table></figure><p>算法的精髓：S 集内的顶点是已经找到最短路径的顶点，V0 到 w 的最短路径只能通过 S 集内的顶点。**</p><p><strong>迪杰斯特拉算法的时间复杂度为O(n*n)。</strong></p><blockquote><p>Dijkstra算法 和 Prim算法的原理都是一样是 广度优先搜索，只不过前者每次循环更新的是其余点到源点的路径信息（路径权值总和最小），后者更新的是总体权值总和最小。它们都是每次加入一个点，从某个确定点开始，逐步展开至整张图。</p></blockquote><blockquote><p>Floyd优缺点分析：</p><p>优点：比较容易容易理解，可以算出任意两个节点之间的最短距离，代码编写简单。<br>缺点：时间复杂度比较高(n3)，不适合计算大量数据，当数据稍微大点儿的时候就可以选择其他的算法来解决问题了，不然也会是超时。</p><p>Floyd算法与Dijkstra算法的不同</p><p>1.Floyd算法是求任意两点之间的距离，是多源最短路，而Dijkstra(迪杰斯特拉)算法是求一个顶点到其他所有顶点的最短路径，是单源最短路。<br>2.Floyd算法属于动态规划，我们在写核心代码时候就是相当于推dp状态方程，Dijkstra(迪杰斯特拉)算法属于贪心算法。<br>3.Dijkstra(迪杰斯特拉)算法时间复杂度一般是o(n^2),Floyd算法时间复杂度是o(n^3),Dijkstra(迪杰斯特拉)算法比Floyd算法块。<br>4.Floyd算法可以算带负权的，而Dijkstra(迪杰斯特拉)算法是不可以算带负权的。并且Floyd算法不能算负权回路。 </p></blockquote><blockquote></blockquote><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p><strong>不管三七二十一，先把整个图中任意两点的最短距离求出再说</strong></p><p>Floyd算法又称为插点法，是一种利用<a href="https://baike.baidu.com/item/动态规划/529408" target="_blank" rel="noopener">动态规划</a>的思想寻找给定的<a href="https://baike.baidu.com/item/加权图/10579361" target="_blank" rel="noopener">加权图</a>中多源点之间<a href="https://baike.baidu.com/item/最短路径/6334920" target="_blank" rel="noopener">最短路径</a>的算法，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图的基本定义&quot;&gt;&lt;a href=&quot;#图的基本定义&quot; class=&quot;headerlink&quot; title=&quot;图的基本定义&quot;&gt;&lt;/a&gt;图的基本定义&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构——树专题总结</title>
    <link href="http://yoursite.com/2019/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/09/10/数据结构——树专题总结/</id>
    <published>2019-09-10T07:54:04.000Z</published>
    <updated>2019-09-10T08:44:09.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树<br>二叉树：每个节点最多含有两个子树的树称为二叉树。（我们一般在书中试题中见到的树是二叉树，但并不意味着所有的树都是二叉树。）</p><p>在二叉树的概念下又衍生出满二叉树和完全二叉树的概念</p><p>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上<br>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。 </p><blockquote><p>深度优先搜索（DFS）与广度优先搜索（BFS）<br>实现：bfs＝队列，入队列，出队列 一次访问一条路径；dfs=栈，压栈，出栈 一次访问多条路径（来自知乎）</p><p>关系：用DFS解决的问题都可以用BFS解决。DFS易于编写（递归），时间消耗较少但是容易发生爆栈，而BFS可以控制队列的长度。 </p></blockquote><h3 id="二叉树的一些性质"><a href="#二叉树的一些性质" class="headerlink" title="二叉树的一些性质"></a>二叉树的一些性质</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二叉树有以下几个性质：TODO(上标和下标)</span><br><span class="line">性质<span class="number">1</span>：二叉树第i层上的结点数目最多为 <span class="number">2</span>&#123;i<span class="number">-1</span>&#125; (i≥<span class="number">1</span>)。</span><br><span class="line">性质<span class="number">2</span>：深度为k的二叉树至多有<span class="number">2</span>&#123;k&#125;<span class="number">-1</span>个结点(k≥<span class="number">1</span>)。</span><br><span class="line">性质<span class="number">3</span>：包含n个结点的二叉树的高度至少为log2 (n+<span class="number">1</span>)。</span><br><span class="line">性质<span class="number">4</span>：在任意一棵二叉树中，若终端结点的个数为n0，度为<span class="number">2</span>的结点数为n2，则n0=n2+<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h2 id="2-动态查找树"><a href="#2-动态查找树" class="headerlink" title="2.动态查找树"></a>2.动态查找树</h2><h3 id="2-1-二叉查找树-二叉排序树"><a href="#2-1-二叉查找树-二叉排序树" class="headerlink" title="2.1 二叉查找树/二叉排序树"></a>2.1 二叉查找树/二叉排序树</h3><p>二叉查找树是二叉树的衍生概念：</p><p>二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><pre><code>1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；2 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；3.任意节点的左、右子树也分别为二叉查找树；4.没有键值相等的节点。</code></pre><p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低为 O ( log ⁡ n ) 。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</p><h3 id="2-2-平衡二叉树-AVL树"><a href="#2-2-平衡二叉树-AVL树" class="headerlink" title="2.2 平衡二叉树 /AVL树"></a>2.2 平衡二叉树 /AVL树</h3><p>平衡二叉树，又称AVL树，它是一种特殊的<a href="http://www.cnblogs.com/sench/p/7783331.html" target="_blank" rel="noopener">二叉排序树</a>。<strong>AVL树或者是一棵空树</strong>，或者是具有以下性质的二叉树：</p><p>（1）左子树和右子树都是平衡二叉树；</p><p>（2）左子树和右子树的深度（高度）之差的绝对值不超过1。  </p><p>平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</p><p>其中<strong>AVL树是最先发明的自平衡二叉查找树</strong>，是最原始典型的平衡二叉树。</p><p>平衡二叉树是基于二叉查找树的改进。由于在某些极端的情况下（如在插入的序列是有序的时），二叉查找树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。所以我们通过自平衡操作（即旋转）构建两个子树高度差不超过1的平衡二叉树。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; 平衡二叉排序树是一类特殊的二叉排序树，它或者为空树，或者其左右子树都是平衡二叉排序树，而且其左右的子数高度之差绝对值不超过1. </span><br><span class="line">&gt; AVL树的查找平均复杂度是O（log(n)）。</span><br><span class="line">&gt; </span><br><span class="line">&gt;  在每一次树插入新元素后，树的平衡都可能被破坏，需要旋转调整树的高度，以达到平衡树结构，共分为以下四种情况：</span><br><span class="line">&gt; </span><br><span class="line">&gt; LL：对该结点的左儿子的左子树进行了一次插入，需右旋转</span><br><span class="line">&gt; LR：对该结点的左儿子的右子树进行了一次插入，先左后右</span><br><span class="line">&gt; RL：对该结点的右儿子的左子树进行了一次插入，先右后左</span><br><span class="line">&gt; RR：对该结点的右儿子的右子树进行了一次插入，需左旋转</span><br><span class="line">&gt; 旋转原则：在旋转的时候，都是要以离新插入节点最近的不平衡子树进行旋转，注意旋转的这部分子树一定是不平衡的子树。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>对于插入或删除造成不平衡，可以用四种方式去调整，具体参考</p><p><a href="https://www.cnblogs.com/sgatbl/p/9426394.html" target="_blank" rel="noopener">https://www.cnblogs.com/sgatbl/p/9426394.html</a></p><h3 id="2-3-红黑树"><a href="#2-3-红黑树" class="headerlink" title="2.3 红黑树"></a>2.3 红黑树</h3><p>红黑树也是一种自平衡的二叉查找树。</p><pre><code>1.每个结点要么是红的要么是黑的。（红或黑）2.根结点是黑的。  （根黑）3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  （叶黑）4.如果一个结点是红的，那么它的两个儿子都是黑的。  （红子黑）5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。（路径下黑相同）</code></pre><p><img src="/2019/09/10/数据结构——树专题总结/redblack.jpg" alt="redblack"></p><p>如图就是一棵典型的红黑树。保证红黑树满足它的基本性质，就是在调整数据结构自平衡。</p><p>而红黑树自平衡的调整操作方式就有旋转和变色两种。</p><p>红黑树是一种应用很广的数据结构，如在Java集合类中TreeSet和TreeMap的底层，C++STL中set与map，以及linux中虚拟内存的管理。 </p><p>详细解读参考：<a href="https://blog.csdn.net/qq_39295755/article/details/80182288" target="_blank" rel="noopener">https://blog.csdn.net/qq_39295755/article/details/80182288</a></p><h3 id="2-4-哈夫曼树（Huffman-Tree）"><a href="#2-4-哈夫曼树（Huffman-Tree）" class="headerlink" title="2.4 哈夫曼树（Huffman Tree）"></a>2.4 哈夫曼树（Huffman Tree）</h3><p>哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。</p><p>一般可以按下面步骤构建：</p><p>1，将所有左，右子树都为空的作为根节点。<br>2，在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。<br>3，从森林中删除这两棵树，同时把新树加入到森林中。<br>4，重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。</p><p>大家可能更多听说的是哈夫曼编码，其实就是哈夫曼树的应用。<strong>即如何让电文中出现较多的字符采用尽可能短的编码且保证在译码时不出现歧义。</strong> </p><p><strong>哈夫曼编码就是在哈夫曼树的基础上构建的，这种编码方式最大的优点就是用最少的字符包含最多的信息内容。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文本中字符出现的次数越多，在哈夫曼树中的体现就是越接近树根。编码的长度越短</span><br></pre></td></tr></table></figure><p><img src="/2019/09/10/数据结构——树专题总结/273cb3f0e038d9db68f7b36bb4702ac.png" alt="273cb3f0e038d9db68f7b36bb4702ac"><img src="/2019/09/10/数据结构——树专题总结/ha.png" alt="ha"></p><blockquote><p>树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 <strong>“WPL”</strong> 。例如图 1 中所示的这颗树的带权路径长度为</p></blockquote><h3 id="3-多路查找树"><a href="#3-多路查找树" class="headerlink" title="3.多路查找树"></a>3.多路查找树</h3><p>大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。</p><h4 id="3-1-B树"><a href="#3-1-B树" class="headerlink" title="3.1 B树"></a>3.1 B树</h4><p>B树（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的<strong>二叉查找树</strong>（binary search tree），可以拥有最多2个子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.根结点至少有两个子女。</span><br><span class="line"></span><br><span class="line">2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</span><br><span class="line"></span><br><span class="line">3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</span><br><span class="line"></span><br><span class="line">4.所有的叶子结点都位于同一层。</span><br><span class="line"></span><br><span class="line">5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</span><br></pre></td></tr></table></figure><p><img src="/2019/09/10/数据结构——树专题总结/B+.png" alt="B+"></p><p>如图所示就是一颗符合规范的B树，由于相比于磁盘IO的速度，内存中的耗时几乎可以省略，所以只要树的高度足够低，IO次数足够小，就可以提升查询性能。</p><p>B树的增加删除同样遵循自平衡的性质，有旋转和换位。</p><p>B树的应用是文件系统及部分非关系型数据库索引。</p><h4 id="3-2-B-树"><a href="#3-2-B-树" class="headerlink" title="3.2 B+树"></a>3.2 B+树</h4><p>B+ 树是一种树数据结构，通常用于关系型数据库（如Mysql）和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。</p><p>在B树基础上，为叶子结点增加链表指针（B树+叶子有序链表），所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。</p><p>b+树的非叶子节点不保存数据，只保存子树的临界值（最大或者最小），所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。</p><p><img src="/2019/09/10/数据结构——树专题总结/BB+.png" alt="BB+"> </p><p>这通常在多数节点在次级存储比如硬盘中的时候出现。通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了。</p><h4 id="3-3-B-树"><a href="#3-3-B-树" class="headerlink" title="3.3 B*树"></a>3.3 B*树</h4><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针</p><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。</p><h4 id="3-4-R树"><a href="#3-4-R树" class="headerlink" title="3.4 R树"></a>3.4 R树</h4><p>R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。</p><p>R树的核心思想是聚合距离相近的节点并在树结构的上一层将其表示为这些节点的最小外接矩形（MBR），这个最小外接矩形就成为上一层的一个节点。因为所有节点都在它们的最小外接矩形中，所以跟某个矩形不相交的查询就一定跟这个矩形中的所有节点都不相交。叶子节点上的每个矩形都代表一个对象，节点都是对象的聚合，并且越往上层聚合的对象就越多。也可以把每一层看做是对数据集的近似，叶子节点层是最细粒度的近似，与数据集相似度100%，越往上层越粗糙。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;p&gt;二叉树&lt;br&gt;二叉树：每个节点最多含有两个子树的树称为二叉树。（我们一般在书中试题中见到的树是二叉树，但并不意味着所有的树都是二叉树
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>20190919Summary</title>
    <link href="http://yoursite.com/2019/09/10/20190919Summary/"/>
    <id>http://yoursite.com/2019/09/10/20190919Summary/</id>
    <published>2019-09-10T03:05:11.000Z</published>
    <updated>2019-09-10T09:14:47.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择题知识点回顾"><a href="#选择题知识点回顾" class="headerlink" title="选择题知识点回顾"></a>选择题知识点回顾</h2><p>1.排序算法的时间复杂度分析</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; 研究排序算法的稳定性有何意义？</span><br><span class="line">&gt; </span><br><span class="line">&gt; 　　首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 再简单具体一点，如果A i == A j，Ai 原来在 Aj 位置前，排序后 Ai  仍然是在 Aj 位置前。 </span><br><span class="line">&gt; </span><br><span class="line">&gt; 下面我们分析一下稳定性的好处：</span><br><span class="line">&gt; </span><br><span class="line">&gt; （1）如果排序算法是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所利用。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 基数排序就是这样，先按低位排序，逐次按高位排序，那么，低位相同的数据元素其先后位置顺序即使在高位也相同时是不会改变的。详细请参见随笔《基数排序》。</span><br><span class="line">&gt; </span><br><span class="line">&gt; （2）学习排序原理时，可能编的程序里面要排序的元素都是简单类型，实际上真正应用时，可能是对一个复杂类型（自定义类型）的数组排序，</span><br><span class="line">&gt; </span><br><span class="line">&gt; 而排序的键值仅仅只是这个元素中的一个属性，对于一个简单类型，数字值就是其全部意义，即使交换了也看不出什么不同。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 但是，对于复杂类型，交换的话可能就会使原本不应该交换的元素交换了。比如：一个“学生”数组，欲按照年龄排序，“学生”这个对象不仅含有“年龄”，还有其它很多属性。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 假使原数组是把学号作为主键由小到大进行的数据整理。而稳定的排序会保证比较时，如果两个学生年龄相同，一定不会交换。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 那也就意味着尽管是对“年龄”进行了排序，但是学号顺序仍然是由小到大的要求。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2019/09/10/20190919Summary/1.png" alt="1"></p><h2 id="编程题回顾"><a href="#编程题回顾" class="headerlink" title="编程题回顾"></a>编程题回顾</h2><h3 id="1-redbook书券使用问题"><a href="#1-redbook书券使用问题" class="headerlink" title="1 . redbook书券使用问题"></a>1 . redbook书券使用问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> money;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arry,<span class="keyword">int</span> loc,<span class="keyword">int</span> CurPrice,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Curarry)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurPrice==money)&#123;</span><br><span class="line">        res.insert(Curarry);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(CurPrice&gt;money||loc&gt;=arry.size())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     dfs(arry,loc+<span class="number">1</span>, CurPrice,Curarry);</span><br><span class="line">     Curarry.push_back(arry[loc]);</span><br><span class="line">     dfs(arry,loc, CurPrice+arry[loc],Curarry);</span><br><span class="line">     dfs(arry,loc+<span class="number">1</span>, CurPrice+arry[loc],Curarry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;money;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;arry;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;tmp) &#123;</span><br><span class="line">        arry.push_back(tmp);</span><br><span class="line">        <span class="keyword">if</span>(getchar()==<span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmpvec;</span><br><span class="line">    sort(arry.begin(),arry.end());</span><br><span class="line">    dfs(arry,<span class="number">0</span>, <span class="number">0</span>,tmpvec);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-字符串倒序"><a href="#2-字符串倒序" class="headerlink" title="2 字符串倒序"></a>2 字符串倒序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxlen=<span class="number">10001</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;test;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    getline(<span class="built_in">cin</span>,a);</span><br><span class="line">    <span class="keyword">int</span> loc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> wordlen=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (loc&lt;=a.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[loc]==<span class="string">' '</span>&amp;&amp;loc&lt;=a.length()) &#123;</span><br><span class="line">            loc++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=loc;</span><br><span class="line">        <span class="keyword">while</span> (a[loc++]!=<span class="string">' '</span>&amp;&amp;loc&lt;=a.length()) &#123;</span><br><span class="line">            wordlen++;</span><br><span class="line">        &#125;</span><br><span class="line">        test.push(a.substr(pre,wordlen));</span><br><span class="line">         wordlen=<span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span> (!test.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(test.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;test.top()&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line">            test.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;test.top()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            test.pop();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表逆置"><a href="#单链表逆置" class="headerlink" title="单链表逆置"></a>单链表逆置</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><p>基本思路</p><p>定义一个链表类型的指针l，指针l指向的是链表的首地址，而不是链表的第一个数，指针l指向的下一个链表类型才是链表的第一个数，每次往链表中加数都加到链表中的第1个位置（即指针l指向的位置）</p><p><img src="/2019/09/10/20190919Summary/touchafa1.png" alt="touchafa1"></p><h4 id="原地逆置"><a href="#原地逆置" class="headerlink" title="原地逆置"></a>原地逆置</h4><p> <img src="/2019/09/10/20190919Summary/yuandi.png" alt="yuandi"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头插法相对简便，但插入的数据与插入的顺序相反；</span><br><span class="line">尾插法操作相对复杂，但插入的数据与插入顺序相同。</span><br><span class="line">两种创建的方法各有千秋，根据实际情况选择不同的方法。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择题知识点回顾&quot;&gt;&lt;a href=&quot;#选择题知识点回顾&quot; class=&quot;headerlink&quot; title=&quot;选择题知识点回顾&quot;&gt;&lt;/a&gt;选择题知识点回顾&lt;/h2&gt;&lt;p&gt;1.排序算法的时间复杂度分析&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PersonaDocument</title>
    <link href="http://yoursite.com/2019/09/09/PersonaDocument/"/>
    <id>http://yoursite.com/2019/09/09/PersonaDocument/</id>
    <published>2019-09-09T05:56:30.000Z</published>
    <updated>2019-09-19T02:50:04.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="农业物联网终端系统"><a href="#农业物联网终端系统" class="headerlink" title="农业物联网终端系统"></a>农业物联网终端系统</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在农业环境（大田、大棚）布置传感器采集环境数据，通过物联网终端传输到大数据平台，平台</span><br><span class="line">提供用户数据存储、访问、下载、上传。用户不需要自己搭建物联网系统、也不需要自己建设大数据</span><br><span class="line">系统，只需要从我们平台上下载数据进行自己所从事的专业数据建模与分析。应用示范，本系统与江</span><br><span class="line">苏省农科院团队共同开发，已经完成在扬州、兴化等地的应用示范。 主要负责：</span><br><span class="line"> 物联网采集终端的设计与实现</span><br><span class="line"> 无线传感器网络与服务器的通信实现</span><br><span class="line"> 服务器程序设计</span><br><span class="line"> 协调开发</span><br></pre></td></tr></table></figure><h2 id="面试可能涉及到的问题"><a href="#面试可能涉及到的问题" class="headerlink" title="面试可能涉及到的问题"></a>面试可能涉及到的问题</h2><p>框架（功能、通信）</p><p>硬件部分：</p><p>zigbee的通信流程、底层实现，任务轮询机制—-&gt;Zigbee通信</p><p>TTL 串口通信</p><p>服务器部分：</p><p>socket通信的流程、同步异步问题、堵塞非堵塞问题等等</p><p>多线程与socket结合问题</p><p>大量client连接情况下，IO复用与多线程及其他有缺点方案</p><p>大量client连接的情况下，新的设计方案</p><p>服务器水平拓展、分布式怎么实现方案注意点</p><p>怎么应对攻击，非法连接，方案。</p><p>怎么防止粘包、拆包</p><p>线程、进程、之间通信</p><p>TCP/IP协议部分</p><p>数据库设计：</p><p>怎么实现大量数据的存储</p><p>有什么难点、怎么发现、怎么解决</p><p>通过项目有什么收获</p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><h3 id="1-Zigbee通信"><a href="#1-Zigbee通信" class="headerlink" title="1 Zigbee通信"></a>1 Zigbee通信</h3><h3 id="2-TTL串口通信"><a href="#2-TTL串口通信" class="headerlink" title="2.TTL串口通信"></a>2.TTL串口通信</h3><h3 id="3-GPRS"><a href="#3-GPRS" class="headerlink" title="3. GPRS"></a>3. GPRS</h3><h3 id="4-socket通信-代码以C-为例"><a href="#4-socket通信-代码以C-为例" class="headerlink" title="4.socket通信(代码以C#为例)"></a>4.socket通信(代码以C#为例)</h3><p>​      从问题看本质：socket到底是什么？==&gt;<a href="https://blog.csdn.net/yeyuangen/article/details/6799575" target="_blank" rel="noopener">https://blog.csdn.net/yeyuangen/article/details/6799575</a></p><blockquote><p><strong>每个整数socket就是一个socket核心对象的handle，对你来说他就代表一个socket’。</strong>　</p><p>每个socket其实是个五元数，（源IP，源端口，目标IP，目标端口，协议），只要这5元里边有一个不同，就被认为是不同的SOCKET。<br>所以不管是什么系统来实现，都是按照这样的原则进行识别处理的。</p><hr><p>  如上所知，每个socket其实是个五元数，（源IP，源端口，目标IP，目标端口，协议），只要这5元里边有一个不同，就被认为是不同的SOCKET。<br>我们这里的这些socket中除了 ‘监听’socket 比较特殊， 是没有第三第四项的。 其他n个socket 5个元素都有，区别仅是目标IP不一样。</p><p>具体分析，listen是不阻塞的，创建了等待列表，允许操作系统开始接收客户，完成连接阶段并把它们放入等待被服务的列表。<br>然后，server开始循环并逐一 对客户进行服务。在每次循环中，server进程 调用accept函数， 从已经连接客户的等待列表中去除一个客户，对其进行服务。  </p></blockquote><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">Socket的TCP通讯</span><br><span class="line"></span><br><span class="line">一、 socket的通讯原理</span><br><span class="line"></span><br><span class="line">服务器端的步骤如下。</span><br><span class="line"></span><br><span class="line">（1）建立服务器端的Socket，开始侦听整个网络中的连接请求。</span><br><span class="line"></span><br><span class="line">（2）当检测到来自客户端的连接请求时，向客户端发送收到连接请求的信息，并建立与客户端之间的连接。</span><br><span class="line"></span><br><span class="line">（3）当完成通信后，服务器关闭与客户端的Socket连接。</span><br><span class="line"></span><br><span class="line">客户端的步骤如下。</span><br><span class="line"></span><br><span class="line">（1）建立客户端的Socket，确定要连接的服务器的主机名和端口。</span><br><span class="line"></span><br><span class="line">（2）发送连接请求到服务器，并等待服务器的回馈信息。</span><br><span class="line"></span><br><span class="line">（3）连接成功后，与服务器进行数据的交互。</span><br><span class="line"></span><br><span class="line">（4）数据处理完毕后，关闭自身的Socket连接。</span><br><span class="line"></span><br><span class="line">二、 socket的通讯方式</span><br><span class="line"></span><br><span class="line">socket通讯方式有两种：同步和异步</span><br><span class="line"></span><br><span class="line">同步工作方式:</span><br><span class="line"></span><br><span class="line">用TCP协议进行编程时程序执行到发送、接收和监听语句的时候，在未完成工作前不再继续往下执行，即处于阻塞状态，直到该语句完成某个工作后才继续执行下一条语句。</span><br><span class="line"></span><br><span class="line">异步工作方式</span><br><span class="line"></span><br><span class="line">程序执行到发送、接收和监听语句的时候，不论工作是否完成，都会继续往下执行。</span><br><span class="line"></span><br><span class="line">三、 socket的C#实现</span><br><span class="line"></span><br><span class="line">1.同步： </span><br><span class="line">服务端客户端通信：</span><br><span class="line"></span><br><span class="line">在与服务端的连接建立以后，我们就可以通过此连接来发送和接收数据。端口与端口之间以流（Stream）的形式传输数据，因为几乎任何对象都可以保存到流中，所以实际上可以在客户端与服务端之间传输任何类型的数据。对客户端来说，往流中写入数据，即为向服务器传送数据；从流中读取数据，即为从服务端接收数据。对服务端来说，往流中写入数据，即为向客户端发送数据；从流中读取数据，即为从客户端接收数据。</span><br><span class="line"> </span><br><span class="line">服务端： </span><br><span class="line"></span><br><span class="line">（1）服务端对端口进行侦听：</span><br><span class="line"></span><br><span class="line">服务器端建立一个socket，设置好本机的ip和监听的端口与socket进行绑定，开始监听连接请求，当接收到连接请求后，发送确认，同客户端建立连接，开始与客户端进行通信。</span><br><span class="line"></span><br><span class="line">TcpListener listener =new TcpListener(new IPEndPoint(IPAddress.Parse(ip), port));//ip为服务器IP地址，port为监听的端口</span><br><span class="line"></span><br><span class="line">Listener.Start();//开启监听</span><br><span class="line"></span><br><span class="line">(2)检测来自客户端的连接请求</span><br><span class="line"></span><br><span class="line">TcpClient remoteClient = listener.AcceptTcpClient();</span><br><span class="line">//接收客户端  这里体现了同步的含义，如果客户端对该服务端发起连接的时候，程序在这里就会等待（阻塞），直到有客户端的连接请求为止</span><br><span class="line"></span><br><span class="line">(3)建立和连接的客户端的数据流（传输数据）</span><br><span class="line"></span><br><span class="line">NetworkStream streamToClient = remoteClient.GetStream();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">该数据流只要是用来接收和发送数据，同步也分多客户端和单个客户端，如果分的详细一点的话，还有客户端的一条以及多条数据的情况，如果是单个客户端的多条数据的话，连接客户端之后，在建立数据流的前面添加一个循环就可以了，如果是多个客户端的话，在（2）前面加个循环就可以了。为了接收数据的效率，建议不管是同步还是异步，服务端都做成线程，详细见Demo</span><br><span class="line"></span><br><span class="line">(4)接收客户端发送过来的数据（用缓存来接收）</span><br><span class="line"></span><br><span class="line">byte[] buffer = new byte[BufferSize];  // BufferSize为缓存的大小</span><br><span class="line"> </span><br><span class="line"> int bytesRead; </span><br><span class="line"> try </span><br><span class="line"> &#123; </span><br><span class="line">    lock (streamToClient)//为了保证数据的完整性以及安全性  锁定数据流 </span><br><span class="line">     &#123; </span><br><span class="line">         bytesRead = streamToClient.Read(buffer, 0, BufferSize);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">(5)向连接的客户端发送数据 </span><br><span class="line">lock (streamToClient) </span><br><span class="line">    &#123; </span><br><span class="line">        streamToClient.Write(buffer, 0, buffer.Length);//buffer为发送的字符数组   </span><br><span class="line">    &#125;</span><br><span class="line">(6)释放数据流和TcpClient（以便下次的数据以及客户端的收发）</span><br><span class="line"></span><br><span class="line">streamToClient.Dispose();//释放数据流中的数据</span><br><span class="line"> </span><br><span class="line">  remoteClient.Close();//释放TcpClient实例</span><br><span class="line"></span><br><span class="line">客户端：</span><br><span class="line"></span><br><span class="line">1）连接服务器</span><br><span class="line"></span><br><span class="line">TcpClient tcp = new TcpClient(); </span><br><span class="line">tcp.Connect(IP,Port);//根据服务器的IP地址和侦听的端口连接</span><br><span class="line">if (tcp.Connected)</span><br><span class="line">&#123; </span><br><span class="line">//连接成功的消息机制  详细见DEMO</span><br><span class="line">ShowGetData(&quot;成功连接上了服务器：&quot;, this.strIP.Text.ToString());</span><br><span class="line">&#125;</span><br><span class="line">这里需要注意的是，不管是使用有参数的构造函数与服务器连接，或者是通过Connect()方法与服务器建立连接，都是同步方法（或者说是阻塞的，英文叫block）。它的意思是说，客户端在与服务端连接成功、从而方法返回，或者是服务端不存、从而抛出异常之前，是无法继续进行后继操作的。这里还有一个名为BeginConnect()的方法，用于实施异步的连接，这样程序不会被阻塞，可以立即执行后面的操作，这是因为可能由于网络拥塞等问题，连接需要较长时间才能完成。网络编程中有非常多的异步操作，凡事都是由简入难，关于异步操作，我们后面再讨论，现在只看同步操作。</span><br><span class="line"></span><br><span class="line">（2）建立连接服务端的数据流</span><br><span class="line">NetworkStream streamToServer = tcp.GetStream();</span><br><span class="line">（3）接收和发送数据 </span><br><span class="line">//发送字符串</span><br><span class="line"> </span><br><span class="line">        byte[] buffer = Encoding.Unicode.GetBytes(msg); //msg为发送的字符串    </span><br><span class="line">        try </span><br><span class="line">          &#123; </span><br><span class="line">                 lock (streamToServer) </span><br><span class="line">                &#123; </span><br><span class="line">                    streamToServer.Write(buffer, 0, buffer.Length);     // 发往服务器 </span><br><span class="line">                &#125;  </span><br><span class="line">              //接收字符串 </span><br><span class="line">                buffer = new byte[BufferSize];</span><br><span class="line">               lock (streamToServer) </span><br><span class="line">                &#123;</span><br><span class="line">                    bytesRead = streamToServer.Read(buffer, 0, BufferSize);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">2.异步 </span><br><span class="line">    相对于同步，异步中的连接，接收和发送数据的方法都不一样，都有一个回调函数，就是即使不能连接或者接收不到数据，程序还是会一直执行下去，如果连接上了或者接到数据，程序会回到这个回调函数的地方重新往下执行。详细见下面： </span><br><span class="line">服务器 </span><br><span class="line">1、 开启侦听接口</span><br><span class="line"></span><br><span class="line">private TcpListener listener;               //监听类</span><br><span class="line"> </span><br><span class="line">listener = new TcpListener(new IPEndPoint(IPAddress.Parse(ip), port));</span><br><span class="line"> </span><br><span class="line">listener.Start();//开启侦听，对连接的客户端的数目没有限制</span><br><span class="line"> </span><br><span class="line">或者</span><br><span class="line"> </span><br><span class="line">listener.Start(int i);// 开启侦听，最多只能连接i个客户端数目</span><br><span class="line">2、 接收客户端</span><br><span class="line"></span><br><span class="line"> listener.BeginAcceptSocket(clientConnect, listener);//异步接受客户端的连接请求  clientConnect为连接的回调函数 </span><br><span class="line">/// &lt;summary&gt; </span><br><span class="line">        /// 接收回调函数 </span><br><span class="line">        /// &lt;/summary&gt; </span><br><span class="line">        /// &lt;param name=&quot;ar&quot;&gt;&lt;/param&gt; </span><br><span class="line">        private void clientConnect(IAsyncResult ar) </span><br><span class="line">        &#123; </span><br><span class="line">            try </span><br><span class="line">            &#123; </span><br><span class="line">                TcpListener listener = (TcpListener)ar.AsyncState; </span><br><span class="line">                //接受客户的连接,得到连接的Socket </span><br><span class="line">                Socket client = listener.EndAcceptSocket(ar);  </span><br><span class="line">            &#125; </span><br><span class="line">            catch &#123; &#125; </span><br><span class="line">        &#125;</span><br><span class="line">3、 接收客户端发送的数据 </span><br><span class="line">/// &lt;summary&gt; </span><br><span class="line">        /// 异步接收数据 </span><br><span class="line">        /// &lt;/summary&gt; </span><br><span class="line">        private void receiveData(Socket client) </span><br><span class="line">        &#123; </span><br><span class="line">                // 调用异步方法 BeginReceive 来告知 socket 如何接收数据 </span><br><span class="line">           IAsyncResult iar = client.BeginReceive(buffer, 0, BagSize,                                   SocketFlags.None, out errorCode, receiveCallback, buffer);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125; </span><br><span class="line">        /// &lt;summary&gt; </span><br><span class="line">        /// 接收数据回调函数 </span><br><span class="line">        /// &lt;/summary&gt; </span><br><span class="line">        /// &lt;param name=&quot;ar&quot;&gt;&lt;/param&gt; </span><br><span class="line">        private void receiveCallback(IAsyncResult ar) </span><br><span class="line">        &#123;           </span><br><span class="line">                //接收到的数据长度． </span><br><span class="line">                int receLen = 0; </span><br><span class="line">                try </span><br><span class="line">                &#123; </span><br><span class="line">                    receLen = client.EndReceive(ar, out errorCode);      </span><br><span class="line">if (receLen &gt; 0) </span><br><span class="line">                    &#123; </span><br><span class="line">                        OnReceiveData(client);//接收到数据之后的处理函数 </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                catch &#123;     &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            else &#123; &#125; </span><br><span class="line">        &#125; </span><br><span class="line">4、接收成功之后，回发数据给客户端</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt; </span><br><span class="line">        /// 异步发送报文 </span><br><span class="line">        /// &lt;/summary&gt; </span><br><span class="line">        /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; </span><br><span class="line">        private void OnReceiveData (Socket socket) </span><br><span class="line">        &#123; </span><br><span class="line">string strLogin = “succeed recived”; </span><br><span class="line">byte[] data = Encoding.ASCII.GetBytes(strLogin); </span><br><span class="line">         socket.BeginSend(data, 0, data.Length, SocketFlags.None, out errorCode,               sendCallBack, socket);//异步发送数据 </span><br><span class="line">             </span><br><span class="line">        &#125;  </span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line"> </span><br><span class="line">        /// 异步发送回调事件</span><br><span class="line"> </span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line"> </span><br><span class="line">        /// &lt;param name=&quot;ar&quot;&gt;&lt;/param&gt;</span><br><span class="line"> </span><br><span class="line">        private void sendCallBack(IAsyncResult ar)</span><br><span class="line"> </span><br><span class="line">        &#123; </span><br><span class="line">socket.EndSend(ar, out errorCode);</span><br><span class="line">        &#125;</span><br><span class="line">客户端 </span><br><span class="line"></span><br><span class="line">1、连接服务器</span><br><span class="line"></span><br><span class="line">private TcpClient tcpcz = null</span><br><span class="line"> </span><br><span class="line">         tcpcz = new TcpClient()</span><br><span class="line"> </span><br><span class="line">    tcpcz.BeginConnect(ipaddress, Convert.ToInt32(port), new AsyncCallback(ConnectCallback), tcpcz);//根据服务器的IP地址和端口号 异步连接服务器</span><br><span class="line">  </span><br><span class="line">        /// &lt;summary&gt; </span><br><span class="line">        /// 异步连接的回调函数 </span><br><span class="line">        /// &lt;/summary&gt; </span><br><span class="line">        /// &lt;param name=&quot;ar&quot;&gt;&lt;/param&gt; </span><br><span class="line">        private void ConnectCallback(IAsyncResult ar)</span><br><span class="line"> </span><br><span class="line">        &#123; </span><br><span class="line">            TcpClient t = (TcpClient)ar.AsyncState; </span><br><span class="line">            try </span><br><span class="line">            &#123; </span><br><span class="line">                if (t.Connected) </span><br><span class="line">                &#123; </span><br><span class="line">                    t.EndConnect(ar);//函数运行到这里就说明连接成功 </span><br><span class="line">                &#125; </span><br><span class="line">                else </span><br><span class="line">                &#123; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            catch () &#123;    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">2、发送和接收字符串  </span><br><span class="line">NetworkStream stream = tcp.GetStream();//创建于服务器连接的数据流 </span><br><span class="line">                  //发送字符串 </span><br><span class="line">             string strLogin = “this is socket example”; </span><br><span class="line">             byte[] data = Encoding.ASCII.GetBytes(strLogin); </span><br><span class="line">            stream.BeginWrite(data, 0, data.Length, new     AsyncCallback(SendCallback),stream);//异步发送数据 </span><br><span class="line">                  //接收字符串 </span><br><span class="line">        byte[] result = new byte[tcp.Available]; // tcp.Available为接受的字符串大小</span><br><span class="line">                  try</span><br><span class="line">                  &#123;</span><br><span class="line">                      stream.BeginRead(result, 0, result.Length, new AsyncCallback(ReadCallback), stream);//异步接受服务器回报的字符串 </span><br><span class="line">                  &#125;</span><br><span class="line">                  catch &#123; &#125;</span><br><span class="line">                  string strResponse = Encoding.ASCII.GetString(result).Trim();//从服务器接受到的字符串 </span><br><span class="line">              &#125; </span><br><span class="line">          &#125;</span><br><span class="line">          catch ()</span><br><span class="line">          &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-多线程与socket通信"><a href="#5-多线程与socket通信" class="headerlink" title="5.多线程与socket通信"></a>5.多线程与socket通信</h3><p>服务器端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">using System;  </span><br><span class="line">using System.Collections.Generic;  </span><br><span class="line">using System.Linq;  </span><br><span class="line">using System.Text;  </span><br><span class="line">using System.Net;  </span><br><span class="line">using System.Net.Sockets;  </span><br><span class="line">using System.Threading;  </span><br><span class="line">  </span><br><span class="line">namespace multithreadservTest  </span><br><span class="line">&#123;  </span><br><span class="line">    class Threadtcpserver  </span><br><span class="line">    &#123;  </span><br><span class="line">  </span><br><span class="line">/* 本程序中采用了多线程技术，可以应付多客户的需求。首先，程序的主线程也就是程序的入口即Main（）函数， </span><br><span class="line"> * 当执行到Accept方法时，线程变会阻塞；当有新连接时，就创建相应的消息服务线程。而主程序则继续进行监听， </span><br><span class="line"> * 检查有没有新的连接进入。如果客户端有向服务器连接的请求，那么就把连接句柄传递给接收的套接字。由于线程 </span><br><span class="line"> * 的调度和切换是非常快的，快得足以让我们分辨不出程序的运行顺序，所以从宏观上来讲，可以说程序是并行执行 </span><br><span class="line"> * 的。但事实上，从微观的角度上说，只是cpu飞快地调度线程，让我们感觉好像可以同时接收连接和处理消息一样， </span><br><span class="line">         * 但在一个时刻，只有一个线程是处于运行状态的。 </span><br><span class="line">         */   </span><br><span class="line">        /// &lt;summary&gt;  </span><br><span class="line">        /// 下面这段代码的业务逻辑是：  </span><br><span class="line">        /// （1）创建套接字server，并将其与本地终结点iep进行绑定。然后，在13000端口上监听是否  </span><br><span class="line">                  有新的客户端进行连接  </span><br><span class="line">        /// （2）在无限循环中有一个阻塞的方法Accept，该方法直到有新客户端连接到服务器上时，把  </span><br><span class="line">                  客户端的套接字信息传递给client对象。否则，将阻塞 直到有客户机进行连接。  </span><br><span class="line">        /// （3）ClientThread类负责客户端与服务器端之间的通信。先把客户端的套接字句柄传递给  </span><br><span class="line">        ///       负责消息服务的ClientThread类。然后，把ClientThread类 的ClientService方  </span><br><span class="line">                  法委托给线程，并启动线程。   </span><br><span class="line">        /// &lt;/summary&gt;  </span><br><span class="line">        private Socket server;  </span><br><span class="line">        public Threadtcpserver()  </span><br><span class="line">        &#123;  </span><br><span class="line">            //初始化IP地址  </span><br><span class="line">            IPAddress local=IPAddress.Parse(&quot;192.168.5.187&quot;);  </span><br><span class="line">            IPEndPoint iep = new IPEndPoint(local, 13000);  </span><br><span class="line">            server = new Socket(AddressFamily.InterNetwork, SocketType.Stream,  </span><br><span class="line">            ProtocolType.Tcp);  </span><br><span class="line">            //将套接字与本地终结点绑定  </span><br><span class="line">            server.Bind(iep);  </span><br><span class="line">            //在本地13000端口号上进行监听  </span><br><span class="line">            server.Listen(20);  </span><br><span class="line">            Console.WriteLine(&quot;等待客户机进行连接......&quot;);  </span><br><span class="line">            while (true)  </span><br><span class="line">            &#123;  </span><br><span class="line">                //得到包含客户端信息的套接字  </span><br><span class="line">                Socket client = server.Accept();  </span><br><span class="line">                //创建消息服务线程对象  </span><br><span class="line">                ClientThread newclient = new ClientThread(client);  </span><br><span class="line">                //把ClientThread类的ClientService方法委托给线程  </span><br><span class="line">                Thread newthread = new Thread(new ThreadStart(newclient.ClientService));  </span><br><span class="line">                //启动消息服务线程  </span><br><span class="line">                newthread.Start();  </span><br><span class="line">                       </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;    </span><br><span class="line">        /// &lt;summary&gt;  </span><br><span class="line">        /// （1）在构造函数中得到接收到的客户套接字client，以后就通过service句柄处理消息的接收  </span><br><span class="line">         ///      和发送。  </span><br><span class="line">        /// （2）ClientService方法是委托给线程的，此方法进行消息的处理工作。在这里实现的功能是，  </span><br><span class="line">        ///       先从客户端接收一条消息，然后把这条消息转换为大写字母，并立即发送一条应答的消息，  </span><br><span class="line">        ///      也就是所谓的echo技术，通常用来进行消息之间的传递。  </span><br><span class="line">        /// （3）还有就是通过connections变量来记录活动的连接数。当有新增连接或断开连接的情况发   </span><br><span class="line">        ///       生时，都会体现出connections的变化。  </span><br><span class="line">       /// &lt;/summary&gt;  </span><br><span class="line">        public class ClientThread  </span><br><span class="line">        &#123;  </span><br><span class="line">            //connections变量表示连接数  </span><br><span class="line">            public static int connections = 0;  </span><br><span class="line">            public Socket service;  </span><br><span class="line">            int i;  </span><br><span class="line">            //构造函数  </span><br><span class="line">            public ClientThread(Socket clientsocket)  </span><br><span class="line">            &#123;  </span><br><span class="line">                //service对象接管对消息的控制  </span><br><span class="line">                this.service = clientsocket;  </span><br><span class="line">            &#125;  </span><br><span class="line">            public void ClientService()  </span><br><span class="line">            &#123;  </span><br><span class="line">                String data = null;  </span><br><span class="line">                byte[] bytes = new byte[1024];  </span><br><span class="line">                //如果Socket不是空，则连接数加1  </span><br><span class="line">                if (service != null)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    connections++;  </span><br><span class="line">                &#125;  </span><br><span class="line">                Console.WriteLine(&quot;新客户连接建立：&#123;0&#125;个连接数&quot;, connections);  </span><br><span class="line">                while((i=service.Receive(bytes))!=0)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);  </span><br><span class="line">                    Console.WriteLine(&quot;收到的数据：&#123;0&#125;&quot;, data);  </span><br><span class="line">                    //处理客户端发来的消息，这是转化为大写字母  </span><br><span class="line">                    data = data.ToUpper();  </span><br><span class="line">                    byte[] msg = System.Text.Encoding.ASCII.GetBytes(data);  </span><br><span class="line">                    //发送一条应答消息  </span><br><span class="line">                    service.Send(msg);  </span><br><span class="line">                    Console.WriteLine(&quot;发送的数据：&#123;0&#125;&quot;, data);  </span><br><span class="line">                &#125;  </span><br><span class="line">                //关闭套接字  </span><br><span class="line">                service.Close();  </span><br><span class="line">                connections--;  </span><br><span class="line">                Console.WriteLine(&quot;客户关闭连接：&#123;0&#125;个连接数&quot;, connections);  </span><br><span class="line">            &#125;   </span><br><span class="line">            /// &lt;summary&gt;  </span><br><span class="line">            /// Main函数十分简单，生成和一个Threadtcpserver实例，然后构造函数就会一步一步地  </span><br><span class="line">              /// 展开，开始执行具体的业务逻辑。  </span><br><span class="line">            /// &lt;/summary&gt;  </span><br><span class="line">            /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;  </span><br><span class="line">            static void Main(string[] args)  </span><br><span class="line">            &#123;  </span><br><span class="line">                Threadtcpserver instance = new Threadtcpserver();  </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using System;  </span><br><span class="line">using System.Collections.Generic;  </span><br><span class="line">using System.Linq;  </span><br><span class="line">using System.Text;  </span><br><span class="line">using System.Net;  </span><br><span class="line">using System.Net.Sockets;    </span><br><span class="line">namespace multithreadclientTest  </span><br><span class="line">&#123;  </span><br><span class="line">    class Program  </span><br><span class="line">    &#123;  </span><br><span class="line">        /// &lt;summary&gt;  </span><br><span class="line">        /// 本程序代码的主要功能：  </span><br><span class="line">        /// （1）创建套接字，并通过connect方法连接到本地终结点。当连接建立以后，便可以与服务器进  </span><br><span class="line">        ///       行通讯了。  </span><br><span class="line">        /// （2）在客户端上等待用户输入一条消息，该消息会发送到服务器创建的消息服务线程上  </span><br><span class="line">        ///       的ClientService 方法上进行处理。在将该消息转化为大写字母后，发还给客户端。  </span><br><span class="line">        ///       这是一个echo技术。如果在控制台上输入exit 接断开与服务器之间的连接。  </span><br><span class="line">        /// &lt;/summary&gt;  </span><br><span class="line">        /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;  </span><br><span class="line">        static void Main(string[] args)  </span><br><span class="line">        &#123;  </span><br><span class="line">            Socket client;  </span><br><span class="line">            byte[] buf = new byte[1024];  </span><br><span class="line">            string input;  </span><br><span class="line">            IPAddress local = IPAddress.Parse(&quot;192.168.5.187&quot;);  </span><br><span class="line">            IPEndPoint iep = new IPEndPoint(local, 13000);  </span><br><span class="line">  </span><br><span class="line">            try  </span><br><span class="line">            &#123;  </span><br><span class="line">                client = new Socket(AddressFamily.InterNetwork, SocketType.Stream,  </span><br><span class="line">                ProtocolType.Tcp);  </span><br><span class="line">                client.Connect(iep);  </span><br><span class="line">            &#125;  </span><br><span class="line">            catch (SocketException)  </span><br><span class="line">            &#123;  </span><br><span class="line">                Console.WriteLine(&quot;无法连接到服务器！&quot;);  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            finally  </span><br><span class="line">            &#123;   </span><br><span class="line">            &#125;  </span><br><span class="line">            while (true)  </span><br><span class="line">            &#123;  </span><br><span class="line">                //在控制台上输入一条消息  </span><br><span class="line">                input = Console.ReadLine();  </span><br><span class="line">                //输入exit，可以断开与服务器的连接  </span><br><span class="line">                if (input == &quot;exit&quot;)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                client.Send(Encoding.ASCII.GetBytes(input));  </span><br><span class="line">                //得到实际收到的字节总数  </span><br><span class="line">                int rec = client.Receive(buf);  </span><br><span class="line">                Console.WriteLine(Encoding.ASCII.GetString(buf, 0, rec));  </span><br><span class="line">  </span><br><span class="line">            &#125;  </span><br><span class="line">            Console.WriteLine(&quot;断开与服务器的连接......&quot;);  </span><br><span class="line">            client.Close();  </span><br><span class="line">   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高并发的socket的高性能设计"><a href="#6-高并发的socket的高性能设计" class="headerlink" title="6.高并发的socket的高性能设计"></a>6.<strong>高并发的socket的高性能设计</strong></h3><p>常见的socket的四种模型==&gt;<a href="https://blog.csdn.net/m_buddy/article/details/70242410" target="_blank" rel="noopener">https://blog.csdn.net/m_buddy/article/details/70242410</a></p><p>首先来看看课本和学习资料上关于处理并发网络编程的三种常用方案，以及对应的大体思路和优缺点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1) IO多路复用模型</span><br><span class="line"></span><br><span class="line">    -&gt;思路：单进程（非多线程）调用select()函数来处理多个连接请求。</span><br><span class="line"></span><br><span class="line">    -&gt;优点：单进程（非多线程）可支持同时处理多个网络连接请求。</span><br><span class="line"></span><br><span class="line">    -&gt;缺点：最大并发为1024个，当并发数较大时，其处理性能很低。</span><br><span class="line"></span><br><span class="line"> 2) 多进程模型</span><br><span class="line"></span><br><span class="line">    -&gt;思路：当连接请求过来时，主进程fork产生一个子进程，让子进程负责与客户端连接进行数据通信，当客户端主动关闭连接后，子进程结束运行。</span><br><span class="line"></span><br><span class="line">    -&gt;优点：模式简单，易于理解；连接请求很小时，效率较高。</span><br><span class="line"></span><br><span class="line">    -&gt;缺点：当连接请求过多时，系统资源很快被耗尽。比如：当连接请求达到10k时，难道要启动10k个进程吗？</span><br><span class="line"></span><br><span class="line">  3) 多线程模型</span><br><span class="line"></span><br><span class="line">    -&gt;思路：首先启动多个工作线程，而主线程负责接收客户端连接请求，工作线程负责与客户端通信；当连接请求过来时，ACCEPT线程将sckid放入一个数组中，工作线程中的空闲线程从数组中取走一个sckid，对应的工作线程再与客户端连接进行数据通信，当客户端主动关闭连接后，此工作线程又去从指定数组中取sckid，依次重复运行。</span><br><span class="line"></span><br><span class="line">    -&gt;优点：拥有方案２)的优点，且能够解决方案２)的缺点。</span><br><span class="line"></span><br><span class="line">    -&gt;缺点：不能支持并发量大的请求和量稍大的长连接请求。</span><br><span class="line"></span><br><span class="line"> 通过对以上三种方案的分析，以上方案均不能满足高并发、高性能的服务器的处理要求。针对以上设计方案问题的存在，该如何设计才能做到高并发、高性能的处理要求呢？</span><br></pre></td></tr></table></figure><p>高并发网络编程之epoll详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。</span><br><span class="line"></span><br><span class="line">本文便来介绍epoll的实现机制，并附带讲解一下select和poll。通过对比其不同的实现机制，真正理解为何epoll能实现高并发。</span><br><span class="line"></span><br><span class="line">select()和poll() IO多路复用模型</span><br><span class="line">select的缺点：</span><br><span class="line"></span><br><span class="line">单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE    1024)</span><br><span class="line">内核 / 用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销；</span><br><span class="line">select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</span><br><span class="line">select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</span><br><span class="line">相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</span><br><span class="line"></span><br><span class="line">拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。</span><br><span class="line"></span><br><span class="line">因此，该epoll上场了。</span><br><span class="line"></span><br><span class="line">epoll IO多路复用模型实现机制</span><br><span class="line">由于epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。</span><br><span class="line"></span><br><span class="line">设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</span><br><span class="line"></span><br><span class="line">在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</span><br><span class="line"></span><br><span class="line">epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：</span><br><span class="line"></span><br><span class="line">1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</span><br><span class="line"></span><br><span class="line">2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</span><br><span class="line"></span><br><span class="line">3）调用epoll_wait收集发生的事件的连接</span><br><span class="line"></span><br><span class="line">如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</span><br></pre></td></tr></table></figure><h3 id="7-粘包、分包、拆包"><a href="#7-粘包、分包、拆包" class="headerlink" title="7.粘包、分包、拆包"></a>7.粘包、分包、拆包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">粘包</span><br><span class="line"></span><br><span class="line">    使用TCP长连接就会引入粘包的问题，粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。粘包可能由发送方造成，也可能由接收方造成。TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据，造成多个数据包的粘连。如果接收进程不及时接收数据，已收到的数据就放在系统接收缓冲区，用户进程读取数据时就可能同时读到多个数据包。</span><br><span class="line"></span><br><span class="line">    粘包一般的解决办法是制定通讯协议，由协议来规定如何分包解包。 </span><br><span class="line">分包</span><br><span class="line"></span><br><span class="line">    在IOCPDemo例子程序中，我们分包的逻辑是先发一个长度，然后紧接着是数据包内容，这样就可以把每个包分开。</span><br><span class="line"></span><br><span class="line">    应用层数据包格式如下：</span><br><span class="line"></span><br><span class="line">    应用层数据包格式  </span><br><span class="line">    数据包长度Len：Cardinal（<span class="number">4</span>字节无符号整数） 数据包内容，长度为Len</span><br><span class="line">    IOCPSocket分包处理主要代码，我们收到的数据都是在TSocketHandle.ProcessIOComplete方法中处理：</span><br></pre></td></tr></table></figure><h3 id="8-http的工作流程"><a href="#8-http的工作流程" class="headerlink" title="8.http的工作流程"></a>8.http的工作流程</h3><p><img src="/2019/09/09/PersonaDocument/image_1d9oni5bs6tj1ov414g353a1qdn9.png" alt="image_1d9oni5bs6tj1ov414g353a1qdn9"></p><hr><hr><p><img src="/2019/09/09/PersonaDocument/image_1d9onkskg2vq10mnj0recp1alem.png" alt="image_1d9onkskg2vq10mnj0recp1alem"></p><h3 id="9-对handle的认识"><a href="#9-对handle的认识" class="headerlink" title="9.对handle的认识"></a>9.对handle的认识</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">句柄是一种指向指针的指针。我们知 道，所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是住留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，那么就可以随时用这个地址 访问对象。但是，如果您真的这样认为，那么您就大错特错了。 </span><br><span class="line">       我们知道，Windows是一 个以虚拟内存为基础的操作系统。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化 了。如果地址总是如此变化，我们该到哪里去找该对象呢? </span><br><span class="line">        为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门 登记各应用对象在内存中的地址变化，而这个地址(存储单元的位置)本身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。 </span><br><span class="line">        这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。 </span><br><span class="line">       句柄地址(稳定)→记载着对象在内存中的地址────→对象在内存中的地址(不稳定) →实际对象但是，必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看成 是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电 影院售给我们的门票总是不同的一个座位是一样的道理。</span><br></pre></td></tr></table></figure><h3 id="10-系统调用"><a href="#10-系统调用" class="headerlink" title="10.系统调用"></a>10.系统调用</h3><blockquote><p>所谓系统调用就是用户在程序中调用操作系统所提供的一个子功能，也就是系统API，系统调用可以被看做特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/O传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十个乃至上百个之多。</p><hr><p>显然，系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。系统调用命令式由操作系统提供的一个或多个子程序模块来实现的。</p></blockquote><p>系统调用过程</p><p>首先将API函数参数压到栈上，然后将函数内调用系统调用的代码放入寄存器，通过陷入中断，进入内核将控制权交给操作系统，操作系统获得控制后，将系统调用代码拿出来，跟操作系统一直维护的一张系统调用表做比较，已找到该系统调用程序体的内存地址，接着访问该地址，执行系统调用。执行完毕后，返回用户程序</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  int main() </span><br><span class="line">  &#123;</span><br><span class="line">      int fd = create(&quot;filename&quot;,0666);</span><br><span class="line">    exit(0); </span><br><span class="line">  &#125; </span><br><span class="line">  在执行main函数时，是在user mode下执行，当遇到create函数时，继续在user mode下执行，然后将filename和0666两个参数压入栈中寄存器，接着调用库函数create，系统仍然处于user mode。这里的库函数create实际上调用了内核的系统调用create，执行到这里后，系统将create系统调用的unique number压入寄存器，然后执行指令trap使系统进入kernel mode(执行int $0x80产生中断)。这时系统意识到要进行系统调用的invoke，于是从刚才的寄存器中取出create系统调用的unique number，从系统调用表中得知要invoke的系统调用是create，然后执行。执行完毕返回库函数create的调用，库函数负责检查系统调用的执行情况(检查某些寄存器的值)，然后库函数create根据检查的结果返回响应的值。</span><br><span class="line"></span><br><span class="line">  这里trap指令类似于一个系统中断并且是软中断，而系统调用create类似于一个中断处理函数所有的系统调用都与上边的情况类似，靠中断机制切换到内核模式实现。</span><br><span class="line"></span><br><span class="line">系统调用通常比库函数要慢，因为要把上下文环境切换到内核模式。</span><br></pre></td></tr></table></figure><h3 id="11-数据库水平扩展、垂直扩展"><a href="#11-数据库水平扩展、垂直扩展" class="headerlink" title="11 数据库水平扩展、垂直扩展"></a>11 数据库水平扩展、垂直扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 在互联网应用中。数据库经常是我们存储和訪问数据的经常使用介质。随着负载的增大，对数据库读写性能的要求往往成为非常大的挑战。在这种情况下我们能够考虑数据库相关的replication机制提高读写的性能。因为一般採用一写多读的replication机制（写master同步到多个slaves），导致这种机制往往会有缺陷。首先它依赖于读写的比例，假设写的操作过多，导致master往往成为性能的瓶颈所在，从而使得slaves的数据同步延迟也变大，进而大大消耗CPU的资源，而且导致数据的不一致从而影响到用户的体验。</span><br><span class="line"></span><br><span class="line">       这个时候我们就要考虑使用数据库的sharding（分片）机制，这里面我们所说sharding机制并非一个数据库软件的附属功能，而是一种相对简朴的软件理念。</span><br><span class="line"></span><br><span class="line">一般我们把sharding机制分成水平扩展（横向扩展，或者向外扩展）和垂直扩展两种方式。</span><br><span class="line"></span><br><span class="line">详细什么是数据库的水平扩展和垂直扩展呢？我们以以下的样例来说明。</span><br><span class="line"></span><br><span class="line">       比方我们如今有两个表：用户信息表 产品订单表</span><br><span class="line"></span><br><span class="line">       水平的拆分的方案，即不改动数据库表结构。通过对表中数据的拆分而达到分片的目的：</span><br><span class="line"></span><br><span class="line">       1）使用用户id做hash，分解数据库，在訪问数据库的使用用户id做路由。</span><br><span class="line"></span><br><span class="line">   2）将产品订单表依照已下单和未下单区分成两个表。</span><br><span class="line"></span><br><span class="line">       一般水平拆分在查询数据库的时候可能会用到union操作。 </span><br><span class="line">       </span><br><span class="line">垂直拆分的方案：将表和表分离，或者改动表结构，依照訪问的差异将某些列拆分出去。</span><br><span class="line"></span><br><span class="line">         1）将用户信息表放到一个数据库server，将产品订单表放到一个数据库server。</span><br><span class="line"></span><br><span class="line">         2）将用户信息表中主码（通常是user id）和一些经常使用的信息放到一个表，将主码和不经常使用的信息放到另外的表。这导致一般查询数据的时候可能会用到join操作。</span><br><span class="line"></span><br><span class="line">在数据库的设计中，我们更关注数据库的水平扩展的能力。</span><br></pre></td></tr></table></figure><blockquote><p>Replication的思想是将数据在集群的多个节点同步、备份，以提高集群数据的可用性（HA）；Mysql使用Replication架构来实现上述目的，同时可以提升了集群整体的并发能力。5.6版本作为一个里程碑，对replication做了不少的优化调整，提高了集群数据的一致性、同步的性能以及数据自动恢复（recovery）的能力。（本文内容基于MySQL 5.6+，不过在5.7+版本仍有部分调整）</p><p>　　Replication架构通常由一个master和一个或者多个slaves构成，master接收应用的writes操作（事务中的read、write操作均有master处理），slaves接收read操作。在master上发生的数据变更，都将会复制给slaves，从直观而言，replication架构解决了：1）数据多点备份，提高数据可用性。 2）读写分流，提高集群的并发能力。（并非是负载均衡）3）让一些非实时的数据操作，转移到slaves上进行。</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据分片，是将整体数据分摊在多个存储设备（下文统称为“数据分区”或“分区”）上，这样每个存储设备的数据量相对就会小很多，以此满足系统的性能需求。</span><br><span class="line">Sharding按【方向】可以分为两类。</span><br><span class="line">（1）垂直分片：以表为单位，把不同的表分散到不同的数据库或主机上。特点是规则简单，实施方便，适合业务之间耦合度低的系统。</span><br><span class="line">（2）水平分片：以行为单位，将同一个表中的数据按照某种条件拆分到不同的数据库或主机上。特点是相对复杂，适合单表巨大的系统。</span><br></pre></td></tr></table></figure><h3 id="12-分布式设计"><a href="#12-分布式设计" class="headerlink" title="12.分布式设计"></a>12.分布式设计</h3><h3 id="13-socket安全性"><a href="#13-socket安全性" class="headerlink" title="13.socket安全性"></a>13.socket安全性</h3><p> SSL。它是Secure Socket Layer的，即安全的套接层。</p><p>它就是用于给普通Socket提供安装功能，实现安全的几个主要功能： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：认证; </span><br><span class="line"></span><br><span class="line">2：加密数据，是数据不可读; </span><br><span class="line"></span><br><span class="line">3：防止数据被修改，维持数据完整性;</span><br></pre></td></tr></table></figure><blockquote><ol><li>什么是SSLSocket</li></ol><p>JDK文档指出，SSLSocket扩展Socket并提供使用SSL或TLS协议的安全套接字。</p><p>这种套接字是正常的流套接字，但是它们在基础网络传输协议(如TCP)上添加了安全保护层。</p><p>具体安全方面的讨论见下一篇。本篇重点关注SSLSocket及相关几个类的使用。</p></blockquote><blockquote><p>SSL Socket通讯是对socket的扩展，增加Socket通讯的数据安全性，SSL认证分为单向和双向认证。单向认证只认证服务器端的合法性而不认证客户端的合法性。双向认证是同时认证服务端和客户端。下面我分别说说使用C#实现单向认证和双向认证的过程，并用代码实现。</p></blockquote><blockquote><p>SSL原理<br>比如 A要和B互相通讯，为了安全他们希望双方发送的数据都是经过加密的。这就要求双方有一个共同的加解密密钥(一般加密都是基于对称加密算法)。如何才能让双方都拥有同一个密钥呢？有人说由一方生成发给另一方不就行了。这样就带来另一个问题，如何保证这个传送的密钥是安全的呢？</p><p>ssl实现了通过非对称的RSA加解密原理实现密钥的交换。(这里就不细讲RSA的原理了，不明白的可以先补充一下这部分知识)。我们假设A是服务器端，B是客户端。然后还有一个角色，是一个可信任的第三方CA。A首先生成一个RSA公私钥对，然后再由这个可信的第三方用自己的私钥(为了便于描述， 后面叫CA_PRIVATE_KEY)把这个DES密钥连同RSA公钥一起签发一个客户端证书(后面叫CLIENT_CERT)，这个证书中同时也包含一段签名。</p><p>A会把CA证书(证书中包含CA_PRIVATE_KEY 对应的公钥， 后面叫CA_CERT)连同CLIENT_CERT一起发给客户端，当然客户端也可以由其它途径获取这两个证书(比如由专门的安全设备中导入到本地)。同时RSA私钥(后面叫CLIENT_PRIVATE_KEY)也会一起下发到客户端。</p><p>客户端首先用CA_CERT对CLIENT_CERT做验签，以确保数据确实是由A发出来的。如果验签能过，其实就已经说明B已经认证了A的身份。前面说到CLIENT_CERT包含服务器的公钥，B用这个公钥对一个对称的DES密钥加密，然后可以公开发出去，他不用担心这个密钥会被截取，因为只有A才有CLIENT_PRIVATE_KEY，也只有A才能解密出来这个DES密钥。这样就完成了对称密钥的交换。</p><p>盗个图，流程基本是下面这样的，</p><p> <img src="/2019/09/09/PersonaDocument/1568551213(1" alt="1568551213(1)">.jpg)</p></blockquote><p>大部分时候到这里，SSL通讯前的握手已经完成了，可以进行安全的数据通讯了。不过有时候会有双向认证的需求，也就是A也想认证B。这个时候CLIENT_PRIVATE_KEY就发生作用了，B会用这个私钥自己生成签名，然后发给A来认证。</p><p>这些基本就是SSL的原理了。</p><p>上面讲到的这些流程，如果用程序实现还是有点复杂的。幸运的是，开源库openssl已经帮我们做了大部分的事情(openssl的实现机制更复杂也更灵活，但基本原理跟上面是一致的)。我们只需要调用一些基本的接口就可以完成SSL socket通讯。 </p><h3 id="14-share智能指针的原理"><a href="#14-share智能指针的原理" class="headerlink" title="14.share智能指针的原理"></a>14.share智能指针的原理</h3><p><a href="https://blog.csdn.net/hj605635529/article/details/76984839" target="_blank" rel="noopener">https://blog.csdn.net/hj605635529/article/details/76984839</a></p><h3 id="15-C-中继承在内存中的分布"><a href="#15-C-中继承在内存中的分布" class="headerlink" title="15.C++中继承在内存中的分布"></a>15.C++中继承在内存中的分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    先基类元素后继承类元素</span><br><span class="line"></span><br><span class="line">​        有虚函数只是增加vfptr；继承的类如果有增加虚函数，向vtable增加函数指针</span><br><span class="line"></span><br><span class="line">​        虚继承增加vbptr，注意：虚基类元素排在最后（这个是和 先基类后继承 不同之处）</span><br><span class="line"></span><br><span class="line">​               注意上面，凡是打上了vbptr的类，  DerivedB::m_base都被打到了最后。</span><br><span class="line"></span><br><span class="line">​        vfptr在vbptr之前</span><br></pre></td></tr></table></figure><p>参见<a href="https://www.cnblogs.com/DylanWind/archive/2009/01/12/1373919.html" target="_blank" rel="noopener">https://www.cnblogs.com/DylanWind/archive/2009/01/12/1373919.html</a></p><h3 id="16教你快速理解大端和小端"><a href="#16教你快速理解大端和小端" class="headerlink" title="16教你快速理解大端和小端"></a>16教你快速理解大端和小端</h3><p>解释：</p><p><strong>大端</strong>：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。</p><p>比如整型变量 0x12345678 占 4 个字节，那么根据内存地址从小到大它们的存放方式如下：</p><p><img src="http://www.itcast.cn/files/image/201801/20180124150351585.jpg" alt="img"></p><p>小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。所以整型变量 0x12345678 根据内存地址从小到大它们的存放方式如下：</p><p><img src="http://www.itcast.cn/files/image/201801/20180124150401382.jpg" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_little_or_big_endian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(int) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> x0, x1, x2, x3;</span><br><span class="line">    x = <span class="number">0x30313233</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *((<span class="keyword">char</span>*)&amp;x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    x0 = ((<span class="keyword">char</span>*)&amp;x)[<span class="number">0</span>];</span><br><span class="line">    x1 = ((<span class="keyword">char</span>*)&amp;x)[<span class="number">1</span>];</span><br><span class="line">    x2 = ((<span class="keyword">char</span>*)&amp;x)[<span class="number">2</span>];</span><br><span class="line">    x3 = ((<span class="keyword">char</span>*)&amp;x)[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x0="</span> &lt;&lt; x0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x1="</span> &lt;&lt; x1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x2="</span> &lt;&lt; x2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x3="</span> &lt;&lt; x3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于小端序，输出</span></span><br><span class="line"><span class="comment">    x0=3   </span></span><br><span class="line"><span class="comment">    x1=2</span></span><br><span class="line"><span class="comment">    x2=1</span></span><br><span class="line"><span class="comment">    x3=0   //0x30对应到十进制的48，也即是ascii的'0'，作为char类型输出显示为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>17.PV操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> P（S）：①将信号量S的值减1，即S=S-1；</span><br><span class="line"></span><br><span class="line">     ②如果S&gt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。</span><br><span class="line"></span><br><span class="line">V（S）：①将信号量S的值加1，即S=S+1；</span><br><span class="line"></span><br><span class="line">      ②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。</span><br></pre></td></tr></table></figure><p>一般来说，信号量S&gt;=0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；</p><p>当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;农业物联网终端系统&quot;&gt;&lt;a href=&quot;#农业物联网终端系统&quot; class=&quot;headerlink&quot; title=&quot;农业物联网终端系统&quot;&gt;&lt;/a&gt;农业物联网终端系统&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="http://yoursite.com/2019/09/08/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/08/常用设计模式/</id>
    <published>2019-09-08T02:05:02.000Z</published>
    <updated>2019-09-08T03:12:52.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">一概念</span><br><span class="line">单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler（Print Spooler是打印后台处理服务，即管理所有本地和网络打印队列及控制所有打印工作。如果此服务被停用，本地计算机上的打印将不可用。），以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</span><br><span class="line"></span><br><span class="line">应用场景</span><br><span class="line"></span><br><span class="line">外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。</span><br><span class="line"></span><br><span class="line">内部资源：大多数软件都有一个（或多个）属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件。</span><br><span class="line"></span><br><span class="line">二、单例模式特点：</span><br><span class="line">　　<span class="number">1</span>、单例类只能有一个实例。</span><br><span class="line">　　<span class="number">2</span>、单例类必须自己创建自己的唯一实例。</span><br><span class="line">　　<span class="number">3</span>、单例类必须给所有其他对象提供这一实例。</span><br><span class="line"></span><br><span class="line">单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。</span><br><span class="line"></span><br><span class="line">三、线程安全的问题</span><br><span class="line"></span><br><span class="line">一方面在获取单例的时候，要保证不能产生多个实例对象，后面会详细讲到若干种实现方式；</span><br><span class="line"></span><br><span class="line">另一方面，在使用单例对象的时候，要注意单例对象内的实例变量是会被多线程共享的，推荐使用无状态的对象，不会因为多个线程的交替调度而破坏自身状态导致线程安全问题，比如我们常用的VO，DTO等（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题）。</span><br><span class="line"></span><br><span class="line">四、单例模式的选择</span><br><span class="line"></span><br><span class="line">还记得我们最早使用的MVC框架Struts1中的action就是单例模式的，而到了Struts2就使用了多例。在Struts1里，当有多个请求访问，每个都会分配一个新线程，在这些线程，操作的都是同一个action对象，每个用户的数据都是不同的，而action却只有一个。到了Struts2， action对象为每一个请求产生一个实例，并不会带来线程安全问题（实际上servlet容器给每个请求产生许多可丢弃的对象，但是并没有影响到性能和垃圾回收问题，有时间会做下研究）。</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&gt; 概念插播：有状态对象和无状态对象</span><br><span class="line">&gt; 第一：基本概念： </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">1</span>、有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。 </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2</span>、无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 第二：看看代加深影响：</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/** </span></span><br><span class="line"><span class="comment">&gt;  * 有状态bean,有state,user等属性，并且user有存偖功能，是可变的。 </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  * @author Peter Wei </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  */</span> </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulBean</span> &#123;</span>  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">int</span> state;  </span><br><span class="line">&gt;     <span class="comment">// 由于多线程环境下，user是引用对象，是非线程安全的  </span></span><br><span class="line">&gt;     <span class="keyword">public</span> User user;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> state;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">this</span>.state = state;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> user;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">this</span>.user = user;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt; <span class="comment">/** </span></span><br><span class="line"><span class="comment">&gt;  * 无状态bean,不能存偖数据。因为没有任何属性，所以是不可变的。只有一系统的方法操作。 </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  * @author Peter Wei </span></span><br><span class="line"><span class="comment">&gt;  *  </span></span><br><span class="line"><span class="comment">&gt;  */</span> </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessBeanService</span> &#123;</span>  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="comment">// 虽然有billDao属性，但billDao是没有状态信息的，是Stateless Bean.  </span></span><br><span class="line">&gt;     BillDao billDao;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> BillDao <span class="title">getBillDao</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">return</span> billDao;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBillDao</span><span class="params">(BillDao billDao)</span> </span>&#123;  </span><br><span class="line">&gt;         <span class="keyword">this</span>.billDao = billDao;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="keyword">public</span> List&lt;User&gt; findUser(String Id) &#123;  </span><br><span class="line">&gt;          <span class="keyword">return</span> null;  </span><br><span class="line">&gt;     &#125;  </span><br><span class="line">&gt; &#125;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1、线程安全 </span><br><span class="line">&gt; 　　要搞清楚有状态对象和无状态对象，首先需要弄清楚线程安全的问题。如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，那么就是线程安全的。 </span><br><span class="line">&gt; 　　或者说，一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。 </span><br><span class="line">&gt; 　　线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 2、关于线程安全 </span><br><span class="line">&gt; 1） 常量始终是线程安全的，因为只存在读操作。 </span><br><span class="line">&gt; 2） 每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源（共享堆内存）。 </span><br><span class="line">&gt; 3） 局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="饿汉式单例（立即加载方式）"><a href="#饿汉式单例（立即加载方式）" class="headerlink" title="饿汉式单例（立即加载方式）"></a>饿汉式单例（立即加载方式）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>设计一个类，只能生成该类的一个实例</span><br><span class="line">饿汉单例：在类装载时完成了初始化，静态成员对象初始化成功</span><br><span class="line">类加载速度相比懒汉慢，但获取对象的速度快，是一种典型的以时间换取空间的做法</span><br><span class="line">优点：线程安全</span><br><span class="line">缺点：不管你用不用这个对象，他都会先创建出来，会造成浪费内存空间</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleon()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleon()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Singleon* instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">GetSingleon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> instance;</span><br><span class="line">instance = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleon* Singleon::instance = <span class="keyword">new</span> Singleon();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleon* sl1 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl2 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl3 = Singleon::GetSingleon();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的。</p><p>Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点1.线程安全 </span><br><span class="line">2.在类加载的同时已经创建好一个静态对象，调用时反应速度快</span><br><span class="line">缺点资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</span><br></pre></td></tr></table></figure><h4 id="懒汉式单例（延迟加载方式）"><a href="#懒汉式单例（延迟加载方式）" class="headerlink" title="懒汉式单例（延迟加载方式）"></a>懒汉式单例（延迟加载方式）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleon()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleon()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Singleon*instrance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">GetSingleon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == instrance)</span><br><span class="line">&#123;</span><br><span class="line">instrance = <span class="keyword">new</span> Singleon();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象创建成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象已经创建成功，无须再建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instrance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleon* <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> instrance;</span><br><span class="line">instrance = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleon* Singleon::instrance =  <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleon* sl1 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl2 = Singleon::GetSingleon();</span><br><span class="line">Singleon* sl3 = Singleon::GetSingleon();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sl2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例虽然用延迟加载方式实现了懒汉式单例，但在多线程环境下会产生多个single对象，如何改造请看以下方式:</p><p>使用synchronized同步锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton3 single = null;</span><br><span class="line"></span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        </span><br><span class="line">        // 等同于 synchronized public static Singleton3 getInstance()</span><br><span class="line">        synchronized(Singleton3.class)&#123;</span><br><span class="line">          // 注意：里面的判断是一定要加的，否则出现线程安全问题</span><br><span class="line">            if(single == null)&#123;</span><br><span class="line">                single = new Singleton3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法上加synchronized同步锁或是用同步代码块对类加同步锁，此种方式虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton4 &#123;</span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton4() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton4 single = null;</span><br><span class="line"></span><br><span class="line">    // 双重检查</span><br><span class="line">    public static Singleton4 getInstance() &#123;</span><br><span class="line">        if (single == null) &#123;</span><br><span class="line">            synchronized (Singleton4.class) &#123;</span><br><span class="line">                if (single == null) &#123;</span><br><span class="line">                    single = new Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双重检查进一步做了优化，可以避免整个方法被锁，只对需要锁的代码部分加锁，可以提高执行效率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法</span><br><span class="line">缺点第一次加载时不够快，多线程使用不必要的同步开销大</span><br></pre></td></tr></table></figure><ul><li>饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢、获取对象的速度快、以空间换取时间模式、线程安全、</li><li>懒汉式单例模式：在类加载时不初始化、按照需求创建实例、以时间换取空间模式</li></ul><h4 id="静态类实现"><a href="#静态类实现" class="headerlink" title="静态类实现"></a>静态类实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton6 &#123;</span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton6() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 静态内部类</span><br><span class="line">    private static class InnerObject&#123;</span><br><span class="line">        private static Singleton6 single = new Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton6 getInstance() &#123;</span><br><span class="line">        return InnerObject.single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类虽然保证了单例在多线程并发下的线程安全性，<em>但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的</em>。这种情况不多做说明了，使用时请注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法</span><br><span class="line">缺点第一次加载时反应不够快</span><br></pre></td></tr></table></figure><h4 id="静态代码块实现"><a href="#静态代码块实现" class="headerlink" title="静态代码块实现"></a>静态代码块实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton6 &#123;</span><br><span class="line">    </span><br><span class="line">    // 私有构造</span><br><span class="line">    private Singleton6() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static Singleton6 single = null;</span><br><span class="line"></span><br><span class="line">    // 静态代码块</span><br><span class="line">    static&#123;</span><br><span class="line">        single = new Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton6 getInstance() &#123;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="概念理论"><a href="#概念理论" class="headerlink" title="概念理论"></a>概念理论</h3><p>在设计模式中,也存在一个类似的模式，提供一个工厂，根据需要可以创建出各种不同类型的对象，该模式称之为简单工程模式。</p><p> <strong>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</strong></p><p> 简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> 简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</span><br><span class="line">适用场合</span><br><span class="line"></span><br><span class="line">1.在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式；</span><br><span class="line">2.由于对象的创建过程是我们不需要去关心的，而我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，如此，方便后期的程序扩展和维护。</span><br><span class="line">1.主要优点</span><br><span class="line">    简单工厂模式的主要优点如下：</span><br><span class="line"></span><br><span class="line">    (1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。也就是说工厂类封装了变化，封装了对象创建的具体细节，对客户端隐藏对象创建的细节，使得客户类针对接口进行编程。满足&quot;针对接口编程而不是针对具体编程原则&quot;。</span><br><span class="line"></span><br><span class="line">    (2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。满足&quot;迪米特法则，也就是和直接朋友通信原则&quot;。</span><br><span class="line"></span><br><span class="line">    (3) 具体对象创建是一个变化过程，因此把对象的创建封装起来，体现了&quot;封装变化原则&quot;。</span><br><span class="line"></span><br><span class="line">2.主要缺点</span><br><span class="line">       简单工厂模式的主要缺点如下：</span><br><span class="line"></span><br><span class="line">       (1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响，违背&quot;单一原则&quot;。</span><br><span class="line"></span><br><span class="line">       (2)使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</span><br><span class="line"></span><br><span class="line">       (3)系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。违背&quot;开发封闭原则&quot;。</span><br><span class="line"></span><br><span class="line">       (4)简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</span><br><span class="line"></span><br><span class="line">3.简单工程模式具体应用</span><br><span class="line">       (1)通常在使用word办公软件的时候，会根据需要绘制出饼状图，柱状图，折线图等图形。可以提供一个工厂类，根据用户的选择创建出不同类型的图形。</span><br><span class="line"></span><br><span class="line">    (2)QQ空间背景样式，博客背景样式等都提供了各种风格的样式。提供一个工厂，根据用户选择的具体风格样式，创建出各个不同的背景风格，用来装饰QQ空间。</span><br><span class="line"></span><br><span class="line">    (3)网页下载工具的开发: 根据需要可以下载新浪网页、腾讯网页、搜狐网页等。根据用户的选择，把网页类型传进工厂，将下载该类型的网页内容。</span><br><span class="line"></span><br><span class="line">    (4)淘宝购物最后一个支付环节，可以选择货到付款、网上银行、支付宝等类型支付。用户可以选择具体的支付方式完成订单,这也是简单工厂模式的一种应用。</span><br><span class="line"></span><br><span class="line">    (5)电影院打折算法: VIP5折、学生票5折、成人票正常收费等打折算法。</span><br><span class="line"></span><br><span class="line">    (6)多功能计算器的开发:封装加减乘除等运算操作(大话设计模式的例子)</span><br><span class="line"></span><br><span class="line">    (7)在很多游戏场合，游戏角色可以选择各种各样的武器，如:手枪、AK47、步枪、大刀等。</span><br><span class="line"></span><br><span class="line">    (8)如果电脑上装有QQ输入法、搜狗输入法、微软拼音输入法，用户可以设置使用哪种类型的输入法。类似的还可以设置IE浏览器、谷歌浏览器、火狐浏览器。可以设置word2003或者金山的WPS。这些都可以理解为简单工厂模式的一种运用。</span><br><span class="line"></span><br><span class="line">    (9)软件公司决策是否开发哪一种产品，银行卡识别、身份证识别还是驾驶证识别。</span><br><span class="line"></span><br><span class="line">    (10)生活中也有很多类似的工厂: 富士康代工工厂；安踏加工厂；咖啡生产基地；沃尔玛等超市提供各种产品供用户使用；肯德基马当劳等。</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> ProductTypeTag</span><br><span class="line">&#123;</span><br><span class="line">  TypeA,</span><br><span class="line">  TypeB,</span><br><span class="line">  TypeC</span><br><span class="line">&#125;PRODUCTTYPE;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> :</span> <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm ProductA"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> :</span> <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm ProductB"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductC</span> :</span> <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I'm ProductC"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">CreateProduct</span><span class="params">(PRODUCTTYPE type)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> TypeA:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> TypeB:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> TypeC:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProductC();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// First, create a factory object</span></span><br><span class="line">  Factory *ProductFactory = <span class="keyword">new</span> Factory();</span><br><span class="line">  Product *productObjA = ProductFactory-&gt;CreateProduct(TypeA);</span><br><span class="line">  <span class="keyword">if</span> (productObjA != <span class="literal">NULL</span>)</span><br><span class="line">    productObjA-&gt;Show();</span><br><span class="line">  </span><br><span class="line">  Product *productObjB = ProductFactory-&gt;CreateProduct(TypeB);</span><br><span class="line">  <span class="keyword">if</span> (productObjB != <span class="literal">NULL</span>)</span><br><span class="line">    productObjB-&gt;Show();</span><br><span class="line">  </span><br><span class="line">  Product *productObjC = ProductFactory-&gt;CreateProduct(TypeC);</span><br><span class="line">  <span class="keyword">if</span> (productObjC != <span class="literal">NULL</span>)</span><br><span class="line">    productObjC-&gt;Show();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> ProductFactory;</span><br><span class="line">  ProductFactory = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> productObjA;</span><br><span class="line">  productObjA = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> productObjB;</span><br><span class="line">  productObjB = <span class="literal">NULL</span>;    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> productObjC;</span><br><span class="line">  productObjC = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yoursite.com/2019/09/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2019/09/07/布隆过滤器/</id>
    <published>2019-09-07T01:57:00.000Z</published>
    <updated>2019-09-07T01:57:00.213Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20190904Code_record</title>
    <link href="http://yoursite.com/2019/09/05/20190904Code-record/"/>
    <id>http://yoursite.com/2019/09/05/20190904Code-record/</id>
    <published>2019-09-05T01:46:56.000Z</published>
    <updated>2019-09-05T04:00:04.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-最小盒数"><a href="#1-最小盒数" class="headerlink" title="1.最小盒数"></a>1.最小盒数</h2><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        res=i*<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(n==res+<span class="number">4</span>*j)&#123;</span><br><span class="line">                 <span class="built_in">cout</span>&lt;&lt;i+j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                 <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(res+<span class="number">4</span>*j&gt;n)&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Undefinedvalue=<span class="number">-1000</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;variable;</span><br><span class="line"><span class="built_in">string</span> finalstr=<span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vararry;</span><br><span class="line">    <span class="built_in">string</span> tmpstr=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'='</span>||str[i]==<span class="string">'+'</span>)&#123;</span><br><span class="line">            vararry.push_back(tmpstr);</span><br><span class="line">            tmpstr=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmpstr+=str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vararry.push_back(tmpstr);</span><br><span class="line">    <span class="built_in">string</span> pre=vararry[<span class="number">0</span>];</span><br><span class="line">    finalstr=pre;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vararry.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vararry[i][<span class="number">0</span>]&lt;=<span class="string">'9'</span>&amp;&amp;vararry[i][<span class="number">0</span>]&gt;=<span class="string">'0'</span>)&#123;</span><br><span class="line">            res+=<span class="built_in">std</span>::stoi(vararry[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(variable.find(vararry[i])!=variable.end()&amp;&amp;variable[vararry[i]]!=Undefinedvalue)&#123;</span><br><span class="line">                res+=variable[vararry[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                variable[pre]=Undefinedvalue;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    variable[pre]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,str);</span><br><span class="line">        solve(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(variable.find(finalstr)!=variable.end()&amp;&amp;variable[finalstr]!=Undefinedvalue)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;variable[finalstr]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NA"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxlen=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> mask[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> [] 一对失一个</span></span><br><span class="line"><span class="comment"> &#123;&#125; 一对失一个</span></span><br><span class="line"><span class="comment"> ""一对失一个</span></span><br><span class="line"><span class="comment"> ,少一个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">FilteroutSpace</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">   <span class="keyword">int</span> loc=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(str[i]!=<span class="string">' '</span>)&#123;</span><br><span class="line">          tmp+=str[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">string</span> totalstr=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> objmount=<span class="number">0</span>;  <span class="comment">//对象的1个数</span></span><br><span class="line">    <span class="keyword">int</span> linemount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> colonnumber=<span class="number">0</span>;  <span class="comment">//冒号个数</span></span><br><span class="line">    <span class="keyword">int</span>  Keyvalue_pair_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jsonArray=<span class="number">0</span>;<span class="comment">//有几个json数组</span></span><br><span class="line">    <span class="built_in">string</span>  strlist[maxlen];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,strlist[linemount]);</span><br><span class="line">        <span class="keyword">if</span>(strlist[linemount].length()==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        colonnumber+= count(strlist[linemount].begin(),strlist[linemount].end(),<span class="string">':'</span>);</span><br><span class="line">        totalstr+=strlist[linemount];</span><br><span class="line">        linemount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//solve    breaking point: 冒号不会失去</span></span><br><span class="line">    <span class="keyword">int</span> prearryflg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;linemount;i++)<span class="comment">//找出有几个对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        strlist[i]=FilteroutSpace(strlist[i]);<span class="comment">//去除可能有的空格干扰</span></span><br><span class="line">       <span class="keyword">if</span>(((<span class="keyword">int</span>)strlist[i].find(<span class="string">':'</span>))!=<span class="number">-1</span>&amp;&amp;(<span class="keyword">int</span>)strlist[i].find(<span class="string">':'</span>)&gt;=strlist[i].length()<span class="number">-2</span>)&#123;</span><br><span class="line">            objmount++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(((<span class="keyword">int</span>)strlist[i].find(<span class="string">':'</span>))!=<span class="number">-1</span>)<span class="comment">//键值对</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(prearryflg==<span class="number">0</span>)&#123;</span><br><span class="line">               jsonArray++;</span><br><span class="line">                   prearryflg=<span class="number">4</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                prearryflg=<span class="number">4</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           prearryflg=<span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Keyvalue_pair_num=colonnumber-objmount;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">']'</span>)!=objmount||count(totalstr.begin(),totalstr.end(),<span class="string">'['</span>)!=objmount) &#123;</span><br><span class="line">       mask[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">'"'</span>)!=Keyvalue_pair_num*<span class="number">4</span>+objmount*<span class="number">2</span>) &#123;</span><br><span class="line">       mask[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">'&#123;'</span>)!=jsonArray+<span class="number">1</span>||count(totalstr.begin(),totalstr.end(),<span class="string">'&#125;'</span>)!=jsonArray+<span class="number">1</span>) &#123;</span><br><span class="line">       mask[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count(totalstr.begin(),totalstr.end(),<span class="string">','</span>)!=Keyvalue_pair_num-objmount) &#123;</span><br><span class="line">       mask[<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-最小盒数&quot;&gt;&lt;a href=&quot;#1-最小盒数&quot; class=&quot;headerlink&quot; title=&quot;1.最小盒数&quot;&gt;&lt;/a&gt;1.最小盒数&lt;/h2&gt;&lt;h2 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>各大排序算法总结</title>
    <link href="http://yoursite.com/2019/09/04/%E5%90%84%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/09/04/各大排序算法总结/</id>
    <published>2019-09-04T06:19:32.000Z</published>
    <updated>2019-09-04T09:55:01.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(table[j<span class="number">-1</span>]&gt;table[j])</span><br><span class="line">          &#123;</span><br><span class="line">            swap(table[j<span class="number">-1</span>],table[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    insert_sort(table);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;table.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> tmploc=i;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;table.size();j++)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(table[tmploc]&gt;table[j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmploc=j;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       swap(table[i],table[tmploc]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Select_sort(table);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flg=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;table.size()<span class="number">-1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       flg=<span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;table.size()<span class="number">-1</span>-i;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(table[j]&gt;table[j+<span class="number">1</span>])</span><br><span class="line">           &#123;</span><br><span class="line">               swap(table[j],table[j+<span class="number">1</span>]);</span><br><span class="line">               flg=<span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(flg)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    bubble_sort(table);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.快速排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3.堆排序"></a>3.堆排序</h2><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在二叉树的第ｉ（ｉ&gt;=１）层最多有２i<span class="number">-1</span>个结点；</span><br><span class="line">&gt; 深度为k(k&gt;=<span class="number">0</span>)的二叉树最少有k个结点，最多有２k<span class="number">-1</span>个结点；</span><br><span class="line">&gt; 对于任一棵非空二叉树，若其叶结点数为n0，度为<span class="number">2</span>的非叶结点数为n2，则n0 = n2 ＋１；</span><br><span class="line">&gt; 具有n个结点的完全二叉树的深度为int_UP（<span class="built_in">log</span>(<span class="number">2</span>，ｎ+<span class="number">1</span>)）；</span><br><span class="line">&gt; 如果将一棵有n个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号１，２，３，．．．．．．，ｎ，然后按此结点编号将树中各结点顺序的存放于一个一维数组，并简称编号为i的结点为结点i（ｉ&gt;=１ &amp;&amp; ｉ&lt;=ｎ）,则有以下关系： </span><br><span class="line">&gt; （<span class="number">1</span>）若 ｉ= <span class="number">1</span>，则结点i为根，无父结点；若 ｉ&gt; <span class="number">1</span>，则结点 i的父结点为结点int_DOWN（ｉ / ２）; </span><br><span class="line">&gt; </span><br><span class="line">&gt; （<span class="number">2</span>）若 ２*ｉ &lt;= ｎ，则结点 ｉ 的左子女为结点 ２*ｉ； </span><br><span class="line">&gt; （<span class="number">3</span>）若２*ｉ＜＝ｎ，则结点ｉ的右子女为结点２*ｉ＋１； </span><br><span class="line">&gt; （<span class="number">4</span>）若结点编号ｉ为奇数，且ｉ！＝１，它处于右兄弟位置，则它的左兄弟为结点ｉ－１； </span><br><span class="line">&gt; （<span class="number">5</span>）若结点编号ｉ为偶数，且ｉ！＝ｎ，它处于左兄弟位置，则它的右兄弟为结点ｉ＋１； </span><br><span class="line">&gt; （<span class="number">6</span>）结点ｉ所在的层次为 int_DOWN（<span class="built_in">log</span>（<span class="number">2</span>，ｉ））＋１。 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table,<span class="keyword">int</span> loclen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loclen==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;table.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;table[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(loclen/<span class="number">2</span>)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        left=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=loclen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(table[left]&gt;table[i])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(table[left],table[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(table[left]&gt;table[i]&amp;&amp;table[left]&gt;table[right])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(table[left],table[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(table[right]&gt;table[i]&amp;&amp;table[right]&gt;table[left])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(table[right],table[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     swap(table[loclen<span class="number">-1</span>],table[<span class="number">0</span>]);</span><br><span class="line">    heapsort(table,loclen<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     heapsort(table,table.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若i从0开始索引，当前节点为i时，父节点（i/2）-1，左子节点：2*i+1,右子节点：2*i+2</span><br></pre></td></tr></table></figure><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [left,mid]  [mid+1,right]</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;leftpart;</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rightpart;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mid-left+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         leftpart.push_back(table[i+left]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-mid;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         rightpart.push_back(table[i+mid+<span class="number">1</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">int</span> leftloc=<span class="number">0</span>,rightloc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftloc&lt;leftpart.size()&amp;&amp;rightloc&lt;rightpart.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(leftpart[leftloc]&lt;rightpart[rightloc])</span><br><span class="line">        &#123;</span><br><span class="line">             table[left]=leftpart[leftloc++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table[left]=rightpart[rightloc++];</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(leftloc&lt;leftpart.size())</span><br><span class="line">    &#123;</span><br><span class="line">      table[left++]=leftpart[leftloc++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(rightloc&lt;rightpart.size())</span><br><span class="line">    &#123;</span><br><span class="line">       table[left++]=rightpart[rightloc++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;table,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">  merge_sort(table,left,mid);     <span class="comment">// [left,mid]</span></span><br><span class="line">  merge_sort(table,mid+<span class="number">1</span>,right);   <span class="comment">//[mid+1,right]</span></span><br><span class="line">  merge(table,left,mid,right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;table=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    merge_sort(table,<span class="number">0</span>,table.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;table[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;table.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分治法，分而合，合之前左右皆有序。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; title=&quot;1.插入排序&quot;&gt;&lt;/a&gt;1.插入排序&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理论易错点总结-LTS</title>
    <link href="http://yoursite.com/2019/09/01/%E7%90%86%E8%AE%BA%E6%98%93%E9%94%99%E7%82%B9%E6%80%BB%E7%BB%93-LTS/"/>
    <id>http://yoursite.com/2019/09/01/理论易错点总结-LTS/</id>
    <published>2019-09-01T08:36:55.000Z</published>
    <updated>2019-09-09T09:04:38.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-中-和-gt-的区别"><a href="#1-C-中-和-gt-的区别" class="headerlink" title="1 C++中.和-&gt;的区别"></a>1 C++中.和-&gt;的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">c++中当定义类对象是指针对象时候，就需要用到-&gt;指向类中的成员；当定义一般对象时候时就需要用到&quot;.&quot;指向类中的成员。</span><br><span class="line">A *p则使用：p-&gt;play(); 左边是结构指针。</span><br><span class="line"></span><br><span class="line">A p 则使用：p.paly(); 左边是结构变量。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">箭头（-&gt;）：左边必须为指针；</span><br><span class="line"></span><br><span class="line">点号（.）：左边必须为实体。</span><br><span class="line">-------------------------------------------------</span><br><span class="line">1、-&gt;是指针指向其成员的运算符。</span><br><span class="line"></span><br><span class="line"> . 是结构体的成员运算符。</span><br><span class="line"></span><br><span class="line">最大的区别是-&gt;前面放的是指针，而.前面跟的是结构体变量。</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">::是域作用符，是各种域性质的实体（比如类（不是对象）、名字空间等）调用其成员专用的。</span><br><span class="line">（如果有个局部变量与全局变量同名（假设都是int a;），默认调用的 a 是局部变量，如果要访问全局变量a，就要这么写“::a”。使用域作用符来加以区别；前面没写具体的域名，就是指默认域）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.是成员作用符，是对象专用的。</span><br></pre></td></tr></table></figure><h2 id="2-this指针"><a href="#2-this指针" class="headerlink" title="2 this指针"></a>2 this指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1. this指针的用处:</span><br><span class="line"></span><br><span class="line">　　一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。　　例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 .</span><br><span class="line"></span><br><span class="line">2. this指针的使用:</span><br><span class="line"></span><br><span class="line">一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n）。</span><br><span class="line"></span><br><span class="line">3. this指针程序示例:</span><br><span class="line"></span><br><span class="line">this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址。</span><br><span class="line"></span><br><span class="line">5. 类的this指针有以下特点：</span><br><span class="line"></span><br><span class="line">（1）this只能在成员函数中使用。</span><br><span class="line"></span><br><span class="line">全局函数、静态函数都不能使用this.</span><br><span class="line"></span><br><span class="line">实际上，成员函数默认第一个参数为T * const this。 </span><br><span class="line"></span><br><span class="line">其中，func的原型在编译器看来应该是：</span><br><span class="line"></span><br><span class="line">  int func(A * const this,int p);</span><br><span class="line"></span><br><span class="line">（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。</span><br><span class="line"></span><br><span class="line">这个生命周期同任何一个函数的参数是一样的，没有任何区别。</span><br><span class="line"></span><br><span class="line">当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">a.func(10);</span><br><span class="line"></span><br><span class="line">此处，编译器将会编译成：</span><br><span class="line"></span><br><span class="line">A::func(&amp;a,10);</span><br><span class="line"></span><br><span class="line">看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高--如VC通常是通过ecx寄存器传递this参数的。</span><br><span class="line"></span><br><span class="line">（3）几个this指针的易混问题。</span><br><span class="line"></span><br><span class="line">A. this指针是什么时候创建的？</span><br><span class="line"></span><br><span class="line">this在成员函数的开始执行前构造，在成员的执行结束后清除。</span><br><span class="line"></span><br><span class="line">但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用 TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答。</span><br><span class="line"></span><br><span class="line">B. this指针存放在何处？堆、栈、全局变量，还是其他？</span><br><span class="line"></span><br><span class="line">this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</span><br><span class="line"></span><br><span class="line">C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</span><br><span class="line"></span><br><span class="line">大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</span><br><span class="line"></span><br><span class="line">在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</span><br><span class="line"></span><br><span class="line">D. this指针是如何访问类中的变量的？</span><br><span class="line"></span><br><span class="line">如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。 </span><br><span class="line">在C++中 ,类和结构是只有一个区别的：类的成员默认是private，而结构是public。</span><br><span class="line"></span><br><span class="line">this是类的指针，如果换成结构，那this就是结构的指针了。</span><br><span class="line"> </span><br><span class="line">E. 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</span><br><span class="line"></span><br><span class="line">this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</span><br><span class="line"></span><br><span class="line">F. 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</span><br><span class="line"></span><br><span class="line">普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</span><br></pre></td></tr></table></figure><h2 id="3-C-函数定义和调用过程"><a href="#3-C-函数定义和调用过程" class="headerlink" title="3.C++函数定义和调用过程"></a>3.C++函数定义和调用过程</h2><h2 id="4-C-数组大小"><a href="#4-C-数组大小" class="headerlink" title="4  C++数组大小"></a>4  C++数组大小</h2><ul><li><strong>函数内申请的变量，数组，是在栈（stack）中申请的一段连续的空间。栈的默认大小为2M或1M，开的比较小。</strong></li><li><strong>全局变量，全局数组，静态数组（static）则是开在全局区（静态区）（static）。大小为2G，所以能够开的很大。</strong></li><li><strong>而malloc、new出的空间，则是开在堆（heap）的一段不连续的空间。理论上则是硬盘大小。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">20000</span>][<span class="number">20000</span>]; <span class="comment">//全局数组能开到20000*20000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">100</span>][<span class="number">100</span>]; <span class="comment">// 函数中二维数组最大能开100*100</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">4</span>*<span class="number">518028</span>]; <span class="comment">// 函数中的char数组最大能开4*518028</span></span><br><span class="line">    <span class="keyword">int</span> b1[<span class="number">500000</span>]; <span class="comment">// int最大能开到518028。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[<span class="number">20000</span>][<span class="number">20000</span>]; <span class="comment">//static能开到10^7*10^7，注意 static和 全局开的是同一块空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-默认值"><a href="#5-默认值" class="headerlink" title="5.默认值"></a>5.默认值</h2><p>对全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在GCC编译器下各个类型的全局变量的默认值：</span><br><span class="line"></span><br><span class="line"> 表示数字的变量类型默认值都为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">bool</span>型默认值为<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">string</span>型默认值为空字符串</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> 型比较特殊。<span class="keyword">char</span>类型默认值为<span class="string">'\0'</span>， 即字符串结束标志，其整数值为<span class="number">0</span>。如果用<span class="built_in">printf</span>(<span class="string">"%d"</span>)输出时值为 <span class="number">0</span>， 但用<span class="built_in">printf</span>(<span class="string">"%c"</span>),或<span class="built_in">cout</span> 输出时显示为<span class="string">"a"</span>， <span class="keyword">char</span>型数组默认值为空字符串，其中的每个元素与单个<span class="keyword">char</span>类型相同，所以用<span class="built_in">puts</span>() 和<span class="built_in">printf</span>(<span class="string">"%s"</span>) 输出都是空字符串。</span><br></pre></td></tr></table></figure><p>static的默认初始化为0.和全局变量一致，因为全局变量也存储在静态数据区。</p><h2 id="6-Vector-赋值"><a href="#6-Vector-赋值" class="headerlink" title="6 Vector 赋值"></a>6 Vector 赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>的几种初始化及赋值方式：</span><br><span class="line">（<span class="number">1</span>）不带参数的构造函数初始化</span><br><span class="line"><span class="comment">//初始化一个size为0的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc;</span><br><span class="line">（<span class="number">2</span>）带参数的构造函数初始化</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc(<span class="number">10</span>);    <span class="comment">//初始化了10个默认值为0的元素</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cde(<span class="number">10</span>，<span class="number">1</span>);    <span class="comment">//初始化了10个值为1的元素</span></span><br><span class="line">（<span class="number">3</span>）通过数组地址初始化</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a, a+<span class="number">5</span>);</span><br><span class="line">（<span class="number">4</span>）通过同类型的<span class="built_in">vector</span>初始化</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//通过a初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a);</span><br><span class="line">（<span class="number">5</span>）通过insert初始化</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">vecot&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a[0]~a[2]插入到b中，b.size()由0变为3</span></span><br><span class="line">b.insert(b.begin(), a.begin(), a.begin() + <span class="number">3</span>);</span><br><span class="line">insert也可通过数组地址区间实现插入</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a的所有元素插入到b中</span></span><br><span class="line">b.insert(b.begin(), a, a+<span class="number">7</span>);</span><br><span class="line">此外，insert还可以插入m个值为n的元素</span><br><span class="line"></span><br><span class="line"><span class="comment">//在b开始位置处插入6个6</span></span><br><span class="line">b.insert(b.begin(), <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">（<span class="number">6</span>）通过copy函数赋值</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">5</span>] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间*/</span></span><br><span class="line">copy(a.begin(), a.end(), b.begin());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//拷贝区间也可以是数组地址构成的区间</span></span><br><span class="line">copy(a1, a1+<span class="number">5</span>, b.begin() + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-C-中-和-gt-的区别&quot;&gt;&lt;a href=&quot;#1-C-中-和-gt-的区别&quot; class=&quot;headerlink&quot; title=&quot;1 C++中.和-&amp;gt;的区别&quot;&gt;&lt;/a&gt;1 C++中.和-&amp;gt;的区别&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux相关操作</title>
    <link href="http://yoursite.com/2019/08/31/Linux%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/08/31/Linux相关操作/</id>
    <published>2019-08-31T13:44:48.000Z</published>
    <updated>2019-08-31T13:47:45.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下还是有很多超棒的开发工具的。</p></blockquote><p>在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C/C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。</p><p>开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I/O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>开发及调试<ul><li>编辑器：vim</li><li>编译器：gcc/g++</li><li>调试工具：gdb</li><li>查看依赖库：ldd</li><li>二进制文件分析：objdump</li><li>ELF文件格式分析：readelf</li><li>跟踪进程中系统调用：strace</li><li>跟踪进程栈：pstack</li><li>进程内存映射：pmap</li></ul></li><li>文件处理<ul><li>文件查找：find</li><li>文本搜索：grep</li><li>排序：sort</li><li>转换：tr</li><li>按列切分文本：cut</li><li>按列拼接文本：paste</li><li>统计行和字符：wc</li><li>文本替换：sed</li><li>数据流处理：awk</li></ul></li><li>性能分析<ul><li>进程查询：ps</li><li>进程监控：top</li><li>打开文件查询：lsof</li><li>内存使用量：free</li><li>监控性能指标：sar</li></ul></li><li>网络工具<ul><li>网卡配置：ifconfig</li><li>查看当前网络连接：netstat</li><li>查看路由表：route</li><li>检查网络连通性：ping</li><li>转发路径：traceroute</li><li>网络Debug分析：nc</li><li>命令行抓包：tcpdump</li><li>域名解析工具：dig</li><li>网络请求：curl</li></ul></li><li>其他<ul><li>终止进程：kill</li><li>修改文件权限：chmod</li><li>创建链接：ln</li><li>显示文件尾：tail</li><li>版本控制：git</li><li>设置别名：alias</li></ul></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="开发及调试"><a href="#开发及调试" class="headerlink" title="开发及调试"></a>开发及调试</h3><blockquote><p>开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。</p></blockquote><ol><li><p>编辑器：vim</p><ul><li>服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。</li><li><a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>编译器：gcc/g++</p><ul><li>C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。</li><li><a href="http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>调试工具：gdb</p><ul><li>服务器端调试必备。</li><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>查看依赖库：ldd</p><ul><li>程序依赖库查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ldd后接可执行文件</span><br><span class="line"># 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址</span><br><span class="line"># 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置</span><br><span class="line"></span><br><span class="line">ldd a.out</span><br></pre></td></tr></table></figure></li><li><p>二进制文件分析：objdump</p><ul><li>反汇编，需要理解汇编语言</li><li><a href="http://man.linuxde.net/objdump" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>ELF文件格式分析：readelf</p><ul><li>可以得到ELF文件各段内容，分析链接、符号表等需要用到</li><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>跟踪进程中系统调用：strace</p><ul><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>跟踪进程栈：pstack</p><ul><li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>进程内存映射：pmap</p><ul><li>显示进程内存映射</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -x显示扩展信息，后接进程pid</span><br><span class="line"># Address: 内存开始地址</span><br><span class="line"># 显示信息：</span><br><span class="line">    Kbytes: 占用内存的字节数</span><br><span class="line">    RSS: 保留内存的字节数</span><br><span class="line">    Dirty: 脏页的字节数（包括共享和私有的）</span><br><span class="line">    Mode: 内存的权限：read、write、execute、shared、private</span><br><span class="line">    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）</span><br><span class="line">    Device: 设备名 (major:minor)</span><br><span class="line"></span><br><span class="line">pmap -x 12345</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><blockquote><p>Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。</p></blockquote><ol><li><p>文件查找：find</p><p>按名查找：</p><ul><li>查找具体文件（一般方式）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name *.cpp</span><br></pre></td></tr></table></figure><ul><li>查找具体文件（正则方式）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -regex为正则查找，-iregex为忽略大小写的正则查找 </span><br><span class="line"></span><br><span class="line">find -regex &quot;.*.cpp$&quot;</span><br></pre></td></tr></table></figure><p>定制查找：</p><ul><li>按类型查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># f(file)为文件，d(dictionary)为目录，l(link)为链接</span><br><span class="line"></span><br><span class="line">find . -type f</span><br></pre></td></tr></table></figure><ul><li>按时间查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># atime为访问时间，x天内加参数&quot;-atime -x&quot;，超过x天加&quot;-atime -x&quot;</span><br><span class="line"># mtime为修改时间</span><br><span class="line"></span><br><span class="line">find . -type f -atime -7</span><br></pre></td></tr></table></figure><ul><li>按大小查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)</span><br><span class="line"></span><br><span class="line">find . -type f -size -1k</span><br></pre></td></tr></table></figure><ul><li>按权限查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -perm后接权限</span><br><span class="line"></span><br><span class="line">find . -type -perm 644</span><br></pre></td></tr></table></figure></li><li><p>文本搜索：grep</p><ul><li>模式匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 匹配test.cpp文件中含有&quot;iostream&quot;串的内容</span><br><span class="line"></span><br><span class="line">grep &quot;iostream&quot; test.cpp</span><br></pre></td></tr></table></figure><ul><li>多个模式匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 匹配test.cpp文件中含有&quot;iostream&quot;和&quot;using&quot;串的内容</span><br><span class="line"></span><br><span class="line">grep -e &quot;using&quot; -e &quot;iostream&quot; test.cpp</span><br></pre></td></tr></table></figure><ul><li>输出信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数</span><br><span class="line"></span><br><span class="line">grep -n &quot;iostream&quot; test.cpp</span><br></pre></td></tr></table></figure></li><li><p>排序：sort</p><ul><li>文件内容行排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 排序在内存进行，不改变文件</span><br><span class="line"># -n(number)表示按数字排序，-d(dictionary)表示按字典序</span><br><span class="line"># -k N表示按各行第N列进行排序</span><br><span class="line"># -r(reverse)为逆序排序</span><br><span class="line"></span><br><span class="line">sort -n -k 1 test</span><br></pre></td></tr></table></figure></li><li><p>转换：tr</p><ul><li>字符替换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 转换在内存进行，不改变文件</span><br><span class="line"># 将打开文件中所有目标字符替换</span><br><span class="line"></span><br><span class="line">cat test | tr &apos;1&apos; &apos;2&apos;</span><br></pre></td></tr></table></figure><ul><li>字符删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 转换在内存进行，不改变文件</span><br><span class="line"># -d删除(delete)</span><br><span class="line"></span><br><span class="line">cat test | tr -d &apos;1&apos;</span><br></pre></td></tr></table></figure><ul><li>字符压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 转换在内存进行，不改变文件</span><br><span class="line"># -s位于后部</span><br><span class="line"></span><br><span class="line">cat test | tr &apos; &apos; -s</span><br></pre></td></tr></table></figure></li><li><p>按列切分文本：cut</p><ul><li>截取特定列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 截取的内存进行，不改变文件</span><br><span class="line"># -b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位</span><br><span class="line"># 数字为具体列范围</span><br><span class="line"></span><br><span class="line">cut -f 1,2 test</span><br></pre></td></tr></table></figure><ul><li>指定界定符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 截取的内存进行，不改变文件</span><br><span class="line"># -d后接界定符</span><br><span class="line"></span><br><span class="line">cut -f 2 -d &apos;,&apos; new</span><br></pre></td></tr></table></figure></li><li><p>按列拼接文本：paste</p><ul><li>按列拼接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在内存中拼接，不改变文件</span><br><span class="line"># 将两个文件按对应列拼接</span><br><span class="line"># 最后加上-d &quot;x&quot;会将x作为指定分隔符（paste test1 test2 -d &quot;,&quot;）</span><br><span class="line"># 两文件列数可以不同 </span><br><span class="line"></span><br><span class="line">paste test1 test2</span><br></pre></td></tr></table></figure><ul><li>指定界定符拼接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在内存中拼接，不改变文件</span><br><span class="line"># 按照-d之后给出的界定符拼接</span><br><span class="line"></span><br><span class="line">paste test1 test2 -d &quot;,&quot;</span><br></pre></td></tr></table></figure></li><li><p>统计行和字符：wc</p><ul><li>基本统计</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)</span><br><span class="line"></span><br><span class="line">wc -l test</span><br></pre></td></tr></table></figure></li><li><p>文本替换：sed</p><ul><li>区别于上面的命令，sed是可以直接改变被编辑文件内容的。</li><li><a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>数据流处理：awk</p><ul><li>区别于上面的命令，awk是可以直接改变被编辑文件内容的。</li><li><a href="http://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">详见</a></li></ul></li></ol><hr><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><blockquote><p>性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I/O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。</p></blockquote><ol><li><p>进程查询：ps</p><ul><li>查看正在运行进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 常结合grep筛选信息(e.g, ps -ef | grep xxx)</span><br><span class="line"></span><br><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li>以完整格式显示所有进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 常结合grep筛选信息</span><br><span class="line"></span><br><span class="line">ps -ajx</span><br></pre></td></tr></table></figure></li><li><p>进程监控：top</p><ul><li>显示实时进程信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是个大招，都不带参数的，具体信息通过grep筛选</span><br><span class="line"># 交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列</span><br><span class="line"># %id表示CPU空闲率，过低表示可能存在CPU存在瓶颈</span><br><span class="line"># %wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析</span><br><span class="line"></span><br><span class="line">top</span><br></pre></td></tr></table></figure></li><li><p>打开文件查询：lsof</p><ul><li>查看占用某端口的进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 最常见的就是mysql端口被占用使用(lsof i:3307)</span><br><span class="line"># 周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)</span><br><span class="line"></span><br><span class="line">lsof -i:53</span><br></pre></td></tr></table></figure><ul><li>查看某用户打开的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -u(user)为用户，后接用户名</span><br><span class="line"></span><br><span class="line">lsof -u inx</span><br></pre></td></tr></table></figure><ul><li>查看指定进程打开的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -p(process)为进程，后接进程PID</span><br><span class="line"></span><br><span class="line">lsof -p 12345</span><br></pre></td></tr></table></figure><ul><li>查看指定目录下被进程打开的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里是&quot;+d&quot;，需要注意，使用&quot;+D&quot;递归目录</span><br><span class="line"></span><br><span class="line">lsof +d /test</span><br></pre></td></tr></table></figure></li><li><p>内存使用量：free</p><ul><li>内存使用量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 可获得内存及交换区的总量，已使用量，空闲量等信息</span><br><span class="line"></span><br><span class="line">free</span><br></pre></td></tr></table></figure></li><li><p>监控性能指标：sar</p><p>监控CPU</p><ul><li>监控CPU负载</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等</span><br><span class="line"># 这里&quot;1&quot;表示采样时间间隔是1秒，这里&quot;2&quot;表示采样次数为2</span><br><span class="line"></span><br><span class="line">sar -q 1 2</span><br></pre></td></tr></table></figure><ul><li>监控CPU使用率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以显示CPU使用情况</span><br><span class="line"># 参数意义同上</span><br><span class="line"></span><br><span class="line">sar -u 1 2</span><br></pre></td></tr></table></figure><p>监控内存</p><ul><li>查询内存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以显示内存使用情况</span><br><span class="line"># 参数意义同上 </span><br><span class="line"></span><br><span class="line">sar -r 1 2</span><br></pre></td></tr></table></figure><ul><li>页面交换查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以查看是否发生大量页面交换，吞吐率大幅下降时可用</span><br><span class="line"># 参数意义同上</span><br><span class="line"></span><br><span class="line">sar -W 1 2</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h3><blockquote><p>网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。</p></blockquote><ol><li><p>网卡配置（链路层）：ifconfig</p><ul><li>显示设备信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 可以显示已激活的网络设备信息</span><br><span class="line"></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li>启动关闭指定网卡</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 前一个参数为具体网卡，后一个为开关信息</span><br><span class="line"># up为打开，down为关闭</span><br><span class="line"></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><ul><li>配置IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 前一个参数为具体网卡，后一个为配置的IP地址</span><br><span class="line"></span><br><span class="line">ifconfig eth0 192.168.1.1</span><br></pre></td></tr></table></figure><ul><li>设置最大传输单元</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前一个参数为具体网卡，后面为MTU的大小</span><br><span class="line"># 设置链路层MTU值，通常为1500</span><br><span class="line"></span><br><span class="line">ifconfig eth0 mtu 1500</span><br></pre></td></tr></table></figure><ul><li>启用和关闭ARP协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开启arp如下，若关闭则-arp</span><br><span class="line"></span><br><span class="line">ifconfig eth0 arp</span><br></pre></td></tr></table></figure></li><li><p>查看当前网络连接（链路层/网络层/传输层）：netstat</p><ul><li>网络接口信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 显示网卡信息，可结合ifconfig学习</span><br><span class="line"></span><br><span class="line">netstat -i</span><br></pre></td></tr></table></figure><ul><li>列出端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口</span><br><span class="line"># -l(listening)表示正在监听的端口</span><br><span class="line"></span><br><span class="line">netstat -at</span><br></pre></td></tr></table></figure><ul><li>显示端口统计信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -s(status)显示各协议信息</span><br><span class="line"># -加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息</span><br><span class="line"></span><br><span class="line">netstat -s</span><br></pre></td></tr></table></figure><ul><li>显示使用某协议的应用名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称</span><br><span class="line"></span><br><span class="line">netstat -pt</span><br></pre></td></tr></table></figure><ul><li>查找指定进程、端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程</span><br><span class="line"># 第二个操作可以用lsof替代</span><br><span class="line"></span><br><span class="line">netstat -ap | grep ssh</span><br><span class="line">netstat -an | grep &apos;:80&apos;</span><br></pre></td></tr></table></figure></li><li><p>查看路由表（网络层IP协议）：route</p><ul><li>查看路由信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 得到路由表信息，具体分析路由表工作需要网络知识</span><br><span class="line"># 可以通过netstat -r(route)得到同样的路由表</span><br><span class="line"></span><br><span class="line">route</span><br></pre></td></tr></table></figure></li><li><p>检查网络连通性（网络层ICMP协议）：ping</p><ul><li>检查是否连通</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 主要功能是检测网络连通性</span><br><span class="line"># 可以额外得到网站的ip地址和连接最大/最小/平均耗时。</span><br><span class="line"></span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure></li><li><p>转发路径（网络层ICMP协议）：traceroute</p><ul><li>文件包途径的IP</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"># 可以打印从沿途经过的路由器IP地址</span><br><span class="line"></span><br><span class="line">traceroute baidu.com</span><br></pre></td></tr></table></figure></li><li><p>网络Debug分析（网络层/传输层）：nc</p><ul><li>端口扫描</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 黑客很喜欢</span><br><span class="line"># 扫描某服务器端口使用情况</span><br><span class="line"># -v(view)显示指令执行过程，-w(wait)设置超时时长</span><br><span class="line"># -z使用输入输出模式（只在端口扫描时使用）</span><br><span class="line"># 数字为扫描的端口范围 </span><br><span class="line"></span><br><span class="line">nc -v -w 1 baidu.com  -z 75-1000</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.oschina.net/translate/linux-netcat-command" target="_blank" rel="noopener">其他详见</a></li></ul></li><li><p>命令行抓包（网络层/传输层）：tcpdump</p><ul><li>抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。</li><li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>域名解析工具（应用层DNS协议）：dig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 应用层，DNS</span><br><span class="line"># 打印域名解析结果</span><br><span class="line"># 打印域名解析过程中涉及的各级DNS服务器地址</span><br><span class="line"></span><br><span class="line">dig baidu.com</span><br></pre></td></tr></table></figure></li><li><p>网络请求（应用层）：curl</p><ul><li><a href="http://www.cnblogs.com/gbyukg/p/3326825.html" target="_blank" rel="noopener">详见</a></li></ul></li></ol><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote><p>这里都是日常开发中高频命令。</p></blockquote><ol><li><p>终止进程：kill</p><ul><li>杀死具体进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 加具体进程PID</span><br><span class="line"></span><br><span class="line">kill 12345</span><br></pre></td></tr></table></figure><ul><li>杀死某进程相关进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 加上&quot;-9&quot;杀死某进程相关进程</span><br><span class="line"></span><br><span class="line">kill -9 12345</span><br></pre></td></tr></table></figure></li><li><p>修改文件权限：chmod</p><ul><li>更改文件权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)</span><br><span class="line"># 文件可以有三种权限，r(read)，w(write)，x(execute)</span><br><span class="line"># 这里u+r表示文件所有者在原有基础上增加文件读取权限</span><br><span class="line"># 这里777分别对应，u=7，g=7，o=7，具体数字含义自行google</span><br><span class="line"></span><br><span class="line">chmod u+r file</span><br><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure></li><li><p>创建链接：ln</p><ul><li>创建硬链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文件inode中链接数会增加，只有链接数减为0时文件才真正被删除</span><br><span class="line"></span><br><span class="line">ln file1 file2</span><br></pre></td></tr></table></figure><ul><li>创建软（符号链接）链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -s(symbol)为符号链接，仅仅是引用路径</span><br><span class="line"># 相比于硬链接最大特点是可以跨文件系统</span><br><span class="line"># 类似于Windows创建快捷方式，实际文件删除则链接失效</span><br><span class="line"></span><br><span class="line">ln -s file1 file2</span><br></pre></td></tr></table></figure></li><li><p>显示文件尾：tail</p><ul><li>查看文件尾部</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新</span><br><span class="line"># 查看日志时常用</span><br><span class="line"></span><br><span class="line">tail -f test</span><br></pre></td></tr></table></figure></li><li><p>版本控制：git</p><ul><li>版本控制最好用的软件，没有之一。至少要知道”git init”，”git add”，”git commit”，”git pull”，”git push”几个命令。</li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">详见</a></li></ul></li><li><p>设置别名：alias</p><ul><li>常用命令添加别名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># &quot;.bashrc&quot;文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令</span><br><span class="line"></span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。</p><p>先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。<a href="https://github.com/linw7/TKeed" target="_blank" rel="noopener">代码</a></p><ol><li>单步调试：gdb</li></ol><ul><li>运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。</li></ul><ol><li>动态库依赖：ldd</li></ol><ul><li>命令：ldd ./server</li><li>可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。</li></ul><ol><li>性能分析：top</li></ol><ul><li>top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。</li></ul><ol><li>系统调用：strace</li></ol><ul><li>命令：strace ./server</li><li>上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。</li></ul><ol><li>打印进程：ps</li></ol><ul><li>命令：ps -ejH</li><li>我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。</li></ul><ol><li>打开文件：lsof</li></ol><ul><li>lsof -i:3000</li><li>比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。</li></ul><ol><li>修改权限：chmod</li></ol><ul><li>chmod 000 ./index.html</li><li>可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000/index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。</li></ul><ol><li>网卡信息：ifconfig</li></ol><ul><li>ifconfig</li><li>如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。</li></ul><ol><li>抓包分析：tcpdump</li></ol><ul><li>tcpdump -i eth0 port 3000</li><li>可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux下还是有很多超棒的开发工具的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C/C++开发者至
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2019/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/08/31/计算机网络/</id>
    <published>2019-08-31T13:43:19.000Z</published>
    <updated>2019-09-15T13:34:44.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层-IP"><a href="#网络层-IP" class="headerlink" title="网络层(IP)"></a>网络层(IP)</h1><blockquote><h2 id="1-mac和ip怎么转换"><a href="#1-mac和ip怎么转换" class="headerlink" title="1. mac和ip怎么转换"></a>1. mac和ip怎么转换</h2><p><strong>ARP协议：</strong></p><p>将IP地址通过广播 目标MAC地址是FF-FF-FF-FF-FF-FF 解析目标IP地址的MAC地址 扫描本网段MAC地址。</p><p><strong>DHCP协议：</strong></p><p>DHCP租约过程就是DHCP客户机动态获取IP地址的过程。</p><p>DHCP租约过程分为4步：</p><ol><li>客户机请求IP（客户机发DHCPDISCOVER广播包）；</li><li>服务器响应（服务器发DHCPOFFER广播包）；</li><li>客户机选择IP（客户机发DHCPREQUEST广播包）；</li><li>服务器确定租约（服务器发DHCPACK/DHCPNAK广播包）。</li></ol><p>参考资料：</p><ul><li><a href="http://blog.51cto.com/yuanbin/109574" target="_blank" rel="noopener">图解DHCP的4步租约过程-大浪淘沙-51CTO博客</a></li></ul></blockquote><p><img src="/2019/08/31/计算机网络/子网划分.png" alt="子网划分"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">IP分类</span><br><span class="line">公有地址：</span><br><span class="line">IP分类        缺省掩码</span><br><span class="line">A 1－127      /8</span><br><span class="line">B 128－191        /16</span><br><span class="line">C 192－223      /24</span><br><span class="line">D 224－239      组播地址</span><br><span class="line">E 240－247    保留地址</span><br><span class="line">私有地址：</span><br><span class="line">A：10.0.0.0 - 10.255.255.255</span><br><span class="line">B:  172.16.0.0 - 172.31.255.255</span><br><span class="line">C:  192.168.0.0 - 192.168.255.255</span><br><span class="line"></span><br><span class="line">判断合法的主机（IP）地址：</span><br><span class="line">192.168.10.240/24        合法</span><br><span class="line">192.168.10.0/24          不合法，主机位全为0，网络地址</span><br><span class="line">192.168.10.255/24        不合法，主机位全为1，子网广播地址</span><br><span class="line">255.255.255.255              不合法，网络和主机位全为1，全网广播地址</span><br><span class="line">127.x.x.x/8                不合法，本地环回地址</span><br><span class="line">172.16.3.5/24              合法</span><br><span class="line">192.168.5.240/32        合法</span><br><span class="line">224.10.10.10.1              不合法，组播地址</span><br><span class="line">300.2.4.200/24              不合法</span><br></pre></td></tr></table></figure><blockquote><p>IP特殊地址</p><ul><li>本地环回地址：127.0.0.0 – 127.255.255.255，测试主机TCP/IP协议栈是否安装正确。</li><li>本地链路地址：169.254.0.0 – 169.254.255.255，自动地址无法获取时系统自动配置占位。</li><li>受限广播地址：255.255.255.255，发往这个地址的数据不能跨越三层设备，但本地网络内所有的主机都可以接收到数据</li></ul></blockquote><h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><h2 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h2><ol><li>路由器可以给你的局域网自动分配IP，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。交换机只是用来分配网络数据的。</li><li>路由器在网络层，路由器根据IP地址寻址，路由器可以处理TCP/IP协议，交换机不可以。</li><li>交换机在中继层，交换机根据MAC地址寻址。路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。交换机可以把很多主机连起来，这些主机对外各有各的IP。</li><li>路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</li></ol><p>交换机是利用<strong>物理地址或者说MAC地址</strong>来确定转发数据的目的地址。而路由器则是利用不同网络的ID号(即IP地址)来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络，有时这些第三层的地址也称为协议地址或者网络地址。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</p><p><strong>路由器和交换机的区别一</strong>：交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响。 <strong>路由器和交换机的区别二</strong>：交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP/IP协议，而交换机不可以。</p><p><strong>路由器和交换机的区别三</strong>：交换机可以使连接它的多台电脑组成局域网，如果还有代理服务器的话还可以实现同时上网功能而且局域网所有电脑是共享它的带宽速率的，但是交换机没有路由器的自动识别数据包发送和到达地址的功能。路由器可以自动识别数据包发送和到达的地址，路由器相当于马路上的警察，负责交通疏导和指路的。</p><p><strong>路由器和交换机的区别四</strong>：举几个例子,路由器是小邮局，就一个地址(IP)，负责一个地方的收发(个人电脑，某个服务器，所以你家上网要这个东西)，交换机是省里的大邮政中心，负责由一个地址给各个小地方的联系。简单的说路由器专管入网，交换机只管配送，路由路由就是给你找路让你上网的，交换机只负责开门，交换机上面要没有路由你是上不了网的。</p><p><strong>路由器和交换机的区别五</strong>：路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p><h2 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h2><p>内网中192.168.1.199的前三组是网络号，后一组是主机号，子网掩码就是255.255.255.0</p><p><strong>首先要说明的是</strong>：不是某个IP的网络号和主机号决定子网掩码是什么，而是子网掩码决定了某个IP地址的网络号与主机号是什么，IP地址是要搭配子网掩码使用的。例如上面的子网掩码决定了192.168.1.199的前三段192.168.1是网络号，最后一段199是主机号。</p><p>我们再来理解子网掩码的作用，先举个例子，市面上的两个厂家都生产电子秤，每个厂家都坚称他们的秤最准，那你是怎么知道他们的秤到底准不准？很简单，你去找一个 1KG 的国际千克原器，各放到他们的秤上测量，如果秤的测量值是1KG，那这把秤就是准的，<strong>子网掩码的作用就相当于这个大家公认的国际千克原器，是我们测量两个IP是否属于同一个网段的一个工具（应该说是让你知道某个IP地址的网络号与主机号分别是什么） 。</strong></p><p><strong>如果让你判断一个IP地址：192.168.1.199的网络号和主机号分别是什么？</strong></p><p>请问你怎么判断？你凭什么说192.168.1是网络号？199是主机号？有什么根据吗？</p><p>但是如果我给你一个IP地址是以下（带子网掩码）形式的：</p><p>IP：192.168.1.199</p><p>子网掩码：255.255.255.0</p><p>那么根据大家公认的规则，你就可以得出这个IP的网络号和主机号了，怎么算呢？</p><p>子网掩码的长度和IP地址一样也是一串32位的二进制数字，只不过为人类的可读性和记忆性的方便，通常使用十进制数字来表示，例如把上面的IP地址和子网掩码都转换成相应的二进制就是下面这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**十进制**                   **二进制**</span><br></pre></td></tr></table></figure><p>IP 地址：192.168.1.199 <strong>‐＞</strong>11000000.10101000.00000001.11000111</p><p>子网掩码：255.255.255.0 <strong>‐＞</strong>11111111.11111111.11111111.00000000</p><p>十进制的显示形式是给人看的，二进制的显示形式是给计算机看的。。。</p><p>子网掩码的左边是网络位，用二进制数字“1”表示，1的数目等于网络位的长度；右边是主机位，用二进制数字“0”表示，0的数目等于主机位的长度。</p><p>例如上面的子网掩码255.255.255.0的 “1”的个数是左边24位，则对应IP地址左边的位数也是24位;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**十进制**                   **二进制**</span><br></pre></td></tr></table></figure><p>IP 地址：192.168.1.199 <strong>‐＞11000000.10101000.00000001</strong>.11000111</p><p>子网掩码：255.255.255.0 <strong>‐＞11111111.11111111.11111111</strong>.00000000</p><p>则这个IP地址的网络号就是11000000.10101000.00000001 ，转换成十进制就是 192.168.1，网掩码255.255.255.0的 “0”的个数是右边8位，则这个IP地址的主机号就是11000111，转换成十进制就是199.</p><h1 id="传输层-TCP-UDP"><a href="#传输层-TCP-UDP" class="headerlink" title="传输层(TCP/UDP)"></a>传输层(TCP/UDP)</h1><ol><li><p>ISO七层模型中表示层和会话层功能是什么？</p><ul><li><p>表示层：图像、视频编码解，数据加密。</p></li><li><p>会话层：建立会话，如session认证、断点续传。</p><p><img src="/2019/08/31/计算机网络/os7.png" alt="os7"></p></li></ul><blockquote><h3 id="（1）五层协议"><a href="#（1）五层协议" class="headerlink" title="（1）五层协议"></a>（1）五层协议</h3><ul><li><p><strong>应用层</strong> ：提供用户接口，特指能够发起网络流量的程序，比如客户端程序：QQ，MSN，浏览器等；服务器程序：web服务器，邮件服务器，流媒体服务器等等。数据单位为报文。</p></li><li><p>运输层</p></li></ul><p>  ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：</p><ul><li>传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；</li><li>用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。</li><li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li></ul><ul><li>网络层</li></ul><p>  ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。（负责选择最佳路径 规划IP地址）</p><ul><li>路由器查看数据包目标IP地址，根据路由表为数据包选择路径。路由表中的类目可以人工添加（静态路由）也可以动态生成（动态路由）。</li></ul><ul><li>数据链路层</li></ul><p>  ：不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧。能够进行差错检验，但不纠错，监测处错误丢掉该帧。</p><ul><li>帧的开始和结束，透明传输，差错校验</li></ul><ul><li>物理层</li></ul><p>  ：物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的主要任务描述为：确定与传输媒体的接口的一些特性，即：</p><ul><li>机械特性：例接口形状，大小，引线数目</li><li>电气特性：例规定电压范围 ( -5V 到 +5V )</li><li>功能特性：例规定 -5V 表示 0，＋5V 表示 1</li><li>过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤</li></ul></blockquote><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>　　在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><ol><li><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p></li><li><p>交换机只有下面两层协议</p><p><img src="/2019/08/31/计算机网络/dta.jpg" alt="dta"></p></li></ol><h3 id="（4）TCP-IP四层模型"><a href="#（4）TCP-IP四层模型" class="headerlink" title="（4）TCP/IP四层模型"></a>（4）TCP/IP四层模型</h3><p>它只有四层，相当于五层协议中<strong>数据链路层和物理层合并为网络接口层</strong>。</p><p>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p></li></ol><ol><li><p>描述TCP头部？</p><p><img src="/2019/08/31/计算机网络/tcp.png" alt="tcp"></p><ul><li><p>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。</p></li><li><p>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。</p></li><li><p>首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。</p></li><li><p>标志位（6bit）：</p><ul><li>URG：标志紧急指针是否有效。</li><li>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li><li>PSH：提示接收端立即从缓冲读走数据。</li><li>RST：表示要求对方重新建立连接（复位报文段）。</li><li>SYN：表示请求建立一个连接（连接报文段）。</li><li>FIN：表示关闭连接（断开报文段）。</li></ul></li><li><p>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</p></li><li><p>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</p><p><strong>udp</strong></p><p><img src="/2019/08/31/计算机网络/udp.png" alt="udp"></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p></li></ul><blockquote><ul><li><p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信</p></li><li><p><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TCP和UDP区别？如何改进TCP</span><br><span class="line">TCP和UDP区别</span><br><span class="line">UDP 是无连接的，即发送数据之前不需要建立连接。</span><br><span class="line">UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</span><br><span class="line">UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。</span><br><span class="line">UDP 支持一对一、一对多、多对一和多对多的交互通信。</span><br><span class="line">UDP 的首部开销小，只有 8 个字节。</span><br><span class="line">TCP 是面向连接的运输层协议。</span><br><span class="line">每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。</span><br><span class="line">TCP 提供可靠交付的服务。</span><br><span class="line">TCP 提供全双工通信。</span><br><span class="line">TCP是面向字节流。  </span><br><span class="line">首部最低20个字节。</span><br><span class="line">TCP加快传输效率的方法</span><br><span class="line">采取一块确认的机制</span><br></pre></td></tr></table></figure><blockquote><h4 id="TCP和UDP的区别？应用场景都有哪些？"><a href="#TCP和UDP的区别？应用场景都有哪些？" class="headerlink" title="TCP和UDP的区别？应用场景都有哪些？"></a>TCP和UDP的区别？应用场景都有哪些？</h4><p>l   TCP面向连接即发送前需要建立连接，UDP是无连接的即发送数据之前不需要建立连接</p><p>l   TCP面向字节流，UTP面向数据包；</p><p>l   TCP提供可靠的服务，即通过TCP连接传送的数据无差错不丢失不重复且按序到达，通过校验和、重传控制、序号标识，滑动窗口、确认应答实现可靠传输，如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制；UDP尽最大努力交付即不保证可靠交付。</p><p>l   UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p><p>l   每一条TCP连接只能是点到点通信；UDP支持一对一、一对多，多对一和多对多的交互通信；</p><p>l   TCP对系统资源要求较多，UDP对系统资源要求较少。</p><p>应用场景：若通信数据需让位且需要通信实时，则应该选用 TCP 协议如文件传输、重要状态的更新等；反之则使用 UDP 协议如视频传输、实时通信等。</p><p>UDP：DNS、SNMP</p><h4 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h4><p>l   网速快的情况下UDP提供可靠传输，丢包率很低，如果使用应用层重传能确保传输的可靠性。</p><p>l   TCP为了实现可靠传输使用复杂的拥塞控制算法和繁琐的握手过程，且TCP内置的系统协议栈中很难改进。一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收后再继续发送，延时会越来越大。UDP具有实时性，采用自定义重传机制能够降低延迟，减少网络问题造成的影响。 </p><h4 id="UDP中一个包的大小最大多少？"><a href="#UDP中一个包的大小最大多少？" class="headerlink" title="UDP中一个包的大小最大多少？"></a>UDP中一个包的大小最大多少？</h4><p>l   以太网(Ethernet)数据帧的长度必须在46-1500字节之间，这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区。</p><p>l   并不包括链路层的首部和尾部的18个字节.所以,事实上，这个1500字节就是网络层IP数据报的长度限制.因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节。  </p><p>而这个1480TCPTCPUDPUDP.UDP8,UDP1472.1472</p></blockquote><p><img src="/2019/08/31/计算机网络/76217b745e45ea3a45337c8cc86c883.png" alt="76217b745e45ea3a45337c8cc86c883"></p></li><li><p>三次握手过程？</p><p> <img src="/2019/08/31/计算机网络/sanci.png" alt="sanci"></p><ul><li>第一次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&gt; SYN_SEND）</li><li>第二次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -&gt; SYN_RECV）</li><li>第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&gt; ESTABLISH，服 -&gt; ESTABLISH）</li></ul></li><li><p>四次挥手过程？</p><p><img src="/2019/08/31/计算机网络/tcp-4.png" alt="tcp-4"></p><ul><li>第一次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&gt; FIN_WAIT_1）</li><li>第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&gt; CLOSE_WAIT，客 -&gt; FIN_WAIT_2）<ul><li>此处有等待</li></ul></li><li>第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&gt; LAST_ACK，客 -&gt; TIME_WAIT）<ul><li>此处有等待</li></ul></li><li>第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -&gt; CLOSED）</li></ul></li><li><p>为什么握手是三次，挥手是四次？</p><ul><li>对于握手：握手只需要确认双方通信时的初始化序号，保证通信不会乱序。（第三次握手必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同一个客户机保持多个连接，造成资源浪费。）</li><li>对于挥手：TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。</li></ul></li><li><p>TCP连接状态？</p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li><li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li><li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li><li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li><li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li><li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li></ul></li><li><p>解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？</p><ul><li>FIN_WAIT_2：<ul><li>半关闭状态。</li><li>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li></ul></li><li>CLOSE_WAIT状态：<ul><li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li><li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。</li></ul></li><li>TIME_WAIT状态：<ul><li>又叫2MSL等待状态。</li><li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li><li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li></ul></li></ul></li><li><p>解释RTO，RTT和超时重传？</p><ul><li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul><li>发送的数据没能到达接收端，所以对方没有响应。</li><li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li><li>接收端拒绝或丢弃数据。</li></ul></li><li>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。<ul><li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li><li>重传次数到达上限之后停止重传。</li></ul></li><li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li></ul></li><li><p>流量控制原理？</p><ul><li>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li><li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。<ul><li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li><li>接收窗：用来标记可以接收的数据大小。</li></ul></li><li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</li><li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li></ul></li><li><p>拥塞控制原理？</p><ul><li>拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</li><li><p>TCP拥塞控制算法：</p><ul><li><p>慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。</p></li><li><p>快速重传 &amp; 快速恢复：略。</p></li><li><p>最终拥塞窗口会收敛于稳定值。</p><blockquote><h3 id="（1）慢开始与拥塞避免"><a href="#（1）慢开始与拥塞避免" class="headerlink" title="（1）慢开始与拥塞避免"></a>（1）慢开始与拥塞避免</h3><p>　　发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>　　注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢启动阈值 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>　　如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。</p><h3 id="（2）快重传与快恢复"><a href="#（2）快重传与快恢复" class="headerlink" title="（2）快重传与快恢复"></a>（2）快重传与快恢复</h3><p>　　在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>　　在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>　　在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p></blockquote></li></ul></li></ul></li><li><p>如何区分流量控制和拥塞控制？</p><ul><li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li><li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li></ul></li><li><p>TCP如何提供可靠数据传输的？</p><ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul></li><li><p>TCP soctet交互流程？</p><ul><li><p>服务器：</p><ul><li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p><ul><li>domain：协议域，决定了socket的地址类型，IPv4为AF_INET。</li><li>type：指定socket类型，SOCK_STREAM为TCP连接。</li><li>protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。</li></ul></li><li><p>绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><ul><li>sockfd：socket返回的套接字描述符，类似于文件描述符fd。</li><li>addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IPv4的sockaddr地址结构</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family;    // 协议类型，AF_INET</span><br><span class="line">    in_port_t sin_port;    // 端口号</span><br><span class="line">    struct in_addr sin_addr;    // IP地址</span><br><span class="line">&#125;;</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addrlen：地址长度。</li></ul></li><li><p>监听端口号 -&gt; int listen(int sockfd, int backlog);</p><ul><li>sockfd：要监听的sock描述字。</li><li>backlog：socket可以排队的最大连接数。</li></ul></li><li><p>接收用户请求 -&gt; int accept(int sockfd, struct sockaddr <em>addr, socklen_t </em>addrlen);</p><ul><li>sockfd：服务器socket描述字。</li><li>addr：指向地址结构指针。</li><li>addrlen：协议地址长度。</li><li>注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。</li></ul></li><li><p>从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);</p><ul><li>fd：连接描述字。</li><li>buf：缓冲区buf。</li><li>count：缓冲区长度。</li><li>注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。</li></ul></li><li><p>关闭socket -&gt; int close(int fd);</p><ul><li>fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。</li><li>注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。</li></ul></li></ul></li><li><p>客户机：</p><ul><li>创建socket -&gt; int socket(int domain, int type, int protocol);</li><li>连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);<ul><li>sockfd客户端的sock描述字。</li><li>addr：服务器的地址。</li><li>addrlen：socket地址长度。</li></ul></li><li>向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);<ul><li>fd、buf、count：同read中意义。</li><li>大于0表示写了部分或全部数据，小于0表示出错。</li></ul></li><li>关闭oscket -&gt; int close(int fd);<ul><li>fd：同服务器端fd。 </li></ul></li></ul></li></ul></li></ol><blockquote><p><strong>问题</strong><br>我面试时经常会问的一个问题是当TCP两端A、B建立了连接后，如果一端拔掉网线或者拔掉电源，那么另一端能够收到通知吗？<br>答案是不会，但是只有少数人能够正确的回答这个问题。</p><p><strong>原因</strong><br>TCP是一种有连接的协议，但是这个连接并不是指有一条实际的电路，而是一种虚拟的电路。TCP的建立连接和断开连接都是通过发送数据实现的，也就是我们常说的三次握手、四次挥手。TCP两端保存了一种数据的状态，就代表这种连接，TCP两端之间的路由设备只是将数据转发到目的地，并不知道这些数据实际代表了什么含义，也并没有在其中保存任何的状态信息，也就是说中间的路由设备没有什么连接的概念，只是将数据转发到目的地，只有数据的发送者和接受者两端真正的知道传输的数据代表着一条连接。</p><p>但是这就说明了一点，如果不发送数据那么是无法断开连接的。正常情况下当TCP的一端A调用了SOCKET的close或者进程结束，操作系统就会按照TCP协议发送FIN数据报文。B端收到后就会断开连接。但是当出现了上文所说的异常情况时：被拔掉网线或者断掉电源，总结起来就是没有机会发出断开的FIN数据报文。那么和A直连的路由设备虽然知道A设备已经断开了，但是路由设备并没有保存连接的状态信息，所以路由设备也就不可能去通知B端A端的断开。而B端没有收到断开的数据报文就会依然保持连接。所以A端拔掉网线或者断掉电源后B端是没办法收到断开连接的通知的。 </p><p>解决方案：心跳包</p></blockquote><h1 id="应用层-HTTP"><a href="#应用层-HTTP" class="headerlink" title="应用层(HTTP)"></a>应用层(HTTP)</h1><p>HTTP协议工作在应用层，端口号是80。HTTP协议被用于网络中两台计算机间的通信，相比于TCP/IP这些底层协议，HTTP协议更像是高层标记型语言，浏览器根据从服务器得到的HTTP响应体中分别得到报文头，响应头和信息体（HTML正文等），之后将HTML文件解析并呈现在浏览器上。同样，我们在浏览器地址栏输入网址之后，浏览器相当于用户代理帮助我们组织好报文头，请求头和信息体（可选），之后通过网络发送到服务器，，服务器根据请求的内容准备数据。所以如果想要完全弄明白HTTP协议，你需要写一个浏览器 + 一个Web服务器，一侧来生成请求信息，一侧生成响应信息。</p><p>从网络分层模型来看，HTTP工作在应用层，其在传输层由TCP协议为其提供服务。所以可以猜到，HTTP请求前，客户机和服务器之间一定已经通过三次握手建立起连接，其中套接字中服务器一侧的端口号为HTTP周知端口80。在请求和传输数据时也是有讲究的，通常一个页面上不只有文本数据，有时会内嵌很多图片，这时候有两种选择可以考虑。一种是对每一个文件都建立一个TCP连接，传送完数据后立马断开，通过多次这样的操作获取引用的所有数据，但是这样一个页面的打开需要建立多次连接，效率会低很多。另一种是对于有多个资源的页面，传送完一个数据后不立即断开连接，在同一次连接下多次传输数据直至传完，但这种情况有可能会长时间占用服务器资源，降低吞吐率。上述两种模式分别是HTTP 1.0和HTTP 1.1版本的默认方式，具体是什么含义会在后面详细解释。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 </span><br><span class="line">&gt; </span><br><span class="line">&gt; 缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>HTTP工作流程</strong></p><p>一次完整的HTTP请求事务包含以下四个环节：</p><ul><li>建立起客户机和服务器连接。</li><li>建立连接后，客户机发送一个请求给服务器。</li><li>服务器收到请求给予响应信息。</li><li>客户端浏览器将返回的内容解析并呈现，断开连接。</li></ul><p><strong>HTTP协议结构</strong></p><p>请求报文</p><p>对于HTTP请求报文我们可以通过以下两种方式比较直观的看到：一是在浏览器调试模式下（F12）看请求响应信息，二是通过wireshark或者tcpdump抓包实现。通过前者看到的数据更加清晰直观，通过后者抓到的数据更真实。但无论是用哪种方式查看，得到的请求报文主题体信息都是相同的，对于请求报文，主要包含以下四个部分，每一行数据必须通过”\r\n”分割，这里可以理解为行末标识符。</p><ul><li><p>报文头（只有一行）</p><p>结构：method uri version</p><ul><li><p>method</p><p>HTTP的请求方法，一共有9中，但GET和POST占了99%以上的使用频次。GET表示向特定资源发起请求，当然也能提交部分数据，不过提交的数据以明文方式出现在URL中。POST通常用于向指定资源提交数据进行处理，提交的数据被包含在请求体中，相对而言比较安全些。</p></li><li><p>uri</p><p>用来指代请求的文件，≠URL。</p></li><li><p>version</p><p>HTTP协议的版本，该字段有HTTP/1.0和HTTP/1.1两种。</p></li></ul></li><li><p>请求头（多行）</p><p>在HTTP/1.1中，请求头除了Host都是可选的。包含的头五花八门，这里只介绍部分。</p><ul><li>Host：指定请求资源的主机和端口号。端口号默认80。</li><li>Connection：值为keep-alive和close。keep-alive使客户端到服务器的连接持续有效，不需要每次重连，此功能为HTTP/1.1预设功能。</li><li>Accept：浏览器可接收的MIME类型。假设为text/html表示接收服务器回发的数据类型为text/html，如果服务器无法返回这种类型，返回406错误。</li><li>Cache-control：缓存控制，Public内容可以被任何缓存所缓存，Private内容只能被缓存到私有缓存，non-cache指所有内容都不会被缓存。</li><li>Cookie：将存储在本地的Cookie值发送给服务器，实现无状态的HTTP协议的会话跟踪。</li><li>Content-Length：请求消息正文长度。</li></ul><p>另有User-Agent、Accept-Encoding、Accept-Language、Accept-Charset、Content-Type等请求头这里不一一罗列。由此可见，请求报文是告知服务器请求的内容，而请求头是为了提供服务器一些关于客户机浏览器的基本信息，包括编码、是否缓存等。</p></li><li><p>空行（一行）</p></li><li><p>可选消息体（多行）</p></li></ul><p>响应报文</p><p>响应报文是服务器对请求资源的响应，通过上面提到的方式同样可以看到，同样地，数据也是以”\r\n”来分割。</p><ul><li><p>报文头（一行）</p><p>结构：version status_code status_message</p><ul><li><p>version</p><p>描述所遵循的HTTP版本。</p></li><li><p>status_code</p><p>状态码，指明对请求处理的状态，常见的如下。</p><ul><li>200：成功。</li><li>301：内容已经移动。</li><li>400：请求不能被服务器理解。</li><li>403：无权访问该文件。</li><li>404：不能找到请求文件。</li><li>500：服务器内部错误。</li><li>501：服务器不支持请求的方法。</li><li>505：服务器不支持请求的版本。</li></ul></li><li><p>status_message</p><p>显示和状态码等价英文描述。</p></li></ul></li><li><p>响应头（多行）</p><p>这里只罗列部分。</p><ul><li>Date：表示信息发送的时间。</li><li>Server：Web服务器用来处理请求的软件信息。</li><li>Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。</li><li>Content-Length：服务器告知浏览器自己响应的对象长度。</li><li>Content-Type：告知浏览器响应对象类型。</li></ul></li><li><p>空行（一行）</p></li><li><p>信息体（多行）</p><p>实际有效数据，通常是HTML格式的文件，该文件被浏览器获取到之后解析呈现在浏览器中。</p></li></ul><p><strong>CGI与环境变量</strong></p><ul><li><p>CGI程序</p><p>服务器为客户端提供动态服务首先需要解决的是得到用户提供的参数再根据参数信息返回。为了和客户端进行交互，服务器需要先创建子进程，之后子进程执行相应的程序去为客户服务。CGI正是帮助我们解决参数获取、输出结果的。</p><p>动态内容获取其实请求报文的头部和请求静态数据时完全相同，但请求的资源从静态的HTML文件变成了后台程序。服务器收到请求后fork()一个子进程，子进程执行请求的程序，这样的程序称为CGI程序（Python、Perl、C++等均可）。通常在服务器中我们会预留一个单独的目录（cgi-bin）用来存放所有的CGI程序，请求报文头部中请求资源的前缀都是/cgi-bin，之后加上所请求调用的CGI程序即可。</p><p>所以上述流程就是：客户端请求程序 -&gt; 服务器fork()子进程 -&gt; 执行被请求程序。接下来需要解决的问题就是如何获取客户端发送过来的参数和输出信息怎么传递回客户端。</p></li><li><p>环境变量</p><p>对CGI程序来说，CGI环境变量在创建时被初始化，结束时被销毁。当CGI程序被HTTP服务器调用时，因为是被服务器fork()出来的子进程，所以其继承了其父进程的环境变量，这些环境变量包含了很多基本信息，请求头中和响应头中列出的内容（比如用户Cookie、客户机主机名、客户机IP地址、浏览器信息等），CGI程序所需要的参数也在其中。</p><ul><li><p>GET方法下参数获取</p><p>服务器把接收到的参数数据编码到环境变量QUERY_STRING中，在请求时只需要直接把参数写到URL最后即可，比如”http:127.0.0.1:80/cgi-bin/test?a=1&amp;b=2&amp;c=3”，表示请求cgi-bin目录下test程序，’?’之后部分为参数，多个参数用’&amp;’分割开。服务器接收到请求后环境变量QUERY_STRING的值即为a=1&amp;b=2&amp;c=3。</p><p>在CGI程序中获取环境变量值的方法是：getenv()，比如我们需要得到上述QUERY_STRING的值，只需要下面这行语句就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *value = getenv(&quot;QUERY_STRING&quot;);</span><br></pre></td></tr></table></figure><p>之后对获得的字符串处理一下提取出每个参数信息即可。</p></li><li><p>POST方法下参数获取</p><p>POST方法下，CGI可以直接从服务器标准输入获取数据，不过要先从CONTENT_LENGTH这个环境变量中得到POST参数长度，再获取对应长度内容。</p></li></ul></li></ul><p><strong>会话机制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</span><br><span class="line"></span><br><span class="line">- Cookie</span><br><span class="line"></span><br><span class="line">    Cookie是客户端保持状态的方法。</span><br><span class="line"></span><br><span class="line">    Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</span><br><span class="line"></span><br><span class="line">    除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</span><br><span class="line"></span><br><span class="line">- Session</span><br><span class="line"></span><br><span class="line">    Session是服务器保持状态的方法。</span><br><span class="line"></span><br><span class="line">    首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</span><br><span class="line"></span><br><span class="line">当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来</span><br></pre></td></tr></table></figure><blockquote><p><strong>HTTP**</strong>协议概念：**超文本传输协议，一种详细规定浏览器和万维网服务器之间通信规则，通过因特网传送万维网文档的数据传送协议。</p><p><strong>HTTP**</strong>协议执行过程：**浏览器要访问万维网服务器时，首先完成对WWW服务器的域名解析，一旦获得服务器IP地址，浏览器通过TCP向服务器发送连接建立请求。</p><p>(1)       浏览器打开一个TCP连接；</p><p>(2)       浏览器发送HTTP请求到服务器；</p><p>(3)       服务器发送HTTP回应信息到服务器；</p><p>(4)       TCP连接关闭；</p><p><strong>HTTPS**</strong>（<strong><strong>Hypertext Transfer Protocol over Secure Socket Layer</strong></strong>）概念：**以安全为目标的HTTP通道即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密需要SSL。</p><p><strong>作用（两个）：</strong>（1）建立一个信息安全通道，来保证数据传输的安全；（2）确认网站的真实性。</p><p><strong>HTTPs SSL**</strong>执行过程：**</p><p>(1)       验证服务器端；</p><p>(2)       允许客户端和服务器端选择加密算法和密码，确保双方都支持；</p><p>(3)       验证客户端；</p><p>(4)       使用公钥加密技术来生成共享加密数据；</p><p>(5)       创建一个加密的SSL连接；</p><p>(6)       基于该SSL连接传递HTTP请求；</p><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><p>l   HTTP是超文本传输协议，信息是明文传输，HTTPs则是具有安全性的ssl加密传输协议，要到ca申请证书。</p><p>l   HTTP和HTTPs使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>l   HTTP连接简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p><p>l   在OSI模型中，HTTP工作于应用层，而HTTPS工作于传输层；</p></blockquote><h2 id="从输入网址到获得页面的网络请求过程"><a href="#从输入网址到获得页面的网络请求过程" class="headerlink" title="从输入网址到获得页面的网络请求过程"></a>从输入网址到获得页面的网络请求过程</h2><ul><li><p>查询 DNS</p><ul><li>浏览器搜索自身的DNS缓存</li><li>搜索操作系统的DNS缓存，本地host文件查询</li><li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li><li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li></ul></li><li><p>浏览器获得域名对应的IP地址后，发起HTTP三次握手</p></li><li><p>TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求了</p></li><li><p>TLS 握手</p><ul><li>客户端发送一个 <code>ClientHello</code> 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</li><li>服务器端向客户端返回一个 <code>ServerHello</code> 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li><li>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li><li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li><li>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li><li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</li><li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li></ul></li><li><p>HTTP 服务器请求处理</p><p>HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p><ul><li><p>HTTPD 接收请求</p></li><li><ul><li><p>服务器把请求拆分为以下几个参数：</p><p>HTTP 请求方法(<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, 或者 <code>TRACE</code>)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法域名：google.com请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)</p></li></ul></li><li><p>服务器验证其上已经配置了 google.com 的虚拟主机</p></li><li><p>服务器验证 google.com 接受 GET 方法</p></li><li><p>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</p></li><li><p>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</p></li><li><p>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</p></li><li><p>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</p></li></ul></li><li><p>服务器接受到这个请求，根据路径参数，经过后端的一些处理生成HTML页面代码返回给浏览器</p></li><li><p>浏览器拿到完整的HTML页面代码开始解析和渲染，如果遇到引用的外部<a href="http://lib.csdn.net/base/javascript" target="_blank" rel="noopener">js</a>，CSS,图片等静态资源，它们同样也是一个个的HTTP请求，都需要经过上面的步骤</p></li><li><p>浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给用户</p></li></ul><h2 id="HTTPs安全性"><a href="#HTTPs安全性" class="headerlink" title="HTTPs安全性"></a>HTTPs安全性</h2><p><strong>HTTP 有以下安全性问题：</strong></p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPs（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</p><p>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><h3 id="（1）对称密钥加密"><a href="#（1）对称密钥加密" class="headerlink" title="（1）对称密钥加密"></a>（1）对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><h3 id="（2）非对称密钥加密"><a href="#（2）非对称密钥加密" class="headerlink" title="（2）非对称密钥加密"></a>（2）非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢</li></ul><h2 id="SSL-TLS协议的握手过程"><a href="#SSL-TLS协议的握手过程" class="headerlink" title="SSL/TLS协议的握手过程"></a>SSL/TLS协议的握手过程</h2><p>我们知道，HTTP 协议都是明文传输内容，在早期只展示静态内容时没有问题。伴随着互联网的快速发展，人们对于网络传输安全性的要求也越来越高，HTTPS 协议因此出现。如上图所示，在 HTTPS 加密中真正起作用的其实是 SSL/TLS 协议。SSL/TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送接收数据流程不变，这就很好地兼容了老的 HTTP 协议，这也是软件开发中分层实现的体现。</p><h3 id="SSL-Secure-Socket-Layer，安全套接字层"><a href="#SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="SSL (Secure Socket Layer，安全套接字层)"></a>SSL (Secure Socket Layer，安全套接字层)</h3><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p><p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><h3 id="TLS-Transport-Layer-Security，传输层安全协议"><a href="#TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="TLS (Transport Layer Security，传输层安全协议)"></a>TLS (Transport Layer Security，传输层安全协议)</h3><p>用于两个应用程序之间提供保密性和数据完整性。 TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p><p>SSL/TLS 握手是为了<strong>安全</strong>地协商出一份<strong>对称加密</strong>的秘钥，这个过程很有意思，下面我们一起来了解一下。</p><p><img src="E:\PersonalBlog\source\_posts\计算机网络\https_com.png" alt="https_com"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">（1）client hello</span><br><span class="line">握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。</span><br><span class="line"></span><br><span class="line">（2）server hello</span><br><span class="line">第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。</span><br><span class="line"></span><br><span class="line">（3）server certificate</span><br><span class="line">这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</span><br><span class="line"></span><br><span class="line">（4）Server Hello Done</span><br><span class="line">Server Hello Done 通知客户端 Server Hello 过程结束。</span><br><span class="line"></span><br><span class="line">（5）Client Key Exchange</span><br><span class="line">上面客户端根据服务器传来的公钥生成了 PreMaster Key，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。</span><br><span class="line"></span><br><span class="line">为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。</span><br><span class="line"></span><br><span class="line">（6）Change Cipher Spec(Client)</span><br><span class="line">这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。</span><br><span class="line"></span><br><span class="line">（7）Finished(Client)</span><br><span class="line">客户端发送Finished报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准。</span><br><span class="line"></span><br><span class="line">（8）Change Cipher Spec(Server)</span><br><span class="line">服务器同样发送Change Cipher Spec报文给客户端</span><br><span class="line"></span><br><span class="line">（9）Finished(Server)</span><br><span class="line">服务器同样发送Finished报文给客户端</span><br><span class="line"></span><br><span class="line">（10-11）Application Data</span><br><span class="line">到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。</span><br><span class="line"></span><br><span class="line">（12）Alert：warning, close notify</span><br><span class="line">最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。</span><br><span class="line"></span><br><span class="line">（*）demand client certificate</span><br><span class="line">Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。</span><br><span class="line"></span><br><span class="line">（*）check server certificate</span><br><span class="line">客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3 生成 PreMaster Key。</span><br></pre></td></tr></table></figure><h1 id="常见问题集锦"><a href="#常见问题集锦" class="headerlink" title="常见问题集锦"></a>常见问题集锦</h1><h2 id="网络负载均衡"><a href="#网络负载均衡" class="headerlink" title="网络负载均衡"></a><strong>网络负载均衡</strong></h2><p><img src="/2019/08/31/计算机网络/fuzai.png" alt="fuzai"></p><p>介绍<br>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>对于大量的用户请求，可通过负载均衡器分发到服务器集群中的各个服务器中，服务器集群是可弹性伸缩的，如对于某些特定的活动节日，用户的请求量比平时更多，所以对于原有的服务器集群可能根本负载不起用户的请求量，一方面通过引入弹性伸缩来增加服务的硬件措施，另一方面通过某些负载均衡算法使得服务器集群内部每一台服务器的负载量是合理的。</p><p>负载均衡方案<br>1、DNS方案    -    地域上的流量均衡</p><p>2、硬件方案    -    大型服务器集群负载均衡</p><p>3、软件方案    -    机器层面的流量负载均衡</p><p>DNS方案<br>让DNS服务器根据不同的地理位置的用户返回不同的服务器IP，如广州的用户可以返回广州机房中服务器的IP，北京的用户可以返回北京机房中服务器的IP。<br>然而，DNS查找服务器IP的方式有两种，一种是递归查询，一种是迭代查询。由于DNS的几级缓存可能导致配置修改生效不及时，从而影响负载均衡的效果。 </p><blockquote><p>软件方案<br>软件方案大多都是使用一些列的负载均衡算法，如轮训算法，负载度策略算法、响应策略、哈希策略。<br>常用的由LVS和Nginx，<br>LVS是基于4层网络协议（TCP）<br>Nginx是基于5层网络协议(应用层，传输层)<br>LVS由于是基于底层的网络协议，主要是TCP协议，由IP来转发，处理量在几十万/秒。<br>Nginx是基于7层网络协议，如Http、SMTP协议，处理量在几万/秒。</p><p>常用的负载均衡算法<br>1、轮询策略，在DNS方案负载均衡方案中较为常见，根据域的权重比来分配流量。<br>2、负载度策略，负载均衡器向后端服务器中采集参数，如每台服务器的CPU负载指标，连接请求等参数来动态分配流量到不同的服务器。<br>3、响应策略，这种做法更注重用户的体验，由负载均衡器不断向后（如每隔1分钟采集一次）端采集每一台后端服务器的响应速度来将数据流量转发到当前处理速度最快的服务器。<br>4、哈希策略，率先给后端服务器的主机进行编号，通过哈希算法将请求转发到对应哈希运算结果对应的服务器中。如，采用取模的哈希算法，将数据包对后端机器数量进行取模后得到一个值Q，最终将数据包转发到编号为Q的服务器。 </p></blockquote><h2 id="http连接池的作用，有哪些优化？"><a href="#http连接池的作用，有哪些优化？" class="headerlink" title="http连接池的作用，有哪些优化？"></a><strong>http</strong>连接池的作用，有哪些优化？</h2><p>HTTP是建立在TCP上面的，一次HTTP请求要经历TCP三次握手阶段，然后发送请求，得到相应，最后TCP断开连接。如果我们要发出多个HTTP请求，每次都这么搞，那每次要握手、请求、断开，就太浪费了，如果是HTTPS请求，就更加浪费了，每次HTTPS请求之前的连接多好几个包（不包括ACK的话会多4个）。所以如果我们在TCP或HTTP连接建立之后，可以传输、传输、传输，就能省很多资源。于是就有了“HTTP（S）连接池”的概念。和线程池非常像是不是。本文介绍连接池，连接池管理器，主要基于Python和 requests, urllib3 两个库。主要讲HTTP连接池，HTTPS连接池原理一样，只不过不光缓存TCP连接，还有发起请求之前对证书认证等过程。</p><blockquote><p>http连接池是什么？http连接池就是一个池子，里面装满了连接，哈哈哈。连接就是一条通路，例如打电话，通了之后，就是一个连接。把这些连接放在一起就是连接池啦。<br>以通电话为例子，例如有下面几通接通的电话：<br>1.跟主席连通的电话<br>2.跟总理连通的电话<br>3.跟总司令连接的电话<br>4.跟指导员连接的电话<br>这一堆连通的电话机放在的一个神秘的小黑屋，这个小黑屋就是连接池啦</p><p>而每个进小黑屋跟大领导通电话的人可以认为就是httpclient，而大领导就是各个服务器啦。大领导可忙了，如果每个进小黑屋的人跟大领导通完电话就挂断的话，那得多浪费大领导的时间，所以小黑屋里面的电话不能随便挂断，要过一段时间一直没有人跟大领导通话了才能挂断。这个就是连接池（小黑屋）的原理。<br>所以有一下两个特征：<br>1.连接池里面保存着可以马上通信的连接，免除了重新建立连接的麻烦<br>2.连接如果长期不用，就会挂断。</p></blockquote><p>大概就是三个步骤：<br>1.查看有没有过期的连接，有则干掉他<br>2.查看没事干的空闲的连接是不是过多了，按时间顺序干掉一部分。先把老的干掉<br>3.如果没有东西要清理，清理线程则休息一下。当有连接进入的时候，就起来继续干活，哈哈哈。</p><blockquote><p>1.为什么要用Http连接池</p><p>1、降低延迟：如果不采用连接池，每次连接发起Http请求的时候都会重新建立TCP连接(经历3次握手)，用完就会关闭连接(4次挥手)，如果采用连接池则减少了这部分时间损耗，别小看这几次握手，本人经过测试发现，基本上3倍的时间延迟</p><p>2、支持更大的并发：如果不采用连接池，每次连接都会打开一个端口，在大并发的情况下系统的端口资源很快就会被用完，导致无法建立新的连接</p><p>2.简单连接管理器</p><p>是个简单的连接管理器，它一次只能管理一个连接。尽管这个类是线程安全的，它在同一时间也只能被一个线程使用。会尽量重用旧的连接来发送后续的请求，并且使用相同的路由。如果后续请求的路由和旧连接中的路由不匹配，就会关闭当前连接，使用请求中的路由重新建立连接。如果当前的连接正在被占用，会抛出异常。</p><p>3.连接池管理器</p><p>相对来说，是个更复杂的类，它管理着连接池，可以同时为很多线程提供http连接请求。Connections are pooled on a per route basis.当请求一个新的连接时，如果连接池有有可用的持久连接，连接管理器就会使用其中的一个，而不是再创建一个新的连接。</p><p>维护的连接数在每个路由基础和总数上都有限制。默认，每个路由基础上的连接不超过2个，总连接数不能超过20。在实际应用中，这个限制可能会太小了，尤其是当服务器也使用Http协议时。</p><p>下面的例子演示了如果调整连接池的参数：</p><p>4.关闭连接管理器</p><p>当一个HttpClient的实例不在使用，或者已经脱离它的作用范围，我们需要关掉它的连接管理器，来关闭掉所有的连接，释放掉这些连接占用的系统资源。</p><p>\5. 连接回收策略</p><p>经典阻塞I/O模型的一个主要缺点就是只有当组侧I/O时，socket才能对I/O事件做出反应。当连接被管理器收回后，这个连接仍然存活，但是却无法监控socket的状态，也无法对I/O事件做出反馈。如果连接被服务器端关闭了，客户端监测不到连接的状态变化（也就无法根据连接状态的变化，关闭本地的socket）。</p><p>HttpClient为了缓解这一问题造成的影响，会在使用某个连接前，监测这个连接是否已经过时，如果服务器端关闭了连接，那么连接就会失效。这种过时检查并不是100%有效，并且会给每个请求增加10到30毫秒额外开销。唯一一个可行的，且does not involve a one thread per socket model for idle connections的解决办法，是建立一个监控线程，来专门回收由于长时间不活动而被判定为失效的连接。这个监控线程可以周期性的调用类的方法来关闭过期的连接，回收连接池中被关闭的连接。它也可以选择性的调用类的方法来关闭一段时间内不活动的连接。</p><p>\6. 连接存活策略</p><p>Http规范没有规定一个持久连接应该保持存活多久。有些Http服务器使用非标准的头消息和客户端进行交互，服务器端会保持数秒时间内保持连接。HttpClient也会利用这个头消息。如果服务器返回的响应中没有包含头消息，HttpClient会认为这个连接可以永远保持。然而，很多服务器都会在不通知客户端的情况下，关闭一定时间内不活动的连接，来节省服务器资源。在某些情况下默认的策略显得太乐观，我们可能需要自定义连接存活策略。</p><p><strong>7.原理及注意事项</strong></p><p>连接池中连接都是在发起请求的时候建立，并且都是长连接</p><p><strong>in.close();作用就是将用完的连接释放，下次请求可以复用，这里特别注意的是，如果不使用in.close();而仅仅使用response.close();结果就是连接会被关闭，并且不能被复用，这样就失去了采用连接池的意义。</strong></p><p>连接池释放连接的时候，并不会直接对TCP连接的状态有任何改变，只是维护了两个Set，leased和avaliabled，leased代表被占用的连接集合，avaliabled代表可用的连接的集合，释放连接的时候仅仅是将连接从leased中remove掉了，并把连接放到avaliabled集合中</p></blockquote><h3 id="DNS是干什么的？"><a href="#DNS是干什么的？" class="headerlink" title="DNS是干什么的？"></a>DNS是干什么的？</h3><p><strong>DNS**</strong>协议：**运行在UDP协议之上，服务器监听端口号为53：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询。</p><p>（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，依次类推）</p><p><strong>主机解析域名的顺序：</strong>找缓存、找本机的hosts文件、找DNS服务器</p><p><img src="/2019/08/31/计算机网络/c44d92b9c250a5365fc228d71d714e9.png" alt="c44d92b9c250a5365fc228d71d714e9"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解析过程：10步</span><br><span class="line">浏览器先检查自身缓存中有没有被解析过这个域名对应的ip地址；</span><br><span class="line">如果浏览器缓存没有命中，浏览器会检查操作系统缓存中有没有对应的已解析过的结果。在windows中可通过c盘里hosts文件来设置；</span><br><span class="line">还没命中，请求本地域名服务器来解析这个域名，一般都会在本地域名服务器找到；</span><br><span class="line">本地域名服务器没有命中，则去根域名服务器请求解析；</span><br><span class="line">根域名服务器返回给本地域名服务器一个所查询域的主域名服务器；</span><br><span class="line">本地域名服务器向主域名服务器发送请求；</span><br><span class="line">接受请求的主域名服务器查找并返回这个域名对应的域名服务器的地址；</span><br><span class="line">域名服务器根据映射关系找到ip地址，返回给本地域名服务器；</span><br><span class="line">本地域名服务器缓存这个结果；</span><br><span class="line">本地域名服务器将该结果返回给用户；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络层-IP&quot;&gt;&lt;a href=&quot;#网络层-IP&quot; class=&quot;headerlink&quot; title=&quot;网络层(IP)&quot;&gt;&lt;/a&gt;网络层(IP)&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;1-mac和ip怎么转换&quot;&gt;&lt;a href=&quot;#1-mac和ip怎么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://yoursite.com/2019/08/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/31/网络编程/</id>
    <published>2019-08-31T13:42:07.000Z</published>
    <updated>2019-08-31T13:47:42.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h3><ol><li>网络编程一般步骤？<ul><li>TCP：<ul><li>服务端：socket -&gt; bind -&gt; listen -&gt; accept -&gt; recv/send -&gt; close。</li><li>客户端：socket -&gt; connect -&gt; send/recv -&gt; close。</li></ul></li><li>UDP：<ul><li>服务端：socket -&gt; bind -&gt; recvfrom/sendto -&gt; close。</li><li>客户端：socket -&gt; sendto/recvfrom -&gt; close。</li></ul></li></ul></li><li>send、sendto区别，recv、recvfrom区别？</li></ol><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><ol><li>TCP和UDP区别？<ul><li>TCP面向连接（三次握手），通信前需要先建立连接；UDP面向无连接，通信前不需要连接。</li><li>TCP通过序号、重传、流量控制、拥塞控制实现可靠传输；UDP不保障可靠传输，尽最大努力交付。</li><li>TCP面向字节流传输，因此可以被分割并在接收端重组；UDP面向数据报传输。</li></ul></li><li>TCP为什么不是两次握手而是三次？<ul><li>如果仅两次连接可能出现一种情况：客户端发送完连接报文（第一次握手）后由于网络不好，延时很久后报文到达服务端，服务端接收到报文后向客户端发起连接（第二次握手）。此时客户端会认定此报文为失效报文，但在两次握手情况下服务端会认为已经建立起了连接，服务端会一直等待客户端发送数据，但因为客户端会认为服务端第二次握手的回复是对失效请求的回复，不会去处理。这就造成了服务端一直等待客户端数据的情况，浪费资源。</li></ul></li><li>TCP为什么挥手是四次而不是三次？<ul><li>TCP是全双工的，它允许两个方向的数据传输被独立关闭。当主动发起关闭的一方关闭连接之后，TCP进入半关闭状态，此时主动方可以只关闭输出流。</li><li>之所以不是三次而是四次主要是因为被动关闭方将”对主动关闭报文的确认”和”关闭连接”两个操作分两次进行。</li><li>“对主动关闭报文的确认”是为了快速告知主动关闭方，此关闭连接报文已经收到。此时被动方不立即关闭连接是为了将缓冲中剩下的数据从输出流发回主动关闭方（主动方接收到数据后同样要进行确认），因此要把”确认关闭”和”关闭连接”分两次进行。</li><li><strong>Linux的close实际上是同时关闭输入流和输出流，并不是我们常说的四次握手。半关闭函数为shutdown，它可以用来断开某个具体描述符的TCP输入流或输出流。</strong></li></ul></li><li>为什么要有TIME_WAIT状态，TIME_WAIT状态过多怎么解决？<ul><li>主动关闭连接一方在发送对被动关闭方关闭连接的确认报文时，有可能因为网络状况不佳，被动关闭方超时未能收到此报文而重发断开连接（FIN）报文，此时如果主动方不等待而是直接进入CLOSED状态，则接收到被动关闭方重发的断开连接的报文会触发RST分组而非ACK分组，当被动关闭一方接收到RST后会认为出错了。所以说处于TIME_WAIT状态就是为了在重新收到断开连接分组情况下进行确认。</li><li>解决方法：<ul><li>可以通过修改sysctl中TIME_WAIT时间来减少此情况（HTTP 1.1也可以减少此状态）。</li><li>利用SO_LINGER选项的强制关闭方式，发RST而不是FIN，来越过TIMEWAIT状态，直接进入CLOSED状态。</li></ul></li></ul></li><li>TCP建立连接及断开连接是状态转换？<ul><li>客户端：SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT。</li><li>服务端：LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED。</li></ul></li><li>TCP流量控制和拥塞控制的实现？<ul><li>流量控制：TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节，在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限，发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。</li><li>拥塞控制：网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象。严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。</li></ul></li><li>TCP重传机制？<ul><li>滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少、尚未确认的字节数、尚待发送的字节数；让接收方知道已经确认收到的字节数。</li><li>选择重传，用于对传输出错的序列进行重传。</li></ul></li><li>三次握手过程？<ul><li>主动建立连接方A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号x进行同步，表明在后面传送数据时的第一个数据字节的序号是x + 1。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。</li><li>接收连接方B的TCP收到连接请求报文段后，如同意则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为x + 1，同时也为自己选择一个序号y。</li><li>主动方A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为y + 1，而自己的序号为x + 1。</li></ul></li><li>四次挥手过程？<ul><li>主动关闭主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，将发往主机B的TCP报文段首部的终止比特FIN置1，其序号x等于前面已传送过的数据的最后一个字节的序号加1。</li><li>被动关闭主机B的TCP收到释放连接通知后即发出确认，其序号为y，确认号为x + 1，同时通知高层应用进程，这样，从A到B的连接就释放了，连接处于半关闭状态。但若主机B还有一些数据要发送主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。</li><li>若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须将终止比特FIN和确认比特ACK置1，并使其序号仍为y，但还必须重复上次已发送过的ACK = x + 1。</li><li>主机A必须对此发出确认，将ACK置1，ACK = y + 1，而自己的序号是x + 1。这样才把从B到A的反方向的连接释放掉。主机A的TCP再向其应用进程报告，整个连接已经全部释放。</li></ul></li></ol><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><ol><li>阻塞和非阻塞I/O区别？<ul><li>如果内核缓冲没有数据可读时，read()系统调用会一直等待有数据到来后才从阻塞态中返回，这就是阻塞I/O。</li><li>非阻塞I/O在遇到上述情况时会立即返回给用户态进程一个返回值，并设置errno为EAGAIN。</li><li>对于往缓冲区写的操作同理。</li></ul></li><li>同步和异步区别？<ul><li>同步I/O指处理I/O操作的进程和处理I/O操作的进程是同一个。</li><li>异步I/O中I/O操作由操作系统完成，并不由产生I/O的用户进程执行。</li></ul></li><li>Reactor和Proactor区别？<ul><li>Reactor模式已经是同步I/O，处理I/O操作的依旧是产生I/O的程序；Proactor是异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。</li><li>异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。</li></ul></li><li>epoll和select及poll区别？<ul><li>文件描述符数量限制：select文件描述符数量受到限制，最大为2048（FD_SETSIZE），可重编内核修改但治标不治本；poll没有最大文件描述符数量限制；epoll没有最大文件描述符数量限制。</li><li>检查机制：select和poll会以遍历方式（轮询机制）检查每一个文件描述符以确定是否有I/O就绪，每次执行时间会随着连接数量的增加而线性增长；epoll则每次返回后只对活跃的文件描述符队列进行操作（每个描述符都通过回调函数实现，只有活跃的描述符会调用回调函数并添加至队列中）。<strong>当大量连接是非活跃连接时epoll相对于select和poll优势比较大，若大多为活跃连接则效率未必高（设计队列维护及红黑树创建）</strong></li><li>数据传递方式：select和poll需要将FD_SET在内核空间和用户空间来回拷贝；epoll则避免了不必要的数据拷贝。</li></ul></li><li>epoll中ET和LT模式的区别与实现原理？<ul><li>LT：默认工作方式，同时支持阻塞I/O和非阻塞I/O，LT模式下，内核告知某一文件描述符读、写是否就绪了，然后你可以对这个就绪的文件描述符进行I/O操作。如果不作任何操作，内核还是会继续通知。这种模式编程出错误可能性较小但由于重复提醒，效率相对较低。传统的select、poll都是这种模型的代表。</li><li>ET：高速工作方式（因为减少了epoll_wait触发次数），适合高并发，只支持非阻塞I/O，ET模式下，内核告知某一文件描述符读、写是否就绪了，然后他假设已经知道该文件描述符是否已经就绪，内核不会再为这个文件描述符发更多的就绪通知（epoll_wait不会返回），直到某些操作导致文件描述符状态不再就绪。</li></ul></li><li>ET模式下要注意什么（如何使用ET模式）？<ul><li>对于读操作，如果read没有一次读完buff数据，下一次将得不到就绪通知（ET特性），造成buff中数据无法读出，除非有新数据到达。<ul><li>解决方法：将套接字设置为非阻塞，用while循环包住read，只要buff中有数据，就一直读。一直读到产生EAGIN错误。</li></ul></li><li>对于写操作主要因为ET模式下非阻塞需要我们考虑如何将用户要求写的数据写完。<ul><li>解决方法：只要buff还有空间且用户请求写的数据还未写完，就一直写。</li></ul></li></ul></li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>Linux下进程间通信方式？<ul><li>管道：<ul><li>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</li></ul></li><li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</li><li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</li><li>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</li></ul></li><li>Linux下同步机制？<ul><li>POSIX信号量：可用于进程同步，也可用于线程同步。</li><li>POSIX互斥锁 + 条件变量：只能用于线程同步。</li></ul></li><li>线程和进程的区别？<ul><li>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li><li>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</li><li>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li><li>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</li></ul></li><li>介绍虚拟内存？</li><li>内存分配及碎片管理？</li><li>有很多小的碎片文件怎么处理？</li></ol><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ol><li>fork系统调用？</li><li>什么场景用共享内存，什么场景用匿名管道？</li><li>有没有用过开源的cgi框架？</li><li>epoll和select比有什么优势有什么劣势，epoll有什么局限性？<ul><li>epoll优势：1. 没有描述符数量限制；2. 通过回调代替轮询；3. 内存映射代替数据在用户和内核空间来回拷贝。</li><li>epoll劣势（局限性）：select可以跨平台，epoll只能在Linux上使用。</li></ul></li><li>线程（POSIX）锁有哪些？<ul><li>互斥锁（mutex）<ul><li>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。</li></ul></li><li>条件变量(cond)</li><li>自旋锁(spin)<ul><li>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</li><li>虽然它的效率比互斥锁高，但是它也有些不足之处：<ul><li>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</li><li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</li></ul></li><li>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</li></ul></li><li>读写锁（rwlock）</li></ul></li></ol><h2 id="TKeed"><a href="#TKeed" class="headerlink" title="TKeed"></a>TKeed</h2><ol><li>项目整体架构是什么？请求怎么进来？处理完怎么出去？<ul><li>整体架构为：I/O多路复用 + 非阻塞I/O + 线程池，即Reactor反应堆模型。</li><li>处理流程：<ul><li>创建监听描述符并在epoll中注册。</li><li>监听到新请求，epoll从阻塞中返回并建立新连接。</li><li>将新建的连接描述符在epoll中注册。</li><li>当某个连接接收到用户请求数据时，将任务投放到线程池任务队列中。</li><li>工作线程被条件变量（任务队列不为空）唤醒，并互斥访问线程池。</li><li>得到任务的线程完成解析及响应。<ul><li>工作线程执行函数为do_request，参数即为task结构。<ul><li>每个task结构在建立连接是被初始化，包含描述符、缓冲区等信息是，并在do_request执行时记录解析结果及状态。</li></ul></li></ul></li></ul></li></ul></li><li>在做压测时，机器配置是什么样的？数据如何？<ul><li>本地测试。<ul><li>四核i5处理器 + 128G固态硬盘。</li></ul></li></ul></li><li>为了QPS（Query per second, 1秒内完成的请求数量）更高可以做哪些改进？<ul><li>对请求结果做缓存。</li><li>多次搜索请求采用异步I/O，改串行为并行。</li><li>调整并发线程数量（通常和CPU核心数相同）。</li></ul></li><li>有没有注意到压测时内存，CPU，I/O指标？<ul><li>压测同时打开top -H -p pid查看CPU，I/O，内存信息。</li></ul></li><li>压测时有没有见过TIME_WAIT？怎么样会见到？怎么解决？<ul><li>当服务端关闭连接时会产生TIME_WAIT。</li><li>解决方案：<ul><li>HTTP 1.1在同一个TCP连接上尽量传输更多数据。</li><li>通过修改sysctl配置减小TIME_WAIT时间。</li></ul></li></ul></li><li>是会主动关闭还是会等待客户端关闭连接?<ul><li>服务端会在完成请求之后关闭连接。</li></ul></li><li>写一个Server需要注意哪些问题？<ul><li>只支持request/response，除此之外是否需要支持cgi。</li><li>并发量，QPS，资源占用（内存，CPU，I/O，网络流量等）。<ul><li>CPU占用是否过高。</li><li>内存是否泄露。</li></ul></li></ul></li><li>项目中遇到什么困难，你是如何解决的？<ul><li>CPU占用过高。</li><li>压测时，每次最后会挂掉。</li></ul></li><li>做这个项目的目的是什么？</li><li>定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？</li><li>如果发生超时，在关闭连接时同时又收到了新的数据怎么办？</li><li>用什么数据结构存放url，怎么解析的？<ul><li>使用tk_request_t结构中buff读取用户请求，buff为循环缓冲（8192 Bytes）。</li><li>每次进入while循环时读取用户请求到buff中循环队列尾位置（plast），之后解析用户请求并响应。</li><li>支持HTTP 1.1，只要有数据就读取 -&gt; 解析 -&gt; 响应。</li></ul></li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>层序遍历二叉树？</li><li>map和hashmap的区别是什么？</li><li>Hash发生冲突时怎么处理？</li><li>hashmap的时间复杂度是多少？map的时间复杂度？</li><li>优先队列时间复杂度？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;h3 id=&quot;Socket-API&quot;&gt;&lt;a href=&quot;#Socket-API&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统理论</title>
    <link href="http://yoursite.com/2019/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/08/31/操作系统理论/</id>
    <published>2019-08-31T13:40:08.000Z</published>
    <updated>2019-08-31T13:40:30.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a>进程线程模型</h3><p>线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。</p><p><strong>多线程</strong></p><p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。我们必须知道，做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p><p>对于线程，我认为弄清以下两点非常重要：</p><ul><li>线程之间有无先后访问顺序（线程依赖关系）</li><li>多个线程共享访问同一变量（同步互斥问题）</li></ul><p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p><ol><li><p>线程创建和结束</p><ul><li><p>背景知识：</p><p>在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p></li><li><p>相关接口：</p><ul><li><p>创建线程：int pthread_create(pthread_t <em>pthread, const pthread_attr_t </em>attr, void <em>(</em>start_routine)(void <em>), void </em>agr);</p><p>创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。</p><ul><li>pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。</li><li>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</li><li>start_routine：线程执行函数的首地址，传入函数指针。</li><li>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</li></ul></li><li><p>获得线程ID：pthread_t pthread_self();</p><p>调用时，会打印线程ID。</p></li><li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);</p><p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li>tid：创建线程时通过指针得到tid值。</li><li>retval：指向返回值的指针。</li></ul></li><li><p>结束线程：pthread_exit(void *retval);</p><p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p>分离线程：int pthread_detach(pthread_t tid);</p><p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p><ul><li>tid：同上。</li></ul></li></ul></li></ul></li><li><p>线程属性值修改</p><ul><li><p>背景知识：</p><p>线程属性对象类型为pthread_attr_t，结构体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int etachstate;    // 线程分离的状态</span><br><span class="line">    int schedpolicy;    // 线程调度策略</span><br><span class="line">    struct sched_param schedparam;    // 线程的调度参数</span><br><span class="line">    int inheritsched;    // 线程的继承性</span><br><span class="line">    int scope;    // 线程的作用域</span><br><span class="line">    // 以下为线程栈的设置</span><br><span class="line">    size_t guardsize;    // 线程栈末尾警戒缓冲大小</span><br><span class="line">    int stackaddr_set;    // 线程的栈设置</span><br><span class="line">    void *    stackaddr;    // 线程栈的位置</span><br><span class="line">    size_t stacksize;    // 线程栈大小</span><br><span class="line">&#125;pthread_arrt_t;</span><br></pre></td></tr></table></figure></li><li><p>相关接口：</p><p>对上述结构体中各参数大多有：pthread_attr_get<strong><em>()和pthread_attr_set</em></strong>()系统调用函数来设置和获取。这里不一一罗列。</p></li></ul></li><li><p>线程同步</p><ul><li><a href="https://github.com/linw7/Skill-Tree/blob/master/操作系统.md#mutex" target="_blank" rel="noopener">详见同步互斥专题</a></li></ul></li></ol><p><strong>多进程</strong></p><p>每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。</p><p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p><ol><li><p>进程创建与结束</p><ul><li><p>背景知识：</p><p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></li><li><p>相关接口：</p><ul><li><p>创建进程：pid_t fork(void);</p><p>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid == 0</p></li><li><p>结束进程：void exit(int status);</p><ul><li>status是退出状态，保存在全局变量中S?，通常0表示正常退出。</li></ul></li><li><p>获得PID：pid_t getpid(void);</p><p>返回调用者pid。</p></li><li><p>获得父进程PID：pid_t getppid(void);</p><p>返回父进程pid。</p></li></ul></li><li><p>其他补充：</p><ul><li><p>正常退出方式：exit()、_exit()、return（在main中）。</p><p>exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p><p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p></li><li><p>异常退出方式：abort()、终止信号。</p></li></ul></li></ul></li><li><p>僵尸进程、孤儿进程</p><ul><li><p>背景知识：</p><p>父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。</p></li><li><p>相关接口：</p><ul><li><p>回收进程（1）：pid_t wait(int *status);</p><p>一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。</p><ul><li>status：指向子进程结束状态值。</li></ul></li><li><p>回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options);</p><p>返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。</p><ul><li>pid：子进程识别码，控制等待哪些子进程。<ol><li>pid &lt; -1，等待进程组识别码为pid绝对值的任何进程。</li><li>pid = -1，等待任何子进程。</li><li>pid = 0，等待进程组识别码与目前进程相同的任何子进程。</li><li>pid &gt; 0，等待任何子进程识别码为pid的子进程。</li></ol></li><li>status：指向返回码的指针。</li><li>options：选项决定父进程调用waitpid后的状态。<ol><li>options = WNOHANG，即使没有子进程退出也会立即返回。</li><li>options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。</li></ol></li></ul></li></ul></li></ul></li><li><p>守护进程</p></li></ol><ul><li><p>背景知识：</p><p>守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。</p></li><li><p>操作步骤：</p><ul><li>创建子进程，父进程退出：fork() + if(pid &gt; 0){exit(0);}，使子进程称为孤儿进程被init进程收养。</li><li>在子进程中创建新会话：setsid()。</li><li>改变当前目录结构为根：chdir(“/“)。</li><li>重设文件掩码：umask(0)。</li><li>关闭文件描述符：for(int i = 0; i &lt; 65535; ++i){close(i);}。</li></ul></li></ul><ol><li>Linux进程控制</li></ol><ul><li><p>进程地址空间（地址空间）</p><p>虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些”敏感”的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p></li><li><p>进程控制块（处理机）</p><p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p></li><li><p>上下文切换</p><p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p></li></ul><p><strong>线程、进程比较</strong></p><p>关于进程和线程的区别这里就不一一罗列了，主要对比下线程和进程操作中主要的接口。</p><ul><li><p>fork()和pthread_create()</p><p>负责创建。调用fork()后返回两次，一次标识主进程一次标识子进程；调用pthread_create()后得到一个可以独立执行的线程。</p></li><li><p>wait()和pthread_join()</p><p>负责回收。调用wait()后父进程阻塞；调用pthread_join()后主线程阻塞。</p></li><li><p>exit()和pthread_exit()</p><p>负责退出。调用exit()后调用进程退出，控制权交给系统；调用pthread_exit()后线程退出，控制权交给主线程。</p></li></ul><hr><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p><p><strong>管道</strong></p><ul><li>无名管道<ul><li>无名管道特点：<ul><li>无名管道是一种特殊的文件，这种文件只存在于内存中。</li><li>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</li><li>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</li></ul></li><li>相关接口：<ul><li>int pipe(int fd[2]);<ul><li>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</li></ul></li></ul></li></ul></li><li>有名管道：<ul><li>有名管道特点：<ul><li>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</li><li>无名管道可以在不具有亲缘关系的进程间进行通信。</li></ul></li><li>相关接口：<ul><li>int mkfifo(const char *pathname, mode_t mode);<ul><li>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</li><li>mode：和open()中的参数相同。</li></ul></li></ul></li></ul></li></ul><p><strong>消息队列</strong></p><p><strong>共享内存</strong></p><p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p><ul><li><p>相关接口</p><ul><li><p>创建共享内存：int shmget(key_t key, int size, int flag);</p><p>成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。</p><ul><li>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</li><li>size：共享内存容量。</li><li>flag：权限标志位，和open的mode参数一样。</li></ul></li><li><p>连接到共享内存地址空间：void <em>shmat(int shmid, void </em>addr, int flag);</p><p>返回值即共享内存实际地址。</p><ul><li>shmid：shmget()返回的标识。</li><li>addr：决定以什么方式连接地址。</li><li>flag：访问模式。</li></ul></li><li><p>从共享内存分离：int shmdt(const void *shmaddr);</p><p>调用成功返回0，失败返回-1。</p><ul><li>shmaddr：是shmat()返回的地址指针。</li></ul></li></ul></li><li><p>其他补充</p><p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p><p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p></li></ul><p><strong>信号量</strong></p><p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量， 而在进程里使用SYSTEM V信号量。</p><ul><li><p>相关接口</p><ul><li><p>创建信号量：int semget(key_t key, int nsems, int semflag);</p><p>创建成功返回信号量标识符，失败返回-1。</p><ul><li>key：进程pid。</li><li>nsems：创建信号量的个数。</li><li>semflag：指定信号量读写权限。</li></ul></li><li><p>改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);</p><p>我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p><p>struct sembuf结构体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sembuf&#123;</span><br><span class="line">    short sem_num;</span><br><span class="line">    short sem_op;</span><br><span class="line">    short sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成功返回信号量标识符，失败返回-1。</p><ul><li>semid：信号量集标识符，由semget()函数返回。</li><li>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</li><li>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</li></ul></li><li><p>直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);</p><ul><li>semid：信号量集标识符。</li><li>semnum：信号量集数组上的下标，表示某一个信号量。</li><li>arg：union semun类型。</li></ul></li></ul></li></ul><p><strong>辅助命令</strong></p><p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p><ul><li>ipcs -a：列出共享内存、信号量和消息队列信息。</li><li>ipcs -l：列出系统限额。</li><li>ipcs -u：列出当前使用情况。</li></ul><p><strong>套接字</strong></p><ul><li><a href="https://github.com/linw7/Skill-Tree/blob/master/计算机网络.md" target="_blank" rel="noopener">详见socket交互流程</a></li><li><a href="https://github.com/linw7/Skill-Tree/blob/master/操作系统.md#netio" target="_blank" rel="noopener">详见网络I/O模型</a></li></ul><hr><h3 id="同步互斥机制"><a href="#同步互斥机制" class="headerlink" title="同步互斥机制"></a>同步互斥机制</h3><blockquote><p>待补充</p></blockquote><hr><h3 id="网络I-O模型"><a href="#网络I-O模型" class="headerlink" title="网络I/O模型"></a>网络I/O模型</h3><p>在描述这块内容的诸多书籍中，很多都只说笼统的概念，我们将问题具体化，暂时只考虑服务器端的网络I/O情形。我们假定目前的情形是服务器已经在监听用户请求，建立连接后服务器调用read()函数等待读取用户发送过来的数据流，之后将接收到的数据打印出来。</p><p>所以服务器端简单是这样的流程：建立连接 -&gt; 监听请求 -&gt; 等待用户数据 -&gt; 打印数据。我们总结网络通信中的等待：</p><ul><li>建立连接时等待对方的ACK包（TCP）。</li><li>等待客户端请求（HTTP）。</li><li>输入等待：服务器用户数据到达内核缓冲区（read函数等待）。</li><li>输出等待：用户端等待缓冲区有足够空间可以输入（write函数等待）。</li></ul><p>另外为了能够解释清楚网络I/O模型，还需要了解一些基础。对服务器而言，打印出用户输入的字符串（printf函数）和从网络中获取数据（read函数）需要单独来看。服务器首先accept用户连接请求后首先调用read函数等待数据，这里的read函数是系统调用，运行于内核态，使用的也是内核地址空间，并且从网络中取得的数据需要先写入到内核缓冲区。当read系统调用获取到数据后将这些数据再复制到用户地址空间的用户缓冲区中，之后返回到用户态执行printf函数打印字符串。我们需要明确两点：</p><ul><li>read执行在内核态且数据流先读入内核缓冲区；printf运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来。</li><li>printf函数一定是在read函数已经准备好数据之后才能执行，但read函数作为I/O操作通常需要等待而触发阻塞。调用read函数的是服务器进程，一旦被read调用阻塞，整个服务器在获取到用户数据前都不能接受任何其他用户的请求（单进程/线程）。</li></ul><p>有了上面的基础，我们就可以介绍下面四种网路I/O模型。</p><p><strong>阻塞式</strong></p><ul><li>阻塞表示一旦调用I/O函数必须等整个I/O完成才返回。正如上面提到的那种情形，当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -&gt; 用户态）。</li><li>很显然，阻塞式I/O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程/线程）。为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I/O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。</li><li>多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I/O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。</li></ul><p><strong>非阻塞I/O</strong></p><ul><li>阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。</li><li>可以使用以下语句将句柄fd设置为非阻塞I/O：fcntl(fd, F_SETFL, O_NONBLOCK);</li><li>非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。</li><li>非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。</li></ul><p><strong>I/O多路复用（事件驱动模型）</strong></p><p>前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。</p><p>所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I/O多路复用就是这么一种模型。Linux下I/O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I/O范畴。</p><ol><li><p>select</p><ul><li><p>相关接口：</p><p>int select (int maxfd, fd_set <em>readfds, fd_set </em>writefds, fd_set <em>errorfds, struct timeval </em>timeout);</p><p>FD_ZERO(int fd, fd_set* fds) //清空集合</p><p>FD_SET(int fd, fd_set* fds) //将给定的描述符加入集合</p><p>FD_ISSET(int fd, fd_set* fds) //将给定的描述符从文件中删除</p><p>FD_CLR(int fd, fd_set* fds) //判断指定描述符是否在集合中</p></li><li><p>参数： maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。</p><p>readfds：指向读文件队列集合（fd_set）的指针。</p><p>writefds：同上，指向读集合的指针。</p><p>writefds：同上，指向错误集合的指针。</p><p>timeout：指向timeval结构指针，用于设置超时。</p></li><li><p>其他：</p><p>判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。</p></li></ul></li><li><p>poll</p><ul><li><p>相关接口： int poll(struct pollfd *fds, unsigned int nfds, int timeout);</p></li><li><p>结构体定义： struct pollfd{ int fd; // 文件描述符 short events; // 等到的事件 short revents; // 实际发生的事件 }</p></li><li><p>参数： fds：指向pollfd结构体数组的指针。</p><p>nfds：pollfd数组当前已被使用的最大下标。</p><p>timeout：等待毫秒数。</p></li><li><p>其他：</p><p>判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。</p></li></ul></li><li><p>epoll</p><ul><li><p>相关接口： int epoll_create(int size); // 创建epoll句柄 int epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event); // 事件注册函数 int epoll_wait(int epfd, struct epoll_event </em> events, int maxevents, int timeout);</p></li><li><p>结构体定义： struct epoll_event{ <strong>uint32_t events; epoll_data_t data; }; typedef union epoll_data{ void *ptr; int fd; </strong>uint32_t u32; __uint64_t u64; }epoll_data_t;</p></li><li><p>参数：</p><p>size：用来告诉内核要监听的数目。</p><p>epfd：epoll函数的返回值。</p><p>op：表示动作（EPOLL_CTL_ADD/EPOLL_CTL_FD/EPOLL_CTL_DEL）。</p><p>fd：需要监听的fd。</p><p>events：指向epoll_event的指针，该结构记录监听的事件。</p><p>maxevents：告诉内核events的大小。</p><p>timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。</p></li></ul></li><li><p>select、poll和epoll区别</p><ul><li><p>操作方式及效率：</p><p>select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。</p></li><li><p>最大连接数：</p><p>select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。</p></li><li><p>fd拷贝：</p><p>select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。</p></li><li><p>其他：</p><p>select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。</p></li></ul></li></ol><p><strong>异步I/O模型</strong></p><ul><li>上面三种I/O方式均属于同步I/O。</li><li>从阻塞式I/O到非阻塞I/O，我们已经做到了调用I/O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I/O能够立即返回又能不一直轮询的话会更符合我们的预期。</li><li>之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I/O结果。如果内核能够在完成I/O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I/O就是这么回事。</li><li>异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞。看上去异步I/O和非阻塞I/O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程线程模型&quot;&gt;&lt;a href=&quot;#进程线程模型&quot; class=&quot;headerlink&quot; title=&quot;进程线程模型&quot;&gt;&lt;/a&gt;进程线程模型&lt;/h3&gt;&lt;p&gt;线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++理论</title>
    <link href="http://yoursite.com/2019/08/31/C-%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/08/31/C-理论/</id>
    <published>2019-08-31T13:37:55.000Z</published>
    <updated>2019-08-31T13:38:46.156Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h3><p>C/C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。</p><ol><li>变量声明和定义区别？<ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</li><li>相同变量可以再多处声明（外部变量extern），但只能在一处定义。</li></ul></li><li>“零值比较”？<ul><li>bool类型：if(flag)</li><li>int类型：if(flag == 0)</li><li>指针类型：if(flag == null)</li><li>float类型：if((flag &gt;= -0.000001) &amp;&amp; (flag &lt;= 0. 000001))</li></ul></li><li>strlen和sizeof区别？<ul><li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li><li><strong>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</strong></li></ul></li><li>同一不同对象可以互相赋值吗？<ul><li>可以，但含有指针成员时需要注意。</li><li>对比类的对象赋值时深拷贝和浅拷贝。</li></ul></li><li>结构体内存对齐问题？<ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。</li></ul></li><li>static作用是什么？在C和C++中有何区别？<ul><li>static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。</li><li>C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。</li><li>static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。</li><li>未初始化时，static变量默认值为0。</li></ul></li><li><p>结构体和类的区别？</p><ul><li>结构体的默认限定符是public；类是private。</li></ul><p>- <del>结构体不可以继承，类可以。</del> C++中结构体也可以继承。</p></li><li><p>malloc和new的区别？</p><ul><li>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</li><li>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</li><li>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</li></ul></li><li><p>指针和引用区别？    - 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</p><ul><li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul></li><li><p>宏定义和函数有何区别？</p><ul><li>宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</li><li>宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。</li><li>宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li><li>宏函数不要在最后加分号。</li></ul></li><li><p>宏定义和const区别？</p><ul><li>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</li><li>宏不检查类型；const会检查数据类型。</li><li>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</li></ul></li><li><p>宏定义和typedef区别？</p><ul><li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</li><li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li><li>宏不检查类型；typedef会检查数据类型。</li><li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li><li>注意对指针的操作，typedef char <em> p_char和#define p_char char </em>区别巨大。</li></ul></li><li><p>宏定义和内联函数(inline)区别？</p><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li>内联函数本身是函数，强调函数特性，具有重载等功能。</li><li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</li></ul></li><li><p>条件编译#ifdef, #else, #endif作用？</p><ul><li>可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。</li><li>用于子程序前加#define DEBUG用于程序调试。</li><li>应对硬件的设置（机器类型等）。</li><li>条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。</li></ul></li><li><p>区别以下几种变量？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br><span class="line">const int *a;</span><br><span class="line">int *const a;</span><br></pre></td></tr></table></figure><ul><li>int const a和const int a均表示定义常量类型a。</li><li>const int <em>a，其中a为指向int型变量的指针，const在 </em> 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)</li><li>int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</li></ul></li><li><p>volatile有什么作用？</p><ul><li>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。</li><li>多线程中被几个任务共享的变量需要定义为volatile类型。</li></ul></li><li><p>什么是常引用？</p><ul><li>常引用可以理解为常量指针，形式为const typename &amp; refname = varname。</li><li>常引用下，原变量值不会被别名所修改。</li><li>原变量的值可以通过原名修改。</li><li>常引用通常用作只读变量别名或是形参传递。</li></ul></li><li><p>区别以下指针类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p[10]</span><br><span class="line">int (*p)[10]</span><br><span class="line">int *p(int)</span><br><span class="line">int (*p)(int)</span><br></pre></td></tr></table></figure><ul><li>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li><li>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li><li>int <em>p(int)是函数声明，函数名是p，参数是int类型的，返回值是int </em>类型的。</li><li>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li></ul></li><li><p>常量指针和指针常量区别？</p><ul><li>常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const <em>p或const int </em>p。</li><li>指针常量是一个不能给改变指向的指针。如int *const p。</li></ul></li><li><p>a和&amp;a有什么区别？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设数组int a[10];</span><br><span class="line">int (*p)[10] = &amp;a;</span><br></pre></td></tr></table></figure><ul><li>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。</li><li>&amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若(int <em>)p ，此时输出 </em>p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li></ul></li><li><p>数组名和指针（这里为指向数组首元素的指针）区别？</p><ul><li>二者均可通过增减偏移量来访问数组中的元素。</li><li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li><li>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</li></ul></li><li><p>野指针是什么？</p><ul><li>也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。</li><li>产生原因及解决办法：<ul><li>指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。</li><li>指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</li></ul></li></ul></li><li><p>堆和栈的区别？</p><ul><li>申请方式不同。<ul><li>栈由系统自动分配。</li><li>堆由程序员手动分配。</li></ul></li><li>申请大小限制不同。<ul><li>栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li><li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li></ul></li><li>申请效率不同。<ul><li>栈由系统分配，速度快，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li></ul></li><li><p>delete和delete[]区别？</p><ul><li>delete只会调用一次析构函数。</li><li>delete[]会调用数组中每个元素的析构函数。</li></ul></li></ol><h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><p>能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。</p><ol><li><p>面向对象三大特性？</p><ul><li>封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。</li><li>继承性：让某种类型对象获得另一个类型对象的属性和方法。</li><li>多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</li></ul></li><li><p>public/protected/private的区别？</p><ul><li>public的变量和函数在类的内部外部都可以访问。</li><li>protected的变量和函数只能在类的内部和其派生类中访问。</li><li>private修饰的元素只能在类内访问。</li></ul></li><li><p>对象存储空间？</p><ul><li>非静态成员的数据类型大小之和。</li><li>编译器加入的额外成员变量（如指向虚函数表的指针）。</li><li>为了边缘对齐优化加入的padding。</li></ul></li><li><p>C++空类有哪些成员函数?</p><ul><li>首先，空类大小为1字节。</li><li>默认函数有：<ul><li>构造函数</li><li>析构函数</li><li>拷贝构造函数</li><li>赋值运算符</li></ul></li></ul></li><li><p>构造函数能否为虚函数，析构函数呢？</p><ul><li>析构函数：<ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li><li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul></li><li>构造函数：<ul><li>构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。</li></ul></li></ul></li><li><p>构造函数调用顺序，析构函数呢？</p><ul><li>调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅</li><li>基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。</li><li>如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。</li><li>成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。</li><li>派生类的构造函数。</li><li>析构函数与之相反。</li></ul></li><li><p>拷贝构造函数中深拷贝和浅拷贝区别？</p><ul><li>深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。</li><li>浅拷贝仅仅是拷贝指针字面值。</li><li>当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。</li></ul></li><li><p>拷贝构造函数和赋值运算符重载的区别？</p><ul><li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p></li><li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p></li><li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p></li><li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = s;    // 调用拷贝构造函数</span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    // 赋值运算符操作</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符</strong></p></li><li><p>虚函数和纯虚函数区别？</p><ul><li>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</li><li>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</li></ul></li><li><p>覆盖、重载和隐藏的区别？</p><ul><li>覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。</li><li>隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。</li><li>重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。</li></ul></li><li><p>在main执行之前执行的代码可能是什么？</p><ul><li>全局对象的构造函数。</li></ul></li><li><p>哪几种情况必须用到初始化成员列表？</p><ul><li>初始化一个const成员。</li><li>初始化一个reference成员。</li><li>调用一个基类的构造函数，而该函数有一组参数。</li><li>调用一个数据成员对象的构造函数，而该函数有一组参数。</li></ul></li><li><p>什么是虚指针？</p><ul><li>虚指针或虚函数指针是虚函数的实现细节。</li><li>虚指针指向虚表结构。</li></ul></li><li><p>重载和函数模板的区别？</p><ul><li>重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。</li><li>模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。</li></ul></li><li><p>this指针是什么？</p><ul><li>this指针是类的指针，指向对象的首地址。</li><li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</li><li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</li></ul></li><li><p>类模板是什么？</p><ul><li>用于解决多个功能相同、数据类型不同的类需要重复定义的问题。</li><li>在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。</li><li>类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。</li></ul></li><li><p>构造函数和析构函数调用时机？</p><ul><li>全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。</li><li>局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。</li><li>动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。</li><li>静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。</li></ul></li></ol><hr><h3 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h3><p>STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了：</p><ul><li><p>怎么用？</p><p>各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。</p></li><li><p>怎么实现？</p><p>本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。</p></li><li><p>如何避免错误？</p><p>在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。</p></li></ul><p><strong>string</strong></p><p><strong>vector</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">    vector&lt;T&gt; vec;</span><br><span class="line"></span><br><span class="line">插入元素：</span><br><span class="line">    vec.push_back(element);</span><br><span class="line">    vec.insert(iterator, element);</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    vec.pop_back();</span><br><span class="line">    vec.erase(iterator);</span><br><span class="line"></span><br><span class="line">修改元素：</span><br><span class="line">    vec[position] = element;</span><br><span class="line"></span><br><span class="line">遍历容器：</span><br><span class="line">    for(auto it = vec.begin(); it != vec.end(); ++it) &#123;......&#125;</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">    vec.empty();    //判断是否空</span><br><span class="line">    vec.size();    // 实际元素</span><br><span class="line">    vec.capacity();    // 容器容量</span><br><span class="line">    vec.begin();    // 获得首迭代器</span><br><span class="line">    vec.end();    // 获得尾迭代器</span><br><span class="line">    vec.clear();    // 清空</span><br></pre></td></tr></table></figure><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp" target="_blank" rel="noopener">模拟Vector实现</a></p><ul><li>线性表，数组实现。<ul><li>支持随机访问。</li><li>插入删除操作需要大量移动数据。</li></ul></li><li>需要连续的物理存储空间。</li><li>每当大小不够时，重新分配内存（*2），并复制原内容。</li></ul><p>错误避免：</p><p><a href="https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp" target="_blank" rel="noopener">迭代器失效</a></p><ul><li>插入元素<ul><li>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</li><li>中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</li></ul></li><li>删除元素<ul><li>尾后删除：只有尾迭代失效。</li><li>中间删除：删除位置之后所有迭代失效。</li></ul></li></ul><p><strong>map</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">    map&lt;T_key, T_value&gt; mymap;</span><br><span class="line"></span><br><span class="line">插入元素：</span><br><span class="line">    mymap.insert(pair&lt;T_key, T_value&gt;(key, value));    // 同key不插入</span><br><span class="line">    mymap.insert(map&lt;T_key, T_value&gt;::value_type(key, value));    // 同key不插入</span><br><span class="line">    mymap[key] = value;    // 同key覆盖</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">    mymap.erase(key);    // 按值删</span><br><span class="line">    mymap.erase(iterator);    // 按迭代器删</span><br><span class="line"></span><br><span class="line">修改元素：</span><br><span class="line">    mymap[key] = new_value;</span><br><span class="line"></span><br><span class="line">遍历容器：</span><br><span class="line">      for(auto it = mymap.begin(); it != mymap.end(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &apos;\n&apos;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>实现：</p><p><a href="https://github.com/linw7/Skill-Tree/tree/master/code/RBTree" target="_blank" rel="noopener">RBTree实现</a></p><ul><li>树状结构，RBTree实现。<ul><li>插入删除不需要数据复制。</li><li>操作复杂度仅跟树高有关。</li></ul></li><li>RBTree本身也是二叉排序树的一种，key值有序，且唯一。<ul><li>必须保证key可排序。</li></ul></li></ul><p>基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。</p><p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p><ol><li><p>它是二叉排序树（继承二叉排序树特显）：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ul></li><li><p>它满足如下几点要求：</p><ul><li>树中所有节点非红即黑。</li><li>根节点必为黑节点。</li><li>红节点的子节点必为黑（黑节点子节点可为黑）。</li><li>从根到NULL的任何路径上黑结点数相同。</li></ul></li><li><p>查找时间一定可以控制在O(logn)。</p></li><li><p>红黑树的节点定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    RED = 0,</span><br><span class="line">    BLACK = 1</span><br><span class="line">&#125;;</span><br><span class="line">struct RBTreeNode &#123;</span><br><span class="line">    struct RBTreeNode*left, *right, *parent;</span><br><span class="line">    int key;</span><br><span class="line">    int data;</span><br><span class="line">    Color color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。</p><p>相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</p><p>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高。</p><p><strong>set</strong></p><hr><h3 id="编译及调试"><a href="#编译及调试" class="headerlink" title="编译及调试"></a>编译及调试</h3><p><strong>编译</strong></p><p>预处理</p><ul><li>展开所有的宏定义，完成字符常量替换。</li><li>处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。</li><li>处理#include指令，将被包含的文件插入到该指令所在位置。</li><li>过滤掉所有注释语句。</li><li>添加行号和文件名标识。</li><li>保留所有#pragma编译器指令。</li></ul><p>编译</p><ul><li>词法分析。</li><li>语法分析。</li><li>语义分析。</li><li>中间语言生成。</li><li>目标代码生成与优化。</li></ul><p>链接</p><p>各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。</p><ul><li><p>静态链接</p><p>静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib<em>**</em>.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。</p><p>既然静态链接是对目标文件的打包，这里介绍些打包命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test1.c    // 生成test1.o</span><br><span class="line">gcc -c test2.c    // 生成test2.c</span><br><span class="line">ar cr libtest.a test1.o test2.o</span><br></pre></td></tr></table></figure><p>首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -ltest</span><br></pre></td></tr></table></figure></li><li><p>动态链接</p><p>静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。</p><p>动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c test1.c </span><br><span class="line">gcc -fPIC -c test2.c</span><br><span class="line">gcc -shared test1.o test2.o -o libtest.so</span><br></pre></td></tr></table></figure><p>使用动态链接的用法也和静态链接相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -ltest</span><br></pre></td></tr></table></figure></li></ul><p>如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。</p><p>比较静态库和动态库我们可以得到二者的优缺点。</p><ul><li>动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。</li><li>动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。</li><li>不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。</li></ul><p>makefile编写</p><p>对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。</p><ul><li><p>基本规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:B</span><br><span class="line">(tab)&lt;command&gt;</span><br></pre></td></tr></table></figure><p>其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。</p></li><li><p>变量</p><p>makefile的书写非常像shell脚本，可以在文件中定义”变量名 = 变量值”的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。</p></li></ul><p><strong>链接</strong></p><p>符号解析</p><ul><li><p>可重定位目标文件</p><p>对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。</p></li><li><p>解析符号表</p><p>解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。</p></li></ul><p>重定位</p><ul><li><p>合并节</p><p>多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。</p></li><li><p>重定位符号引用</p><p>这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（”符号”）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。</p></li></ul><p>可执行目标文件</p><ul><li><p>ELF头部</p><p>描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。</p></li><li><p>段头部表</p><p>描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。</p></li><li><p>其他段</p><p>和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。</p></li></ul><p>加载</p><ul><li><p>克隆</p><p>新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。</p></li><li><p>重新映射</p><p>当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。</p></li><li><p>虚页调入</p><p>加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编程基础&quot;&gt;&lt;a href=&quot;#编程基础&quot; class=&quot;headerlink&quot; title=&quot;编程基础&quot;&gt;&lt;/a&gt;编程基础&lt;/h3&gt;&lt;p&gt;C/C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>阿里笔试20190830</title>
    <link href="http://yoursite.com/2019/08/31/%E9%98%BF%E9%87%8C%E7%AC%94%E8%AF%9520190830/"/>
    <id>http://yoursite.com/2019/08/31/阿里笔试20190830/</id>
    <published>2019-08-31T01:10:57.000Z</published>
    <updated>2019-08-31T01:54:09.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择题知识点总结"><a href="#选择题知识点总结" class="headerlink" title="选择题知识点总结"></a>选择题知识点总结</h1><h2 id="网络协议相关"><a href="#网络协议相关" class="headerlink" title="网络协议相关"></a>网络协议相关</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OSI:</span><br><span class="line">物理层：EIA/TIA<span class="number">-232</span>, EIA/TIA<span class="number">-499</span>, V<span class="number">.35</span>, V<span class="number">.24</span>, RJ45, Ethernet, <span class="number">802.3</span>, <span class="number">802.5</span>, FDDI, NRZI, NRZ, B8ZS</span><br><span class="line">数据链路层：Frame Relay, HDLC, PPP, IEEE <span class="number">802.3</span>/<span class="number">802.2</span>, FDDI, ATM,  IEEE <span class="number">802.5</span>/<span class="number">802.2</span>, 【ARP,RARP】</span><br><span class="line">网络层：IP，IPX，AppleTalk DDP</span><br><span class="line">传输层：TCP，UDP，SPX </span><br><span class="line">会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP </span><br><span class="line">表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML </span><br><span class="line">应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP</span><br></pre></td></tr></table></figure><p><img src="/2019/08/31/阿里笔试20190830/12.jpg" alt="12"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</span><br><span class="line"></span><br><span class="line">RPC是基于Socket的，即工作在会话层</span><br><span class="line">RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</span><br><span class="line">反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。网络管理员在局域网网关路由器里创建一个表以映射物理地址（MAC）和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向路由器上的 RARP 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IGMP协议是一个组管理协议，它帮助多播路由器创建以及更新与每一个路由接口相连的忠实成员列表（就是与该路由接口连接频率较高）。ICMP协议实际上就是差错控制协议，弥补了IP协议没有差错纠正机制以及差错报告的缺憾。ARP是一个地址映射协议，可以把一个IP地址映射为MAC地址。</span><br></pre></td></tr></table></figure><h2 id="红黑树相关操作"><a href="#红黑树相关操作" class="headerlink" title="红黑树相关操作"></a>红黑树相关操作</h2><p>参考：<a href="https://blog.csdn.net/weixin_40170902/article/details/80877147" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40170902/article/details/80877147</a></p><h1 id="编程题总结"><a href="#编程题总结" class="headerlink" title="编程题总结"></a>编程题总结</h1><h2 id="第一道"><a href="#第一道" class="headerlink" title="第一道"></a>第一道</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题意：链表跳表 </span><br><span class="line">给出整个实现类的基本框架，补全插入和查找函数</span><br></pre></td></tr></table></figure><p>参考代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> key;</span><br><span class="line">    <span class="keyword">uint64_t</span> value;</span><br><span class="line">    LinkNode* next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkipLinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    LinkNode* pointer = <span class="literal">NULL</span>;</span><br><span class="line">    SkipLinkNode* next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipLinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SkipLinkList(<span class="keyword">int</span> skipStep = <span class="number">128</span>);</span><br><span class="line">    ~SkipLinkList();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">simpleCheck</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkNode* _listHeader = <span class="literal">NULL</span>;</span><br><span class="line">    SkipLinkNode* _skipListHeader = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> _skipStep;</span><br><span class="line">    <span class="keyword">int</span> _itemCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SkipLinkList::SkipLinkList(<span class="keyword">int</span> skipStep)</span><br><span class="line">: _skipStep(skipStep)</span><br><span class="line">, _listHeader(<span class="literal">NULL</span>)</span><br><span class="line">, _skipListHeader(<span class="literal">NULL</span>)</span><br><span class="line">, _itemCount(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SkipLinkList::~SkipLinkList()</span><br><span class="line">&#123;</span><br><span class="line">    LinkNode* node = _listHeader;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkNode* toDelNode = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SkipLinkNode* skipNode = _skipListHeader;</span><br><span class="line">    <span class="keyword">while</span> (skipNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SkipLinkNode* toDelNode = skipNode;</span><br><span class="line">        skipNode = skipNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> SkipLinkList::simpleCheck()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> lastKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nodeCount = <span class="number">0</span>;</span><br><span class="line">    LinkNode* node = _listHeader;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodeCount++;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; lastKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastKey = node-&gt;key;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodeCount &lt; _skipStep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (_skipListHeader == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> skipNodeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> expectNodeCount = <span class="number">0</span>;</span><br><span class="line">    SkipLinkNode* skipNode = _skipListHeader;</span><br><span class="line">    <span class="keyword">while</span> (skipNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        skipNodeCount++;</span><br><span class="line">        <span class="keyword">if</span> (skipNode-&gt;key &lt; lastKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastKey = skipNode-&gt;key;</span><br><span class="line">        expectNodeCount += skipNode-&gt;count;</span><br><span class="line">        skipNode = skipNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeCount == expectNodeCount &amp;&amp;</span><br><span class="line">        skipNodeCount &gt;= ((nodeCount + _skipStep - <span class="number">1</span>) / _skipStep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 请完成下面这个函数，实现题目要求的功能 **/</span></span><br><span class="line"><span class="keyword">void</span> SkipLinkList::insert(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> char</span></span><br><span class="line">    <span class="keyword">if</span>(_skipListHeader==<span class="literal">NULL</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        _listHeader=<span class="keyword">new</span> LinkNode();</span><br><span class="line">        _listHeader-&gt;key=key;</span><br><span class="line">        _listHeader-&gt;value=value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        _skipListHeader=<span class="keyword">new</span> SkipLinkNode();</span><br><span class="line">        _skipListHeader-&gt;key=key;</span><br><span class="line">        _skipListHeader-&gt;count=<span class="number">1</span>;</span><br><span class="line">         _skipListHeader-&gt;pointer=_listHeader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        SkipLinkNode *tmpskiphead=_skipListHeader;</span><br><span class="line">        <span class="keyword">while</span> (tmpskiphead-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmpskiphead=tmpskiphead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//zhodao</span></span><br><span class="line">        LinkNode *tmplistnode=tmpskiphead-&gt;pointer;</span><br><span class="line">        <span class="keyword">while</span> (tmplistnode-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmplistnode=tmplistnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">         LinkNode *newnode=<span class="keyword">new</span> LinkNode();</span><br><span class="line">         newnode-&gt;key=key;</span><br><span class="line">         newnode-&gt;value=value;</span><br><span class="line">         tmplistnode-&gt;next=tmplistnode;</span><br><span class="line">         tmplistnode=tmplistnode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(tmpskiphead-&gt;count&gt;<span class="number">128</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           SkipLinkNode *newskipList=<span class="keyword">new</span> SkipLinkNode();</span><br><span class="line">            _skipListHeader-&gt;key=key;</span><br><span class="line">            _skipListHeader-&gt;count=<span class="number">1</span>;</span><br><span class="line">             _skipListHeader-&gt;pointer=tmplistnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _skipListHeader-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> SkipLinkList::find(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    SkipLinkNode *tmpskiphead=_skipListHeader;</span><br><span class="line">     SkipLinkNode *pre=_skipListHeader;</span><br><span class="line">    <span class="keyword">if</span>(tmpskiphead==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tmpskiphead-&gt;key&lt;key) &#123;</span><br><span class="line">        pre=tmpskiphead;</span><br><span class="line">        tmpskiphead=tmpskiphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmpskiphead-&gt;key==key) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   LinkNode *tmplistnode=pre-&gt;pointer;</span><br><span class="line">   <span class="keyword">while</span> (tmpskiphead-&gt;key&lt;=key) &#123;</span><br><span class="line">       <span class="keyword">if</span>(tmpskiphead-&gt;key==key)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       tmpskiphead=tmpskiphead-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 请完成上面的函数，实现题目要求的功能 **/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sepStr) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(text)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sep</span><span class="params">(sepStr)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="number">0</span>, old = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        n = str.find(sep, n);</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(str.substr(old, n - old));</span><br><span class="line">            n += sep.length();</span><br><span class="line">            old = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec.push_back(str.substr(old, str.length() - old));</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stringToInteger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = text.c_str();</span><br><span class="line">    <span class="keyword">char</span>* endPtr = <span class="literal">NULL</span>;</span><br><span class="line">    value = (T)strtol(str, &amp;endPtr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> (endPtr &amp;&amp; *endPtr == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">testSkipLinkList</span><span class="params">(<span class="built_in">string</span> inputParam)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; inputVec = splitString(inputParam, <span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (inputVec.size() != <span class="number">2</span> || (inputVec[<span class="number">0</span>] != <span class="string">"list"</span> &amp;&amp; inputVec[<span class="number">0</span>] != <span class="string">"count"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input format error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prepare data</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt; &gt; keyValueVec;</span><br><span class="line">    <span class="keyword">if</span> (inputVec[<span class="number">0</span>] == <span class="string">"list"</span>) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; kvVec = splitString(inputVec[<span class="number">1</span>], <span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kvVec.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; kvStr = splitString(kvVec[i], <span class="string">","</span>);</span><br><span class="line">            <span class="keyword">uint64_t</span> key, value;</span><br><span class="line">            <span class="keyword">if</span> (kvStr.size() != <span class="number">2</span> ||</span><br><span class="line">                !stringToInteger&lt;<span class="keyword">uint64_t</span>&gt;(kvStr[<span class="number">0</span>], key) ||</span><br><span class="line">                !stringToInteger&lt;<span class="keyword">uint64_t</span>&gt;(kvStr[<span class="number">1</span>], value))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"key-value list format error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            keyValueVec.push_back(make_pair(key, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputVec[<span class="number">0</span>] == <span class="string">"count"</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> count;</span><br><span class="line">        <span class="keyword">if</span> (!stringToInteger&lt;<span class="keyword">uint64_t</span>&gt;(inputVec[<span class="number">1</span>], count)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"count format error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint64_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            keyValueVec.push_back(make_pair(i, i));</span><br><span class="line">        &#125;</span><br><span class="line">        random_shuffle(keyValueVec.begin(), keyValueVec.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> maxKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function">SkipLinkList <span class="title">list</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; keyValueVec.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>.insert(keyValueVec[i].first, keyValueVec[i].second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test find</span></span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="built_in">list</span>.find(keyValueVec[i].first, value);</span><br><span class="line">        <span class="keyword">if</span> (!ret || value != keyValueVec[i].second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"test find error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// test replace</span></span><br><span class="line">        <span class="built_in">list</span>.insert(keyValueVec[i].first, keyValueVec[i].second + <span class="number">1</span>);</span><br><span class="line">        ret = <span class="built_in">list</span>.find(keyValueVec[i].first, value);</span><br><span class="line">        <span class="keyword">if</span> (!ret || value != keyValueVec[i].second + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"test replace error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxKey = max(maxKey, keyValueVec[i].first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test not exist key</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>.find(maxKey + <span class="number">1</span>, value))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"find not exist error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>.simpleCheck();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line">    <span class="built_in">string</span> _inputParam;</span><br><span class="line">    getline(<span class="built_in">cin</span>, _inputParam);</span><br><span class="line">    res = testSkipLinkList(_inputParam);</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"PASS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"FAIL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题意：飞鸽传书</span><br><span class="line">一只鸽子能发出两种不同的声音，</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  maxbirdmount=<span class="number">20</span>;<span class="comment">//   6 per</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getlocbit</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//最少的位置位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">pow</span>(<span class="number">2</span>,i)&lt;n)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxdatamount</span><span class="params">()</span><span class="comment">//单披最大传输量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i;i++)<span class="comment">//weizhi</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">int</span> birdmount=<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">       <span class="keyword">if</span>(birdmount&gt;maxbirdmount)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       res=max(res,birdmount*(<span class="number">6</span>-i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMinBatchnumber</span><span class="params">(<span class="keyword">int</span> bitlen)</span><span class="comment">//获取最少的批数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  Maxdatamount=GetMaxdatamount();</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)<span class="comment">//批次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Maxdatamount*i&gt;=bitlen)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMmaxSing</span><span class="params">(<span class="keyword">int</span> bitlen )</span><span class="comment">//  在最小批数已知的情况下 每批最小放飞的鸽子数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MinBatchnumber=GetMinBatchnumber(bitlen);</span><br><span class="line">    <span class="keyword">int</span> avgbit=<span class="built_in">ceil</span>(bitlen/MinBatchnumber);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> birdnum=<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">       <span class="keyword">int</span> minlocbit=Getlocbit(birdnum);</span><br><span class="line">       <span class="keyword">if</span>((<span class="number">6</span>-minlocbit)*birdnum&gt;=avgbit)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span>  birdnum;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求放飞批次最小的情况下每批次最小大放飞量</span></span><br><span class="line">    <span class="comment">//放飞批次最小</span></span><br><span class="line">    <span class="keyword">char</span>* str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> bitlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[len]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;;</span><br><span class="line">        len++;</span><br><span class="line">        bitlen=<span class="number">5</span>*len;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;GetMmaxSing(bitlen)&lt;&lt;<span class="string">" "</span>&lt;&lt;GetMinBatchnumber(bitlen)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">个人题意理解：</span><br><span class="line">一只信鸽携带的数据应该包括：信包序号+数据</span><br><span class="line">至于信鸽序号的位数确定：因为信鸽不会丢失，所以解码人可以根据一次接受到的信鸽数来判断信包序号的位数</span><br><span class="line">题意给出的需要传输的字符有31个，所以数据位是5位，因为2^5=32,所以提意我们可以假定用11111表示结束位，如果最后一只信鸽收到的不是结束位，说明还要继续接受下一批次的信鸽，直至收到结束位为止。(抑或将一只信鸽能传输的六位中的最后一位设为接受标志位，不然相对浪费资源，故舍去)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择题知识点总结&quot;&gt;&lt;a href=&quot;#选择题知识点总结&quot; class=&quot;headerlink&quot; title=&quot;选择题知识点总结&quot;&gt;&lt;/a&gt;选择题知识点总结&lt;/h1&gt;&lt;h2 id=&quot;网络协议相关&quot;&gt;&lt;a href=&quot;#网络协议相关&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="校招 笔试 C++ 总结" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B-%E7%AC%94%E8%AF%95-C-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>huawei20190928-笔试</title>
    <link href="http://yoursite.com/2019/08/29/huawei20190928-%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2019/08/29/huawei20190928-笔试/</id>
    <published>2019-08-29T01:26:39.000Z</published>
    <updated>2019-08-29T02:19:42.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给一个周长，求出其能满足的直角三角形有多少种。</span><br><span class="line"></span><br><span class="line">限制：周长&lt;=100000</span><br><span class="line"></span><br><span class="line">时间限制：&lt;1s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long  num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    double yy;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(x=1;x&lt;num/3;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        yy=1.0*(((num*num)-2*num*x))/(2*num-2*x);</span><br><span class="line">        if(yy-floor(yy)&gt;1e-10)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        y=(int)yy;</span><br><span class="line">        z=num-x-y;</span><br><span class="line">        if(x&lt;=y&amp;&amp;y&lt;z)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note：</span><br><span class="line"><span class="number">1.</span>防止运算过程中数据溢出。</span><br><span class="line"><span class="number">2.</span><span class="keyword">double</span>是不精确的，所以不能将之与某个数值相比，必须确定一个极小区间如<span class="number">1e-8</span>，比如<span class="keyword">if</span>(x-<span class="built_in">floor</span>(x)&gt;<span class="number">1e-8</span>)</span><br></pre></td></tr></table></figure><h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">水题</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">5</span>][<span class="number">5</span>]=&#123;    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,    &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,    &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>&#125;,    &#123;<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>&#125;,    &#123;<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>,<span class="number">45</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> mask[<span class="number">5</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> movex[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> movey[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    mask[x][y]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)   &#123;</span><br><span class="line">        <span class="keyword">if</span>(x+movex[i]&lt;<span class="number">0</span>||x+movex[i]&gt;<span class="number">4</span>||y+movey[i]&lt;<span class="number">0</span>||x+movey[i]&gt;<span class="number">4</span>)       &#123;</span><br><span class="line">            <span class="keyword">continue</span>;       &#125;</span><br><span class="line">        <span class="keyword">if</span>(mask[x+movex[i]][y+movey[i]]==<span class="number">-1</span>)       &#123;</span><br><span class="line">            <span class="keyword">continue</span>;       &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mask[x+movex[i]][y+movey[i]]==<span class="number">1</span>)       &#123;</span><br><span class="line">            solve(x+movex[i],y+movey[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa,b,c,d,e,f;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;aa&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">6</span>]=&#123;aa,b,c,d,e,f&#125;;</span><br><span class="line">        sort(a,a+<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">int</span> loc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startx,starty;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)            &#123;</span><br><span class="line">                <span class="keyword">if</span>(loc&lt;<span class="number">6</span>&amp;&amp;table[i][j]==a[loc])               &#123;</span><br><span class="line">                    loc++;</span><br><span class="line">                    mask[i][j]=<span class="number">1</span>;</span><br><span class="line">                    startx=i;</span><br><span class="line">                    starty=j;</span><br><span class="line">                &#125;               <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mask[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solve(startx,starty);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)   &#123;</span><br><span class="line">                <span class="keyword">if</span>(mask[i][j]==<span class="number">-1</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">6</span>)        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;        <span class="keyword">else</span>        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">俩整数数组，二者元素全部相同，仅顺序不同，求删去最少的元素使得俩整数数组相等。</span><br><span class="line">比如&#123;1，3，2&#125;、&#123;3，2，1&#125;，最少删去1后&#123;3、2&#125;&#123;3，2&#125;相同符合要求，所以结果为1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="keyword">int</span> *table1=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="keyword">int</span> *table2=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="keyword">int</span> *dp=<span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;locmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;table1[i];</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;table2[i];</span><br><span class="line">        locmap[table2[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxlts=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(locmap[table1[i]]&gt;locmap[table1[j]])</span><br><span class="line">           &#123;</span><br><span class="line">               dp[i]=max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlts=max(maxlts,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num-maxlts&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">欢迎找出反例</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="校招 C++" scheme="http://yoursite.com/tags/%E6%A0%A1%E6%8B%9B-C/"/>
    
  </entry>
  
</feed>
